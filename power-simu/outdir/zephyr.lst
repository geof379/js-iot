
zephyr.elf:     file format elf32-iamcu


Disassembly of section text:

40030000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
40030000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
40030003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
40030008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
4003000b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */

	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
4003000c:	0f 01 15 80 00 03 40 	lgdtl  0x40030080
	lidt	_Idt		/* load 32-bit operand size IDT */
40030013:	0f 01 1d 6d 00 03 40 	lidtl  0x4003006d
	 *
	 * This is a special case for the ia32 platform, which must work for
	 * multiple platforms (QEMU, generic PC board, etc.). With other
	 * platforms the bootloader is well known so assumptions can be made.
	 */
	movw	$0x10, %ax	/* data segment selector (entry = 3) */
4003001a:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
4003001e:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
40030020:	8e c0                	mov    %eax,%es
	movw	%ax, %fs	/* set FS */
40030022:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* set GS */
40030024:	8e e8                	mov    %eax,%gs
	movw	%ax, %ss	/* set SS */
40030026:	8e d0                	mov    %eax,%ss

	ljmp	$0x08, $__csSet	/* set CS = 0x08 */
40030028:	ea 2f 00 03 40 08 00 	ljmp   $0x8,$0x4003002f

4003002f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
4003002f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
40030032:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
40030035:	0f 22 c0             	mov    %eax,%cr0
	 * Note: __data_num_words is a multiple of 4 bytes
	 *       rounded up to next 4 bytes.
	 *	 Note: the sections might not be 4 byte aligned.
	 */

	movl	$__data_ram_start, %edi /* DATA in RAM (dest) */
40030038:	bf 00 64 00 a8       	mov    $0xa8006400,%edi
	movl	$__data_rom_start, %esi /* DATA in ROM (src) */
4003003d:	be 40 33 03 40       	mov    $0x40033340,%esi
	movl	$__data_num_words, %ecx /* Size of DATA in quad bytes */
40030042:	b9 46 00 00 00       	mov    $0x46,%ecx
	je	copyDataDone
40030047:	74 02                	je     4003004b <copyDataDone>
dataWords:
	movl	%edx, %ecx	/* restore # quad bytes */
	andl	$0x3, %ecx	/* only need to copy at most 3 quad bytes */
  #endif /* CONFIG_SSE */

	rep
40030049:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

4003004b <copyDataDone>:

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
4003004b:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
4003004d:	bf 20 65 00 a8       	mov    $0xa8006520,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
40030052:	b9 cd 01 00 00       	mov    $0x1cd,%ecx
	cld
40030057:	fc                   	cld    
	rep
40030058:	f3 ab                	rep stos %eax,%es:(%edi)

4003005a <memInitDone>:
	 * _Cstart(), i.e. only until the multi-tasking kernel is
	 * initialized.  The dual-purposing of this area of memory is safe since
	 * interrupts are disabled until the first context switch.
	 */

	movl	$_interrupt_stack, %esp
4003005a:	bc 80 6c 00 a8       	mov    $0xa8006c80,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
4003005f:	81 c4 00 08 00 00    	add    $0x800,%esp

	/* align to stack boundary: ROUND_DOWN (%esp, 4) */

	andl	$0xfffffffc, %esp
40030065:	83 e4 fc             	and    $0xfffffffc,%esp
	pushl	$_Cstart
	call	_AdvIdleStart
#else
	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
40030068:	e9 12 1b 00 00       	jmp    40031b7f <_Cstart>

4003006d <_Idt>:
4003006d:	ff 07 c0 2a 03 40 90 02 b0 ad 1b 00 00 00 00 fe     ...*.@..........
4003007d:	4f 52 e4                                            OR.

40030080 <_gdt>:
40030080:	17 00 90 00 03 40 8d 76 00 8d bc 27 00 00 00 00     .....@.v...'....

40030090 <_gdt_rom_entries>:
	...
40030098:	ff                   	(bad)  
40030099:	ff 00                	incl   (%eax)
4003009b:	00 00                	add    %al,(%eax)
4003009d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
400300a4:	00 92 cf 00 55 89    	add    %dl,-0x76aaff31(%edx)

400300a8 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
400300a8:	55                   	push   %ebp
400300a9:	89 e5                	mov    %esp,%ebp
400300ab:	53                   	push   %ebx
400300ac:	89 c3                	mov    %eax,%ebx
	uart_poll_out(uart_console_dev, (unsigned char)c);
400300ae:	a1 20 65 00 a8       	mov    0xa8006520,%eax
					  unsigned char out_char)
{
	struct uart_driver_api *api;

	api = (struct uart_driver_api *)dev->driver_api;
	return api->poll_out(dev, out_char);
400300b3:	0f b6 d3             	movzbl %bl,%edx
400300b6:	8b 48 04             	mov    0x4(%eax),%ecx
400300b9:	ff 51 04             	call   *0x4(%ecx)
	if ('\n' == c) {
400300bc:	83 fb 0a             	cmp    $0xa,%ebx
400300bf:	75 10                	jne    400300d1 <console_out+0x29>
		uart_poll_out(uart_console_dev, (unsigned char)'\r');
400300c1:	a1 20 65 00 a8       	mov    0xa8006520,%eax
400300c6:	ba 0d 00 00 00       	mov    $0xd,%edx
400300cb:	8b 48 04             	mov    0x4(%eax),%ecx
400300ce:	ff 51 04             	call   *0x4(%ecx)
	}
	return c;
}
400300d1:	89 d8                	mov    %ebx,%eax
400300d3:	5b                   	pop    %ebx
400300d4:	5d                   	pop    %ebp
400300d5:	c3                   	ret    

400300d6 <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
400300d6:	55                   	push   %ebp
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
400300d7:	b8 a8 00 03 40       	mov    $0x400300a8,%eax
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
400300dc:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
}
400300de:	5d                   	pop    %ebp
 */

void uart_console_hook_install(void)
{
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
400300df:	e9 60 1e 00 00       	jmp    40031f44 <__printk_hook_install>

400300e4 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return DEV_OK if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
400300e4:	55                   	push   %ebp
	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400300e5:	b8 60 27 03 40       	mov    $0x40032760,%eax
 * @brief Initialize one UART as the console/debug port
 *
 * @return DEV_OK if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
400300ea:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
400300ec:	e8 df 1b 00 00       	call   40031cd0 <device_get_binding>
400300f1:	a3 20 65 00 a8       	mov    %eax,0xa8006520

	uart_console_hook_install();
400300f6:	e8 db ff ff ff       	call   400300d6 <uart_console_hook_install>

	return DEV_OK;
}
400300fb:	31 c0                	xor    %eax,%eax
400300fd:	5d                   	pop    %ebp
400300fe:	c3                   	ret    

400300ff <ipm_console_fiber>:
#include <stdio.h>
#include <ipm.h>
#include <console/ipm_console.h>

static void ipm_console_fiber(int arg1, int arg2)
{
400300ff:	55                   	push   %ebp
40030100:	89 e5                	mov    %esp,%ebp
40030102:	57                   	push   %edi
40030103:	56                   	push   %esi
40030104:	53                   	push   %ebx
40030105:	83 ec 10             	sub    $0x10,%esp
40030108:	89 c7                	mov    %eax,%edi
	struct ipm_console_receiver_config_info *config_info;
	struct ipm_console_receiver_runtime_data *driver_data;
	int pos;

	d = (struct device *)arg1;
	driver_data = d->driver_data;
4003010a:	8b 40 08             	mov    0x8(%eax),%eax
	config_info = d->config->config_info;
	ARG_UNUSED(arg2);
	size32 = 0;
4003010d:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
	struct ipm_console_receiver_config_info *config_info;
	struct ipm_console_receiver_runtime_data *driver_data;
	int pos;

	d = (struct device *)arg1;
	driver_data = d->driver_data;
40030111:	89 45 ec             	mov    %eax,-0x14(%ebp)
	config_info = d->config->config_info;
40030114:	8b 07                	mov    (%edi),%eax
	ARG_UNUSED(arg2);
	size32 = 0;
	pos = 0;
40030116:	31 db                	xor    %ebx,%ebx
	struct ipm_console_receiver_runtime_data *driver_data;
	int pos;

	d = (struct device *)arg1;
	driver_data = d->driver_data;
	config_info = d->config->config_info;
40030118:	8b 70 08             	mov    0x8(%eax),%esi
	ARG_UNUSED(arg2);
	size32 = 0;
	pos = 0;

	while (1) {
		nano_fiber_sem_take(&driver_data->sem, TICKS_UNLIMITED);
4003011b:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003011e:	83 c0 18             	add    $0x18,%eax
40030121:	89 45 e4             	mov    %eax,-0x1c(%ebp)
40030124:	83 ca ff             	or     $0xffffffff,%edx
40030127:	8b 45 e4             	mov    -0x1c(%ebp),%eax
4003012a:	e8 e1 1a 00 00       	call   40031c10 <_sem_take>

		ret = sys_ring_buf_get(&driver_data->rb, &type,
4003012f:	8b 4e 10             	mov    0x10(%esi),%ecx
40030132:	8d 45 f1             	lea    -0xf(%ebp),%eax
40030135:	01 d9                	add    %ebx,%ecx
40030137:	50                   	push   %eax
40030138:	8d 55 f2             	lea    -0xe(%ebp),%edx
4003013b:	8b 45 ec             	mov    -0x14(%ebp),%eax
4003013e:	6a 00                	push   $0x0
40030140:	e8 eb 1c 00 00       	call   40031e30 <sys_ring_buf_get>
40030145:	59                   	pop    %ecx
				       (uint8_t *)&config_info->line_buf[pos],
				       NULL, &size32);
		if (ret) {
40030146:	85 c0                	test   %eax,%eax
	pos = 0;

	while (1) {
		nano_fiber_sem_take(&driver_data->sem, TICKS_UNLIMITED);

		ret = sys_ring_buf_get(&driver_data->rb, &type,
40030148:	5a                   	pop    %edx
				       (uint8_t *)&config_info->line_buf[pos],
				       NULL, &size32);
		if (ret) {
40030149:	74 13                	je     4003015e <ipm_console_fiber+0x5f>
			/* Shouldn't ever happen... */
			printk("ipm console ring buffer error: %d\n", ret);
4003014b:	50                   	push   %eax
4003014c:	68 67 27 03 40       	push   $0x40032767
40030151:	e8 f8 1d 00 00       	call   40031f4e <printk>
40030156:	58                   	pop    %eax
			size32 = 0;
40030157:	c6 45 f1 00          	movb   $0x0,-0xf(%ebp)
		ret = sys_ring_buf_get(&driver_data->rb, &type,
				       (uint8_t *)&config_info->line_buf[pos],
				       NULL, &size32);
		if (ret) {
			/* Shouldn't ever happen... */
			printk("ipm console ring buffer error: %d\n", ret);
4003015b:	5a                   	pop    %edx
			size32 = 0;
			continue;
4003015c:	eb c6                	jmp    40030124 <ipm_console_fiber+0x25>
		}

		if (config_info->line_buf[pos] == '\n' ||
4003015e:	8b 4e 10             	mov    0x10(%esi),%ecx
40030161:	8d 04 19             	lea    (%ecx,%ebx,1),%eax
40030164:	89 45 e8             	mov    %eax,-0x18(%ebp)
40030167:	80 38 0a             	cmpb   $0xa,(%eax)
4003016a:	8b 46 14             	mov    0x14(%esi),%eax
4003016d:	74 07                	je     40030176 <ipm_console_fiber+0x77>
4003016f:	8d 50 fe             	lea    -0x2(%eax),%edx
40030172:	39 d3                	cmp    %edx,%ebx
40030174:	75 53                	jne    400301c9 <ipm_console_fiber+0xca>
		    pos == config_info->lb_size - 2) {
			if (pos != config_info->lb_size - 2) {
40030176:	83 e8 02             	sub    $0x2,%eax
40030179:	39 c3                	cmp    %eax,%ebx
4003017b:	74 08                	je     40030185 <ipm_console_fiber+0x86>
				config_info->line_buf[pos] = '\0';
4003017d:	8b 45 e8             	mov    -0x18(%ebp),%eax
40030180:	c6 00 00             	movb   $0x0,(%eax)
40030183:	eb 05                	jmp    4003018a <ipm_console_fiber+0x8b>
			} else {
				config_info->line_buf[pos + 1] = '\0';
40030185:	c6 44 19 01 00       	movb   $0x0,0x1(%ecx,%ebx,1)
			}
			if (config_info->flags & IPM_CONSOLE_PRINTK) {
4003018a:	f6 46 18 02          	testb  $0x2,0x18(%esi)
4003018e:	74 14                	je     400301a4 <ipm_console_fiber+0xa5>
				printk("%s: '%s'\n", d->config->name,
40030190:	ff 76 10             	pushl  0x10(%esi)
40030193:	8b 07                	mov    (%edi),%eax
40030195:	ff 30                	pushl  (%eax)
40030197:	68 8a 27 03 40       	push   $0x4003278a
4003019c:	e8 ad 1d 00 00       	call   40031f4e <printk>
400301a1:	83 c4 0c             	add    $0xc,%esp
			}
			if (config_info->flags & IPM_CONSOLE_STDOUT) {
				printf("%s: '%s'\n", d->config->name,
				       config_info->line_buf);
			}
			pos = 0;
400301a4:	31 db                	xor    %ebx,%ebx
			}
			if (config_info->flags & IPM_CONSOLE_PRINTK) {
				printk("%s: '%s'\n", d->config->name,
				       config_info->line_buf);
			}
			if (config_info->flags & IPM_CONSOLE_STDOUT) {
400301a6:	f6 46 18 01          	testb  $0x1,0x18(%esi)
400301aa:	0f 84 74 ff ff ff    	je     40030124 <ipm_console_fiber+0x25>
				printf("%s: '%s'\n", d->config->name,
400301b0:	ff 76 10             	pushl  0x10(%esi)
400301b3:	8b 07                	mov    (%edi),%eax
400301b5:	ff 30                	pushl  (%eax)
400301b7:	68 8a 27 03 40       	push   $0x4003278a
400301bc:	e8 59 07 00 00       	call   4003091a <printf>
400301c1:	83 c4 0c             	add    $0xc,%esp
400301c4:	e9 5b ff ff ff       	jmp    40030124 <ipm_console_fiber+0x25>
				       config_info->line_buf);
			}
			pos = 0;
		} else {
			++pos;
400301c9:	43                   	inc    %ebx
400301ca:	e9 55 ff ff ff       	jmp    40030124 <ipm_console_fiber+0x25>

400301cf <ipm_console_receive_callback>:
	}
}

static void ipm_console_receive_callback(void *context, uint32_t id,
					 volatile void *data)
{
400301cf:	55                   	push   %ebp
400301d0:	89 e5                	mov    %esp,%ebp
400301d2:	53                   	push   %ebx
	struct device *d;
	struct ipm_console_receiver_runtime_data *driver_data;

	ARG_UNUSED(data);
	d = context;
	driver_data = d->driver_data;
400301d3:	8b 58 08             	mov    0x8(%eax),%ebx
	if (!sys_ring_buf_put(&driver_data->rb, 0, id, NULL, 0)) {
400301d6:	6a 00                	push   $0x0
400301d8:	0f b6 ca             	movzbl %dl,%ecx
400301db:	89 d8                	mov    %ebx,%eax
400301dd:	31 d2                	xor    %edx,%edx
400301df:	6a 00                	push   $0x0
400301e1:	e8 88 1b 00 00       	call   40031d6e <sys_ring_buf_put>
400301e6:	5a                   	pop    %edx
400301e7:	85 c0                	test   %eax,%eax
400301e9:	59                   	pop    %ecx
400301ea:	75 0c                	jne    400301f8 <ipm_console_receive_callback+0x29>
		nano_isr_sem_give(&driver_data->sem);
400301ec:	8d 43 18             	lea    0x18(%ebx),%eax
	}
}
400301ef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400301f2:	c9                   	leave  

	ARG_UNUSED(data);
	d = context;
	driver_data = d->driver_data;
	if (!sys_ring_buf_put(&driver_data->rb, 0, id, NULL, 0)) {
		nano_isr_sem_give(&driver_data->sem);
400301f3:	e9 5e 1a 00 00       	jmp    40031c56 <_sem_give_non_preemptible>
	}
}
400301f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
400301fb:	c9                   	leave  
400301fc:	c3                   	ret    

400301fd <ipm_console_receiver_init>:


int ipm_console_receiver_init(struct device *d)
{
400301fd:	55                   	push   %ebp
400301fe:	89 e5                	mov    %esp,%ebp
40030200:	57                   	push   %edi
40030201:	56                   	push   %esi
40030202:	53                   	push   %ebx
40030203:	51                   	push   %ecx
40030204:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct ipm_console_receiver_config_info *config_info =
40030207:	8b 00                	mov    (%eax),%eax
40030209:	8b 70 08             	mov    0x8(%eax),%esi
		d->config->config_info;
	struct ipm_console_receiver_runtime_data *driver_data = d->driver_data;
4003020c:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003020f:	8b 78 08             	mov    0x8(%eax),%edi
	struct device *ipm;

	ipm = device_get_binding(config_info->bind_to);
40030212:	8b 06                	mov    (%esi),%eax
40030214:	e8 b7 1a 00 00       	call   40031cd0 <device_get_binding>

	if (!ipm) {
40030219:	85 c0                	test   %eax,%eax
4003021b:	75 16                	jne    40030233 <ipm_console_receiver_init+0x36>
		printk("unable to bind IPM console receiver to '%s'\n",
4003021d:	ff 36                	pushl  (%esi)
4003021f:	68 f8 27 03 40       	push   $0x400327f8
40030224:	68 94 27 03 40       	push   $0x40032794
40030229:	e8 20 1d 00 00       	call   40031f4e <printk>
4003022e:	83 c4 0c             	add    $0xc,%esp
40030231:	eb 1d                	jmp    40030250 <ipm_console_receiver_init+0x53>
static inline uint32_t ipm_max_id_val_get(struct device *ipmdev)
{
	struct ipm_driver_api *api;

	api = (struct ipm_driver_api *) ipmdev->driver_api;
	return api->max_id_val_get(ipmdev);
40030233:	8b 48 04             	mov    0x4(%eax),%ecx
40030236:	89 c3                	mov    %eax,%ebx
40030238:	ff 51 0c             	call   *0xc(%ecx)
		       __func__, config_info->bind_to);
		return DEV_INVALID_CONF;
	}

	if (ipm_max_id_val_get(ipm) < 0xFF) {
4003023b:	3d fe 00 00 00       	cmp    $0xfe,%eax
40030240:	77 15                	ja     40030257 <ipm_console_receiver_init+0x5a>
		printk("IPM driver %s doesn't support 8-bit id values",
40030242:	ff 36                	pushl  (%esi)
40030244:	68 c1 27 03 40       	push   $0x400327c1
40030249:	e8 00 1d 00 00       	call   40031f4e <printk>
4003024e:	58                   	pop    %eax
4003024f:	5a                   	pop    %edx
		       config_info->bind_to);
		return DEV_INVALID_CONF;
40030250:	b8 03 00 00 00       	mov    $0x3,%eax
40030255:	eb 7e                	jmp    400302d5 <ipm_console_receiver_init+0xd8>
	}

	nano_sem_init(&driver_data->sem);
40030257:	8d 47 18             	lea    0x18(%edi),%eax
4003025a:	e8 35 1a 00 00       	call   40031c94 <nano_sem_init>
	sys_ring_buf_init(&driver_data->rb, config_info->rb_size32,
4003025f:	8b 46 0c             	mov    0xc(%esi),%eax
40030262:	8b 4e 08             	mov    0x8(%esi),%ecx
#define min(a, b) (((a) < (b)) ? (a) : (b))
#endif

static inline int is_power_of_two(unsigned int x)
{
	return (x != 0) && !(x & (x - 1));
40030265:	85 c0                	test   %eax,%eax
 *	  uint32_t data[size]
 */
static inline void sys_ring_buf_init(struct ring_buf *buf, uint32_t size,
				     uint32_t *data)
{
	buf->head = 0;
40030267:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	buf->tail = 0;
4003026d:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
	buf->dropped_put_count = 0;
40030274:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%edi)
	buf->size = size;
4003027b:	89 47 0c             	mov    %eax,0xc(%edi)
	buf->buf = data;
4003027e:	89 4f 10             	mov    %ecx,0x10(%edi)
40030281:	74 49                	je     400302cc <ipm_console_receiver_init+0xcf>
40030283:	8d 48 ff             	lea    -0x1(%eax),%ecx
40030286:	85 c8                	test   %ecx,%eax
40030288:	75 42                	jne    400302cc <ipm_console_receiver_init+0xcf>
	if (is_power_of_two(size)) {
		buf->mask = size - 1;
4003028a:	89 4f 14             	mov    %ecx,0x14(%edi)
					 ipm_callback_t cb, void *context)
{
	struct ipm_driver_api *api;

	api = (struct ipm_driver_api *) ipmdev->driver_api;
	api->register_callback(ipmdev, cb, context);
4003028d:	8b 7b 04             	mov    0x4(%ebx),%edi
40030290:	8b 4d f0             	mov    -0x10(%ebp),%ecx
40030293:	ba cf 01 03 40       	mov    $0x400301cf,%edx
40030298:	89 d8                	mov    %ebx,%eax
4003029a:	ff 57 04             	call   *0x4(%edi)
			  config_info->ring_buf_data);

	ipm_register_callback(ipm, ipm_console_receive_callback, d);

	task_fiber_start(config_info->fiber_stack, IPM_CONSOLE_STACK_SIZE,
4003029d:	8b 46 04             	mov    0x4(%esi),%eax
400302a0:	6a 00                	push   $0x0
400302a2:	6a 02                	push   $0x2
400302a4:	6a 00                	push   $0x0
400302a6:	b9 ff 00 03 40       	mov    $0x400300ff,%ecx
400302ab:	ff 75 f0             	pushl  -0x10(%ebp)
400302ae:	ba 00 02 00 00       	mov    $0x200,%edx
400302b3:	e8 42 16 00 00       	call   400318fa <_fiber_start>
static inline int ipm_set_enabled(struct device *ipmdev, int enable)
{
	struct ipm_driver_api *api;

	api = (struct ipm_driver_api *) ipmdev->driver_api;
	return api->set_enabled(ipmdev, enable);
400302b8:	8b 4b 04             	mov    0x4(%ebx),%ecx
400302bb:	83 c4 10             	add    $0x10,%esp
400302be:	ba 01 00 00 00       	mov    $0x1,%edx
400302c3:	89 d8                	mov    %ebx,%eax
400302c5:	ff 51 10             	call   *0x10(%ecx)
			 ipm_console_fiber, (int)d, 0,
			 IPM_CONSOLE_PRI, 0);
	ipm_set_enabled(ipm, 1);

	return DEV_OK;
400302c8:	31 c0                	xor    %eax,%eax
400302ca:	eb 09                	jmp    400302d5 <ipm_console_receiver_init+0xd8>
	} else {
		buf->mask = 0;
400302cc:	c7 47 14 00 00 00 00 	movl   $0x0,0x14(%edi)
400302d3:	eb b8                	jmp    4003028d <ipm_console_receiver_init+0x90>
}
400302d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
400302d8:	5b                   	pop    %ebx
400302d9:	5e                   	pop    %esi
400302da:	5f                   	pop    %edi
400302db:	5d                   	pop    %ebp
400302dc:	c3                   	ret    

400302dd <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return DEV_OK if successful, failed othersie
 */
static int uart_ns16550_init(struct device *dev)
{
400302dd:	55                   	push   %ebp
400302de:	89 c1                	mov    %eax,%ecx
400302e0:	89 e5                	mov    %esp,%ebp
400302e2:	57                   	push   %edi
400302e3:	56                   	push   %esi
400302e4:	53                   	push   %ebx
400302e5:	83 ec 0c             	sub    $0xc,%esp
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
400302e8:	8b 70 08             	mov    0x8(%eax),%esi

	if (!ns16550_pci_uart_scan(dev)) {
		return DEV_INVALID_OP;
	}

	dev_data->iir_cache = 0;
400302eb:	c6 46 05 00          	movb   $0x0,0x5(%esi)

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400302ef:	9c                   	pushf  
400302f0:	fa                   	cli    
400302f1:	8f 45 e8             	popl   -0x18(%ebp)

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
400302f4:	8b 1e                	mov    (%esi),%ebx
{
	struct uart_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
400302f6:	85 db                	test   %ebx,%ebx
400302f8:	74 41                	je     4003033b <uart_ns16550_init+0x5e>
}
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	struct uart_device_config * const dev_cfg = DEV_CFG(dev);
400302fa:	8b 00                	mov    (%eax),%eax
400302fc:	8b 78 08             	mov    0x8(%eax),%edi
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
400302ff:	8b 47 04             	mov    0x4(%edi),%eax
40030302:	85 c0                	test   %eax,%eax
40030304:	74 35                	je     4003033b <uart_ns16550_init+0x5e>
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	struct uart_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
40030306:	8b 51 08             	mov    0x8(%ecx),%edx
static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
40030309:	8b 3f                	mov    (%edi),%edi
4003030b:	89 55 ec             	mov    %edx,-0x14(%ebp)
	uint32_t divisor; /* baud rate divisor */

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
4003030e:	31 d2                	xor    %edx,%edx
40030310:	f7 f3                	div    %ebx
40030312:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
40030315:	b2 80                	mov    $0x80,%dl
40030317:	c1 e8 04             	shr    $0x4,%eax
4003031a:	88 57 0c             	mov    %dl,0xc(%edi)

		/* set the DLAB to access the baud rate divisor registers */
		OUTBYTE(LCR(dev), LCR_DLAB);
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
4003031d:	8b 11                	mov    (%ecx),%edx
4003031f:	8b 52 08             	mov    0x8(%edx),%edx
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
40030322:	8b 12                	mov    (%edx),%edx
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
40030324:	88 02                	mov    %al,(%edx)
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));
40030326:	8b 11                	mov    (%ecx),%edx
40030328:	8b 45 f0             	mov    -0x10(%ebp),%eax
4003032b:	c1 e8 0c             	shr    $0xc,%eax
4003032e:	8b 52 08             	mov    0x8(%edx),%edx
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
40030331:	8b 12                	mov    (%edx),%edx
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
40030333:	88 42 04             	mov    %al,0x4(%edx)

		dev_data->baud_rate = baud_rate;
40030336:	8b 45 ec             	mov    -0x14(%ebp),%eax
40030339:	89 18                	mov    %ebx,(%eax)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
4003033b:	8b 01                	mov    (%ecx),%eax
4003033d:	8b 40 08             	mov    0x8(%eax),%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
40030340:	8b 10                	mov    (%eax),%edx
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
40030342:	b0 03                	mov    $0x3,%al
40030344:	88 42 0c             	mov    %al,0xc(%edx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
40030347:	8a 46 04             	mov    0x4(%esi),%al
		mdc |= MCR_AFCE;

	OUTBYTE(MDC(dev), mdc);
4003034a:	8b 11                	mov    (%ecx),%edx

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
4003034c:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
4003034f:	3c 01                	cmp    $0x1,%al

	OUTBYTE(MDC(dev), mdc);
40030351:	8b 52 08             	mov    0x8(%edx),%edx
	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
		mdc |= MCR_AFCE;
40030354:	19 c0                	sbb    %eax,%eax
40030356:	83 e0 e0             	and    $0xffffffe0,%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
40030359:	8b 12                	mov    (%edx),%edx
4003035b:	83 c0 2b             	add    $0x2b,%eax
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
4003035e:	88 42 10             	mov    %al,0x10(%edx)
	/*
	 * Program FIFO: enabled, mode 0 (set for compatibility with quark),
	 * generate the interrupt at 8th byte
	 * Clear TX and RX FIFO
	 */
	OUTBYTE(FCR(dev),
40030361:	8b 01                	mov    (%ecx),%eax
40030363:	8b 40 08             	mov    0x8(%eax),%eax
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
40030366:	8b 10                	mov    (%eax),%edx
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
40030368:	b0 87                	mov    $0x87,%al
4003036a:	88 42 08             	mov    %al,0x8(%edx)
		FCR_FIFO | FCR_MODE0 | FCR_FIFO_8 | FCR_RCVRCLR | FCR_XMITCLR);

	/* clear the port */
	INBYTE(RDR(dev));
4003036d:	8b 01                	mov    (%ecx),%eax
4003036f:	8b 40 08             	mov    0x8(%eax),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
40030372:	8b 00                	mov    (%eax),%eax
static inline __attribute__((always_inline))
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
40030374:	8a 00                	mov    (%eax),%al

	/* disable interrupts  */
	OUTBYTE(IER(dev), 0x00);
40030376:	8b 01                	mov    (%ecx),%eax
40030378:	8b 40 08             	mov    0x8(%eax),%eax
static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
4003037b:	8b 10                	mov    (%eax),%edx
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
4003037d:	31 c0                	xor    %eax,%eax
4003037f:	88 42 04             	mov    %al,0x4(%edx)
 *
 */

static inline __attribute__((always_inline)) void irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
40030382:	f7 45 e8 00 02 00 00 	testl  $0x200,-0x18(%ebp)
40030389:	74 01                	je     4003038c <uart_ns16550_init+0xaf>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
4003038b:	fb                   	sti    

	irq_unlock(old_level);

	dev->driver_api = &uart_ns16550_driver_api;
4003038c:	c7 41 04 20 64 00 a8 	movl   $0xa8006420,0x4(%ecx)

	return DEV_OK;
}
40030393:	83 c4 0c             	add    $0xc,%esp
40030396:	31 c0                	xor    %eax,%eax
40030398:	5b                   	pop    %ebx
40030399:	5e                   	pop    %esi
4003039a:	5f                   	pop    %edi
4003039b:	5d                   	pop    %ebp
4003039c:	c3                   	ret    

4003039d <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
4003039d:	55                   	push   %ebp
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
4003039e:	8b 08                	mov    (%eax),%ecx
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
400303a0:	89 e5                	mov    %esp,%ebp
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
400303a2:	8b 49 08             	mov    0x8(%ecx),%ecx
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
400303a5:	8b 09                	mov    (%ecx),%ecx
static inline __attribute__((always_inline))
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
400303a7:	8a 49 14             	mov    0x14(%ecx),%cl
400303aa:	80 e1 01             	and    $0x1,%cl
400303ad:	74 0f                	je     400303be <uart_ns16550_poll_in+0x21>
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
400303af:	8b 00                	mov    (%eax),%eax
400303b1:	8b 40 08             	mov    0x8(%eax),%eax
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
400303b4:	8b 00                	mov    (%eax),%eax
static inline __attribute__((always_inline))
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
400303b6:	8a 00                	mov    (%eax),%al
400303b8:	88 02                	mov    %al,(%edx)

	return 0;
400303ba:	31 c0                	xor    %eax,%eax
400303bc:	eb 03                	jmp    400303c1 <uart_ns16550_poll_in+0x24>
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
		return (-1);
400303be:	83 c8 ff             	or     $0xffffffff,%eax

	/* got a character */
	*c = INBYTE(RDR(dev));

	return 0;
}
400303c1:	5d                   	pop    %ebp
400303c2:	c3                   	ret    

400303c3 <uart_ns16550_poll_out>:
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
400303c3:	55                   	push   %ebp
400303c4:	89 e5                	mov    %esp,%ebp
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
400303c6:	8b 08                	mov    (%eax),%ecx
400303c8:	8b 49 08             	mov    0x8(%ecx),%ecx
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
400303cb:	8b 09                	mov    (%ecx),%ecx
static inline __attribute__((always_inline))
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
400303cd:	8a 49 14             	mov    0x14(%ecx),%cl
400303d0:	80 e1 40             	and    $0x40,%cl
400303d3:	74 f1                	je     400303c6 <uart_ns16550_poll_out+0x3>
		;

	OUTBYTE(THR(dev), c);
400303d5:	8b 00                	mov    (%eax),%eax
400303d7:	8b 40 08             	mov    0x8(%eax),%eax
static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
			 :
			 : "q"(data), "m" (*(volatile uint8_t *) addr)
400303da:	8b 00                	mov    (%eax),%eax
}

static inline __attribute__((always_inline))
	void sys_write8(uint8_t data, mm_reg_t addr)
{
	__asm__ volatile("movb	%0, %1;\n\t"
400303dc:	88 10                	mov    %dl,(%eax)

	return c;
}
400303de:	88 d0                	mov    %dl,%al
400303e0:	5d                   	pop    %ebp
400303e1:	c3                   	ret    

400303e2 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
400303e2:	55                   	push   %ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
400303e3:	8b 00                	mov    (%eax),%eax
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
400303e5:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
400303e7:	8b 40 08             	mov    0x8(%eax),%eax
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
			 : "=q"(ret)
			 : "m" (*(volatile uint8_t *) addr)
400303ea:	8b 00                	mov    (%eax),%eax
static inline __attribute__((always_inline))
	uint8_t sys_read8(mm_reg_t addr)
{
	uint8_t ret;

	__asm__ volatile("movb	%1, %0;\n\t"
400303ec:	8a 40 14             	mov    0x14(%eax),%al
400303ef:	83 e0 1e             	and    $0x1e,%eax
}
400303f2:	5d                   	pop    %ebp
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
400303f3:	d1 f8                	sar    %eax
}
400303f5:	c3                   	ret    

400303f6 <_timer_int_handler>:
	if (_sys_idle_elapsed_ticks == 1) {
		_sys_clock_tick_announce();
	}
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
400303f6:	a1 60 6c 00 a8       	mov    0xa8006c60,%eax
 *
 * @return N/A
 */
void _timer_int_handler(void *unused /* parameter is not used */
				 )
{
400303fb:	55                   	push   %ebp
	if (_sys_idle_elapsed_ticks == 1) {
		_sys_clock_tick_announce();
	}
#else
	/* track the accumulated cycle count */
	accumulated_cycle_count += cycles_per_tick;
400303fc:	01 05 24 65 00 a8    	add    %eax,0xa8006524
#endif

#endif /*TIMER_SUPPORTS_TICKLESS*/

#if defined(CONFIG_NANOKERNEL)
	_sys_clock_tick_announce();
40030402:	a1 44 64 00 a8       	mov    0xa8006444,%eax
 *
 * @return N/A
 */
void _timer_int_handler(void *unused /* parameter is not used */
				 )
{
40030407:	89 e5                	mov    %esp,%ebp
	 */

	initial_count_register_set(cycles_per_tick - 1);
	periodic_mode_set();
#endif /* LOAPIC_TIMER_PERIODIC_WORKAROUND */
}
40030409:	5d                   	pop    %ebp
#endif

#endif /*TIMER_SUPPORTS_TICKLESS*/

#if defined(CONFIG_NANOKERNEL)
	_sys_clock_tick_announce();
4003040a:	e9 6e 16 00 00       	jmp    40031a7d <_nano_sys_clock_tick_announce>

4003040f <_sys_clock_driver_init>:
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
4003040f:	a1 48 64 00 a8       	mov    0xa8006448,%eax
 * rate specified via the 'sys_clock_us_per_tick' global variable.
 *
 * @return 0
 */
int _sys_clock_driver_init(struct device *device)
{
40030414:	55                   	push   %ebp
	ARG_UNUSED(device);

	/* determine the timer counter value (in timer clock cycles/system tick)
	 */

	cycles_per_tick = sys_clock_hw_cycles_per_tick;
40030415:	a3 60 6c 00 a8       	mov    %eax,0xa8006c60
 * rate specified via the 'sys_clock_us_per_tick' global variable.
 *
 * @return 0
 */
int _sys_clock_driver_init(struct device *device)
{
4003041a:	89 e5                	mov    %esp,%ebp
{
}
#else
static inline void divide_configuration_register_set(void)
{
	*_REG_TIMER_CFG = (*_REG_TIMER_CFG & ~0xf) | LOAPIC_TIMER_DIVBY_1;
4003041c:	a1 e0 03 e0 fe       	mov    0xfee003e0,%eax
40030421:	83 e0 f0             	and    $0xfffffff0,%eax
40030424:	83 c8 0b             	or     $0xb,%eax
40030427:	a3 e0 03 e0 fe       	mov    %eax,0xfee003e0
	cycles_per_tick = sys_clock_hw_cycles_per_tick;

	tickless_idle_init();

	divide_configuration_register_set();
	initial_count_register_set(cycles_per_tick - 1);
4003042c:	a1 60 6c 00 a8       	mov    0xa8006c60,%eax
40030431:	48                   	dec    %eax
 */
static inline void initial_count_register_set(
	uint32_t count /* count from which timer is to count down */
	)
{
	*_REG_TIMER_ICR = count;
40030432:	a3 80 03 e0 fe       	mov    %eax,0xfee00380
 *
 * @return N/A
 */
static inline void periodic_mode_set(void)
{
	*_REG_TIMER |= LOAPIC_TIMER_PERIODIC;
40030437:	a1 20 03 e0 fe       	mov    0xfee00320,%eax
4003043c:	0d 00 00 02 00       	or     $0x20000,%eax
40030441:	a3 20 03 e0 fe       	mov    %eax,0xfee00320

	divide_configuration_register_set();
	initial_count_register_set(cycles_per_tick - 1);
	periodic_mode_set();

	IRQ_CONNECT(CONFIG_LOAPIC_TIMER_IRQ, CONFIG_LOAPIC_TIMER_IRQ_PRIORITY,
40030446:	eb 16                	jmp    4003045e <_sys_clock_driver_init+0x4f>
40030448:	50                   	push   %eax
40030449:	52                   	push   %edx
4003044a:	51                   	push   %ecx
4003044b:	b8 f6 03 03 40       	mov    $0x400303f6,%eax
40030450:	ba 00 00 00 00       	mov    $0x0,%edx
40030455:	e8 e0 1d 00 00       	call   4003223a <_execute_handler>
4003045a:	59                   	pop    %ecx
4003045b:	5a                   	pop    %edx
4003045c:	58                   	pop    %eax
4003045d:	cf                   	iret   
4003045e:	0f b6 05 00 33 03 40 	movzbl 0x40033300,%eax
40030465:	31 c9                	xor    %ecx,%ecx
40030467:	ba 40 00 00 00       	mov    $0x40,%edx
4003046c:	e8 0e 00 00 00       	call   4003047f <_SysIntVecProgram>
		    _timer_int_handler, 0, 0);

	/* Everything has been configured. It is now safe to enable the
	 * interrupt
	 */
	irq_enable(CONFIG_LOAPIC_TIMER_IRQ);
40030471:	b8 40 00 00 00       	mov    $0x40,%eax
40030476:	e8 26 00 00 00       	call   400304a1 <irq_enable>

	return 0;
}
4003047b:	31 c0                	xor    %eax,%eax
4003047d:	5d                   	pop    %ebp
4003047e:	c3                   	ret    

4003047f <_SysIntVecProgram>:
 * @param irq the virtualized IRQ
 * @param flags interrupt flags
 *
 */
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
4003047f:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
40030480:	83 fa 3f             	cmp    $0x3f,%edx
 * @param irq the virtualized IRQ
 * @param flags interrupt flags
 *
 */
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
40030483:	89 e5                	mov    %esp,%ebp
40030485:	53                   	push   %ebx
40030486:	89 c3                	mov    %eax,%ebx
40030488:	89 d0                	mov    %edx,%eax
	if (IS_IOAPIC_IRQ(irq)) {
4003048a:	77 09                	ja     40030495 <_SysIntVecProgram+0x16>
		_ioapic_irq_set(irq, vector, flags);
4003048c:	89 da                	mov    %ebx,%edx
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
4003048e:	5b                   	pop    %ebx
4003048f:	5d                   	pop    %ebp
 *
 */
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
40030490:	e9 dd 01 00 00       	jmp    40030672 <_ioapic_irq_set>
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
40030495:	89 da                	mov    %ebx,%edx
40030497:	83 e8 40             	sub    $0x40,%eax
	}
}
4003049a:	5b                   	pop    %ebx
4003049b:	5d                   	pop    %ebp
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
4003049c:	e9 de 00 00 00       	jmp    4003057f <_loapic_int_vec_set>

400304a1 <irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void irq_enable(unsigned int irq)
{
400304a1:	55                   	push   %ebp
	if (IS_IOAPIC_IRQ(irq)) {
400304a2:	83 f8 3f             	cmp    $0x3f,%eax
 * virtualization.
 *
 * @return N/A
 */
void irq_enable(unsigned int irq)
{
400304a5:	89 e5                	mov    %esp,%ebp
	if (IS_IOAPIC_IRQ(irq)) {
400304a7:	77 06                	ja     400304af <irq_enable+0xe>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
400304a9:	5d                   	pop    %ebp
 * @return N/A
 */
void irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
400304aa:	e9 b3 01 00 00       	jmp    40030662 <_ioapic_irq_enable>
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
400304af:	83 e8 40             	sub    $0x40,%eax
	}
}
400304b2:	5d                   	pop    %ebp
void irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
400304b3:	e9 e7 00 00 00       	jmp    4003059f <_loapic_irq_enable>

400304b8 <_loapic_enable>:
 *
 * @return N/A
 */

void _loapic_enable(void)
{
400304b8:	55                   	push   %ebp
400304b9:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400304bb:	9c                   	pushf  
400304bc:	fa                   	cli    
400304bd:	5a                   	pop    %edx
	int32_t oldLevel = irq_lock(); /* LOCK INTERRUPTS */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR) |= LOAPIC_ENABLE;
400304be:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
400304c3:	80 cc 01             	or     $0x1,%ah
400304c6:	80 e6 02             	and    $0x2,%dh
400304c9:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
400304ce:	74 01                	je     400304d1 <_loapic_enable+0x19>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
400304d0:	fb                   	sti    

	irq_unlock(oldLevel); /* UNLOCK INTERRUPTS */
}
400304d1:	5d                   	pop    %ebp
400304d2:	c3                   	ret    

400304d3 <_loapic_init>:
 * @return N/A
 *
 */

int _loapic_init(struct device *unused)
{
400304d3:	55                   	push   %ebp
400304d4:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */

	_loapic_enable();
400304d6:	e8 dd ff ff ff       	call   400304b8 <_loapic_enable>

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
400304db:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
400304e0:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
400304e7:	ff ff ff 
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
400304ea:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
400304f1:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
400304f4:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
400304fb:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
400304fe:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
40030505:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
40030508:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx

	/* enable the Local APIC */

	_loapic_enable();

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
4003050e:	25 00 00 ff 00       	and    $0xff0000,%eax
40030513:	c1 f8 10             	sar    $0x10,%eax

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
40030516:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
4003051c:	80 ce 07             	or     $0x7,%dh

	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
4003051f:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
40030525:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
4003052b:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
40030531:	80 ce 04             	or     $0x4,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40030534:	83 f8 03             	cmp    $0x3,%eax
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
40030537:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_NMI | LOAPIC_HIGH | LOAPIC_EDGE);

	/* lock the Local APIC interrupts */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
4003053d:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
40030544:	00 01 00 
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
40030547:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
4003054e:	00 01 00 
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
40030551:	7e 19                	jle    4003056c <_loapic_init+0x99>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
40030553:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
4003055a:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
4003055d:	83 f8 04             	cmp    $0x4,%eax
40030560:	74 0a                	je     4003056c <_loapic_init+0x99>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
40030562:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
40030569:	00 01 00 
 * @return N/A
 */
static inline void _loapic_eoi(void)
{
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
4003056c:	e8 4d 21 00 00       	call   400326be <_lakemont_eoi>
#endif
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
40030571:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
40030578:	00 00 00 
#endif

	/* discard a pending interrupt if any */
	_loapic_eoi();
	return 0;
}
4003057b:	31 c0                	xor    %eax,%eax
4003057d:	5d                   	pop    %ebp
4003057e:	c3                   	ret    

4003057f <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
4003057f:	55                   	push   %ebp
	 *   IRQ5 -> LOAPIC_ERROR
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
40030580:	05 32 00 ee 0f       	add    $0xfee0032,%eax
40030585:	c1 e0 04             	shl    $0x4,%eax
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
40030588:	89 e5                	mov    %esp,%ebp
4003058a:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
4003058b:	9c                   	pushf  
4003058c:	fa                   	cli    
4003058d:	5b                   	pop    %ebx
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
4003058e:	8b 08                	mov    (%eax),%ecx
40030590:	30 c9                	xor    %cl,%cl
40030592:	09 ca                	or     %ecx,%edx
40030594:	80 e7 02             	and    $0x2,%bh
40030597:	89 10                	mov    %edx,(%eax)
40030599:	74 01                	je     4003059c <_loapic_int_vec_set+0x1d>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
4003059b:	fb                   	sti    
	irq_unlock(oldLevel);
}
4003059c:	5b                   	pop    %ebx
4003059d:	5d                   	pop    %ebp
4003059e:	c3                   	ret    

4003059f <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
4003059f:	55                   	push   %ebp
	/*
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
400305a0:	05 32 00 ee 0f       	add    $0xfee0032,%eax
400305a5:	c1 e0 04             	shl    $0x4,%eax
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
400305a8:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400305aa:	9c                   	pushf  
400305ab:	fa                   	cli    
400305ac:	59                   	pop    %ecx
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
400305ad:	8b 10                	mov    (%eax),%edx
400305af:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
400305b5:	80 e5 02             	and    $0x2,%ch
400305b8:	89 10                	mov    %edx,(%eax)
400305ba:	74 01                	je     400305bd <_loapic_irq_enable+0x1e>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
400305bc:	fb                   	sti    
	irq_unlock(oldLevel);
}
400305bd:	5d                   	pop    %ebp
400305be:	c3                   	ret    

400305bf <_loapic_isr_vector_get>:
 * --------------------
 *
 * @return The vector of the interrupt that is currently being processed.
 */
int _loapic_isr_vector_get(void)
{
400305bf:	55                   	push   %ebp
400305c0:	ba 00 01 e0 fe       	mov    $0xfee00100,%edx
400305c5:	89 e5                	mov    %esp,%ebp
	/* pointer to ISR vector table */
	volatile int *pReg;
	int block = 0;
400305c7:	31 c9                	xor    %ecx,%ecx

	while (block < 8) {
		pReg = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR + (block * 0x10));
		if (*pReg) {
400305c9:	8b 02                	mov    (%edx),%eax
400305cb:	85 c0                	test   %eax,%eax
400305cd:	74 14                	je     400305e3 <_loapic_isr_vector_get+0x24>
			return (block * 32) + (find_lsb_set(*pReg) - 1);
400305cf:	8b 12                	mov    (%edx),%edx

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	int bitpos;

	__asm__ volatile (
400305d1:	0f bc d2             	bsf    %edx,%edx
400305d4:	75 05                	jne    400305db <_loapic_isr_vector_get+0x1c>
400305d6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
400305db:	c1 e1 05             	shl    $0x5,%ecx
400305de:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
400305e1:	eb 09                	jmp    400305ec <_loapic_isr_vector_get+0x2d>
		}
		block++;
400305e3:	41                   	inc    %ecx
400305e4:	83 c2 10             	add    $0x10,%edx
{
	/* pointer to ISR vector table */
	volatile int *pReg;
	int block = 0;

	while (block < 8) {
400305e7:	83 f9 08             	cmp    $0x8,%ecx
400305ea:	75 dd                	jne    400305c9 <_loapic_isr_vector_get+0xa>
		}
		block++;
	}

	return 0;
}
400305ec:	5d                   	pop    %ebp
400305ed:	c3                   	ret    

400305ee <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
400305ee:	55                   	push   %ebp
400305ef:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400305f1:	9c                   	pushf  
400305f2:	fa                   	cli    
400305f3:	59                   	pop    %ecx
400305f4:	80 e5 02             	and    $0x2,%ch

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
400305f7:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
400305fc:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
40030602:	74 01                	je     40030605 <__IoApicSet+0x17>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40030604:	fb                   	sti    

	irq_unlock(key);
}
40030605:	5d                   	pop    %ebp
40030606:	c3                   	ret    

40030607 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
40030607:	55                   	push   %ebp
 * @param irq INTIN number
 * @return 32 low-order bits
 */
static uint32_t ioApicRedGetLo(unsigned int irq)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
40030608:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
4003060c:	89 e5                	mov    %esp,%ebp
4003060e:	56                   	push   %esi
4003060f:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40030610:	9c                   	pushf  
40030611:	fa                   	cli    
40030612:	5e                   	pop    %esi
	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*((volatile char *)
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
40030613:	a2 00 00 c0 fe       	mov    %al,0xfec00000
40030618:	81 e6 00 02 00 00    	and    $0x200,%esi
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
4003061e:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
40030624:	74 01                	je     40030627 <_IoApicRedUpdateLo+0x20>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40030626:	fb                   	sti    
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
40030627:	31 da                	xor    %ebx,%edx
40030629:	21 ca                	and    %ecx,%edx
4003062b:	31 da                	xor    %ebx,%edx
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
}
4003062d:	5b                   	pop    %ebx
4003062e:	5e                   	pop    %esi
4003062f:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
40030630:	e9 b9 ff ff ff       	jmp    400305ee <__IoApicSet>

40030635 <_ioapic_init>:
 * This routine initializes the IO APIC or xAPIC.
 *
 * @return N/A
 */
int _ioapic_init(struct device *unused)
{
40030635:	55                   	push   %ebp
40030636:	89 e5                	mov    %esp,%ebp
40030638:	56                   	push   %esi
40030639:	53                   	push   %ebx
	 */

	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
4003063a:	31 db                	xor    %ebx,%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
4003063c:	8d 34 1b             	lea    (%ebx,%ebx,1),%esi

	__IoApicSet(offset, upper32);
4003063f:	31 d2                	xor    %edx,%edx
	 */

	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
40030641:	43                   	inc    %ebx
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
40030642:	8d 46 11             	lea    0x11(%esi),%eax
40030645:	e8 a4 ff ff ff       	call   400305ee <__IoApicSet>
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
4003064a:	8d 46 10             	lea    0x10(%esi),%eax
4003064d:	ba 00 00 01 00       	mov    $0x10000,%edx
40030652:	e8 97 ff ff ff       	call   400305ee <__IoApicSet>
	 */

	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
40030657:	83 fb 40             	cmp    $0x40,%ebx
4003065a:	75 e0                	jne    4003063c <_ioapic_init+0x7>
		ioApicRedSetHi(ix, 0);
		ioApicRedSetLo(ix, rteValue);
	}
	return 0;
}
4003065c:	5b                   	pop    %ebx
4003065d:	31 c0                	xor    %eax,%eax
4003065f:	5e                   	pop    %esi
40030660:	5d                   	pop    %ebp
40030661:	c3                   	ret    

40030662 <_ioapic_irq_enable>:
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
40030662:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
40030663:	b9 00 00 01 00       	mov    $0x10000,%ecx
40030668:	31 d2                	xor    %edx,%edx
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
4003066a:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
}
4003066c:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
4003066d:	e9 95 ff ff ff       	jmp    40030607 <_IoApicRedUpdateLo>

40030672 <_ioapic_irq_set>:
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
40030672:	55                   	push   %ebp
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030673:	81 c9 00 00 01 00    	or     $0x10000,%ecx
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
40030679:	89 e5                	mov    %esp,%ebp
4003067b:	56                   	push   %esi
4003067c:	53                   	push   %ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
4003067d:	8d 1c 00             	lea    (%eax,%eax,1),%ebx
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030680:	0f b6 f2             	movzbl %dl,%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
40030683:	8d 43 11             	lea    0x11(%ebx),%eax
40030686:	31 d2                	xor    %edx,%edx
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
40030688:	09 ce                	or     %ecx,%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
4003068a:	e8 5f ff ff ff       	call   400305ee <__IoApicSet>
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
4003068f:	8d 43 10             	lea    0x10(%ebx),%eax
40030692:	89 f2                	mov    %esi,%edx

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
		   (vector & IOAPIC_VEC_MASK) | flags;
	ioApicRedSetHi(irq, 0);
	ioApicRedSetLo(irq, rteValue);
}
40030694:	5b                   	pop    %ebx
40030695:	5e                   	pop    %esi
40030696:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
40030697:	e9 52 ff ff ff       	jmp    400305ee <__IoApicSet>

4003069c <quark_se_ipm_send>:
}


static int quark_se_ipm_send(struct device *d, int wait, uint32_t id,
			const void *data, int size)
{
4003069c:	55                   	push   %ebp
	volatile struct quark_se_ipm *ipm = config->ipm;
	const uint8_t *data8;
	int i;
	int flags;

	if (id > QUARK_SE_IPM_MAX_ID_VAL) {
4003069d:	85 c9                	test   %ecx,%ecx
}


static int quark_se_ipm_send(struct device *d, int wait, uint32_t id,
			const void *data, int size)
{
4003069f:	89 e5                	mov    %esp,%ebp
400306a1:	57                   	push   %edi
400306a2:	56                   	push   %esi
400306a3:	53                   	push   %ebx
400306a4:	53                   	push   %ebx
400306a5:	89 55 f0             	mov    %edx,-0x10(%ebp)
	struct quark_se_ipm_config_info *config = d->config->config_info;
400306a8:	8b 00                	mov    (%eax),%eax
400306aa:	8b 40 08             	mov    0x8(%eax),%eax
	volatile struct quark_se_ipm *ipm = config->ipm;
400306ad:	8b 58 08             	mov    0x8(%eax),%ebx
	const uint8_t *data8;
	int i;
	int flags;

	if (id > QUARK_SE_IPM_MAX_ID_VAL) {
400306b0:	0f 88 b1 00 00 00    	js     40030767 <quark_se_ipm_send+0xcb>
		return -EINVAL;
	}

	if (config->direction != QUARK_SE_IPM_OUTBOUND) {
400306b6:	8b 40 04             	mov    0x4(%eax),%eax
400306b9:	85 c0                	test   %eax,%eax
400306bb:	0f 85 a6 00 00 00    	jne    40030767 <quark_se_ipm_send+0xcb>
		return -EINVAL;
	}

	if (size > QUARK_SE_IPM_DATA_BYTES) {
400306c1:	83 7d 0c 10          	cmpl   $0x10,0xc(%ebp)
400306c5:	0f 87 a3 00 00 00    	ja     4003076e <quark_se_ipm_send+0xd2>

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400306cb:	9c                   	pushf  
400306cc:	fa                   	cli    
400306cd:	5f                   	pop    %edi
		return -EMSGSIZE;
	}

	flags = irq_lock();

	if (ipm->sts.sts != 0) {
400306ce:	0f b6 73 14          	movzbl 0x14(%ebx),%esi
400306d2:	83 e6 01             	and    $0x1,%esi
400306d5:	75 04                	jne    400306db <quark_se_ipm_send+0x3f>
400306d7:	31 f6                	xor    %esi,%esi
400306d9:	eb 17                	jmp    400306f2 <quark_se_ipm_send+0x56>
		irq_unlock(flags);
		return -EBUSY;
400306db:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
400306e0:	81 e7 00 02 00 00    	and    $0x200,%edi
400306e6:	0f 84 87 00 00 00    	je     40030773 <quark_se_ipm_send+0xd7>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
400306ec:	fb                   	sti    
400306ed:	e9 81 00 00 00       	jmp    40030773 <quark_se_ipm_send+0xd7>
	}

	/* Populate the data, memcpy doesn't take volatiles */
	data8 = (const uint8_t *)data;

	for (i = 0; i < size; ++i) {
400306f2:	3b 75 0c             	cmp    0xc(%ebp),%esi
400306f5:	74 0d                	je     40030704 <quark_se_ipm_send+0x68>
		ipm->data[i] = data8[i];
400306f7:	8b 55 08             	mov    0x8(%ebp),%edx
400306fa:	8a 14 32             	mov    (%edx,%esi,1),%dl
400306fd:	88 54 33 04          	mov    %dl,0x4(%ebx,%esi,1)
	}

	/* Populate the data, memcpy doesn't take volatiles */
	data8 = (const uint8_t *)data;

	for (i = 0; i < size; ++i) {
40030701:	46                   	inc    %esi
40030702:	eb ee                	jmp    400306f2 <quark_se_ipm_send+0x56>
		ipm->data[i] = data8[i];
	}
	ipm->ctrl.ctrl = id;
40030704:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
4003070a:	8a 13                	mov    (%ebx),%dl
4003070c:	0f b6 f1             	movzbl %cl,%esi
4003070f:	89 f2                	mov    %esi,%edx
40030711:	88 13                	mov    %dl,(%ebx)
40030713:	0f b6 f5             	movzbl %ch,%esi
40030716:	8a 53 01             	mov    0x1(%ebx),%dl
40030719:	89 f2                	mov    %esi,%edx
4003071b:	89 ce                	mov    %ecx,%esi
4003071d:	88 53 01             	mov    %dl,0x1(%ebx)
40030720:	c1 ee 10             	shr    $0x10,%esi
40030723:	c1 e9 18             	shr    $0x18,%ecx
40030726:	89 f2                	mov    %esi,%edx
40030728:	0f b6 f2             	movzbl %dl,%esi
4003072b:	8a 53 02             	mov    0x2(%ebx),%dl
4003072e:	89 f2                	mov    %esi,%edx
40030730:	88 53 02             	mov    %dl,0x2(%ebx)
40030733:	0f b6 73 03          	movzbl 0x3(%ebx),%esi
40030737:	83 e6 80             	and    $0xffffff80,%esi
4003073a:	09 f1                	or     %esi,%ecx
4003073c:	88 4b 03             	mov    %cl,0x3(%ebx)

	/* Cause the interrupt to assert on the remote side */
	ipm->ctrl.irq = 1;
4003073f:	8a 4b 03             	mov    0x3(%ebx),%cl
40030742:	83 c9 80             	or     $0xffffff80,%ecx
40030745:	88 4b 03             	mov    %cl,0x3(%ebx)

	/* Wait for HW to set the sts bit */
	while (ipm->sts.sts == 0) {
40030748:	8a 4b 14             	mov    0x14(%ebx),%cl
4003074b:	80 e1 01             	and    $0x1,%cl
4003074e:	74 f8                	je     40030748 <quark_se_ipm_send+0xac>
40030750:	81 e7 00 02 00 00    	and    $0x200,%edi
40030756:	74 01                	je     40030759 <quark_se_ipm_send+0xbd>
40030758:	fb                   	sti    
	}
	irq_unlock(flags);

	if (wait) {
40030759:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
4003075d:	74 14                	je     40030773 <quark_se_ipm_send+0xd7>
		/* Loop until remote clears the status bit */
		while (ipm->sts.sts != 0) {
4003075f:	8a 53 14             	mov    0x14(%ebx),%dl
40030762:	80 e2 01             	and    $0x1,%dl
40030765:	eb f6                	jmp    4003075d <quark_se_ipm_send+0xc1>
	const uint8_t *data8;
	int i;
	int flags;

	if (id > QUARK_SE_IPM_MAX_ID_VAL) {
		return -EINVAL;
40030767:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
4003076c:	eb 05                	jmp    40030773 <quark_se_ipm_send+0xd7>
	if (config->direction != QUARK_SE_IPM_OUTBOUND) {
		return -EINVAL;
	}

	if (size > QUARK_SE_IPM_DATA_BYTES) {
		return -EMSGSIZE;
4003076e:	b8 dc ff ff ff       	mov    $0xffffffdc,%eax
		/* Loop until remote clears the status bit */
		while (ipm->sts.sts != 0) {
		}
	}
	return 0;
}
40030773:	5a                   	pop    %edx
40030774:	5b                   	pop    %ebx
40030775:	5e                   	pop    %esi
40030776:	5f                   	pop    %edi
40030777:	5d                   	pop    %ebp
40030778:	c3                   	ret    

40030779 <quark_se_ipm_max_data_size_get>:


static int quark_se_ipm_max_data_size_get(struct device *d)
{
40030779:	55                   	push   %ebp
	ARG_UNUSED(d);

	return QUARK_SE_IPM_DATA_BYTES;
}
4003077a:	b8 10 00 00 00       	mov    $0x10,%eax
	return 0;
}


static int quark_se_ipm_max_data_size_get(struct device *d)
{
4003077f:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(d);

	return QUARK_SE_IPM_DATA_BYTES;
}
40030781:	5d                   	pop    %ebp
40030782:	c3                   	ret    

40030783 <quark_se_ipm_max_id_val_get>:


static uint32_t quark_se_ipm_max_id_val_get(struct device *d)
{
40030783:	55                   	push   %ebp
	ARG_UNUSED(d);

	return QUARK_SE_IPM_MAX_ID_VAL;
}
40030784:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	return QUARK_SE_IPM_DATA_BYTES;
}


static uint32_t quark_se_ipm_max_id_val_get(struct device *d)
{
40030789:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(d);

	return QUARK_SE_IPM_MAX_ID_VAL;
}
4003078b:	5d                   	pop    %ebp
4003078c:	c3                   	ret    

4003078d <quark_se_ipm_register_callback>:

static void quark_se_ipm_register_callback(struct device *d, ipm_callback_t cb,
				       void *context)
{
4003078d:	55                   	push   %ebp
	struct quark_se_ipm_driver_data *driver_data = d->driver_data;
4003078e:	8b 40 08             	mov    0x8(%eax),%eax
	return QUARK_SE_IPM_MAX_ID_VAL;
}

static void quark_se_ipm_register_callback(struct device *d, ipm_callback_t cb,
				       void *context)
{
40030791:	89 e5                	mov    %esp,%ebp
	struct quark_se_ipm_driver_data *driver_data = d->driver_data;

	driver_data->callback = cb;
40030793:	89 10                	mov    %edx,(%eax)
	driver_data->callback_ctx = context;
40030795:	89 48 04             	mov    %ecx,0x4(%eax)
}
40030798:	5d                   	pop    %ebp
40030799:	c3                   	ret    

4003079a <quark_se_ipm_set_enabled>:


static int quark_se_ipm_set_enabled(struct device *d, int enable)
{
4003079a:	55                   	push   %ebp
	struct quark_se_ipm_config_info *config_info = d->config->config_info;
4003079b:	8b 00                	mov    (%eax),%eax
	driver_data->callback_ctx = context;
}


static int quark_se_ipm_set_enabled(struct device *d, int enable)
{
4003079d:	89 e5                	mov    %esp,%ebp
	struct quark_se_ipm_config_info *config_info = d->config->config_info;
4003079f:	8b 40 08             	mov    0x8(%eax),%eax

	if (config_info->direction != QUARK_SE_IPM_INBOUND) {
400307a2:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
400307a6:	75 1a                	jne    400307c2 <quark_se_ipm_set_enabled+0x28>
		return -EINVAL;
	}
	set_channel_irq_state(config_info->channel, enable);
400307a8:	8b 00                	mov    (%eax),%eax
static void set_channel_irq_state(int channel, int enable)
{
	mem_addr_t addr = QUARK_SE_IPM_MASK;
	int bit = channel + QUARK_SE_IPM_MASK_START_BIT;

	if (enable) {
400307aa:	85 d2                	test   %edx,%edx
400307ac:	74 09                	je     400307b7 <quark_se_ipm_set_enabled+0x1d>
}

static inline __attribute__((always_inline))
	void sys_clear_bit(mem_addr_t addr, int bit)
{
	__asm__ volatile("btrl	%1, %0;\n\t"
400307ae:	0f b3 05 a0 04 80 b0 	btr    %eax,0xb08004a0
400307b5:	eb 07                	jmp    400307be <quark_se_ipm_set_enabled+0x24>


static inline __attribute__((always_inline))
	void sys_set_bit(mem_addr_t addr, int bit)
{
	__asm__ volatile("btsl	%1, %0;\n\t"
400307b7:	0f ab 05 a0 04 80 b0 	bts    %eax,0xb08004a0

	if (config_info->direction != QUARK_SE_IPM_INBOUND) {
		return -EINVAL;
	}
	set_channel_irq_state(config_info->channel, enable);
	return 0;
400307be:	31 c0                	xor    %eax,%eax
400307c0:	eb 05                	jmp    400307c7 <quark_se_ipm_set_enabled+0x2d>
static int quark_se_ipm_set_enabled(struct device *d, int enable)
{
	struct quark_se_ipm_config_info *config_info = d->config->config_info;

	if (config_info->direction != QUARK_SE_IPM_INBOUND) {
		return -EINVAL;
400307c2:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	}
	set_channel_irq_state(config_info->channel, enable);
	return 0;
}
400307c7:	5d                   	pop    %ebp
400307c8:	c3                   	ret    

400307c9 <quark_se_ipm_isr>:
}


/* Interrupt handler, gets messages on all incoming enabled mailboxes */
void quark_se_ipm_isr(void *param)
{
400307c9:	55                   	push   %ebp
400307ca:	89 e5                	mov    %esp,%ebp
400307cc:	57                   	push   %edi
400307cd:	56                   	push   %esi
400307ce:	53                   	push   %ebx
static inline __attribute__((always_inline))
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
400307cf:	a1 c0 0a 80 b0       	mov    0xb0800ac0,%eax

static ALWAYS_INLINE unsigned int find_msb_set(uint32_t op)
{
	int bitpos;

	__asm__ volatile (
400307d4:	23 05 28 65 00 a8    	and    0xa8006528,%eax
400307da:	0f bd c0             	bsr    %eax,%eax
400307dd:	75 05                	jne    400307e4 <quark_se_ipm_isr+0x1b>
400307df:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	ARG_UNUSED(param);
	sts = quark_se_ipm_sts_get();

	__ASSERT(sts, "spurious IPM interrupt");
	bit = find_msb_set(sts) - 1;
	channel = bit / 2;
400307e4:	b9 02 00 00 00       	mov    $0x2,%ecx
400307e9:	99                   	cltd   
400307ea:	f7 f9                	idiv   %ecx
400307ec:	89 c6                	mov    %eax,%esi
	d = device_by_channel[channel];
400307ee:	8b 04 85 40 65 00 a8 	mov    -0x57ff9ac0(,%eax,4),%eax

	__ASSERT(d, "got IRQ on channel with no IPM device");
	config = d->config->config_info;
	driver_data = d->driver_data;
400307f5:	8b 78 08             	mov    0x8(%eax),%edi
	bit = find_msb_set(sts) - 1;
	channel = bit / 2;
	d = device_by_channel[channel];

	__ASSERT(d, "got IRQ on channel with no IPM device");
	config = d->config->config_info;
400307f8:	8b 00                	mov    (%eax),%eax
	driver_data = d->driver_data;
	ipm = config->ipm;
400307fa:	8b 40 08             	mov    0x8(%eax),%eax
400307fd:	8b 58 08             	mov    0x8(%eax),%ebx

	__ASSERT(driver_data->callback, "enabled IPM channel with no callback");
	driver_data->callback(driver_data->callback_ctx, ipm->ctrl.ctrl,
40030800:	0f b6 13             	movzbl (%ebx),%edx
40030803:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
40030807:	c1 e1 08             	shl    $0x8,%ecx
4003080a:	89 c8                	mov    %ecx,%eax
			      &ipm->data);
4003080c:	8d 4b 04             	lea    0x4(%ebx),%ecx
	config = d->config->config_info;
	driver_data = d->driver_data;
	ipm = config->ipm;

	__ASSERT(driver_data->callback, "enabled IPM channel with no callback");
	driver_data->callback(driver_data->callback_ctx, ipm->ctrl.ctrl,
4003080f:	09 d0                	or     %edx,%eax
40030811:	0f b6 53 02          	movzbl 0x2(%ebx),%edx
40030815:	c1 e2 10             	shl    $0x10,%edx
40030818:	09 c2                	or     %eax,%edx
4003081a:	8a 43 03             	mov    0x3(%ebx),%al
4003081d:	83 e0 7f             	and    $0x7f,%eax
40030820:	c1 e0 18             	shl    $0x18,%eax
40030823:	09 c2                	or     %eax,%edx
40030825:	8b 47 04             	mov    0x4(%edi),%eax
40030828:	ff 17                	call   *(%edi)

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
4003082a:	9c                   	pushf  
4003082b:	fa                   	cli    
4003082c:	5a                   	pop    %edx
			      &ipm->data);

	key = irq_lock();

	ipm->sts.irq = 1; /* Clear the interrupt bit */
4003082d:	8a 43 14             	mov    0x14(%ebx),%al
	ipm->sts.sts = 1; /* Clear channel status bit */

	/* Wait for the above register writes to clear the channel
	 * to propagate to the global channel status register
	 */
	while (quark_se_ipm_sts_get() & (0x3 << (channel * 2))) {
40030830:	8d 0c 36             	lea    (%esi,%esi,1),%ecx
	driver_data->callback(driver_data->callback_ctx, ipm->ctrl.ctrl,
			      &ipm->data);

	key = irq_lock();

	ipm->sts.irq = 1; /* Clear the interrupt bit */
40030833:	83 c8 02             	or     $0x2,%eax
40030836:	88 43 14             	mov    %al,0x14(%ebx)
	ipm->sts.sts = 1; /* Clear channel status bit */
40030839:	8a 43 14             	mov    0x14(%ebx),%al
4003083c:	83 c8 01             	or     $0x1,%eax
4003083f:	88 43 14             	mov    %al,0x14(%ebx)

	/* Wait for the above register writes to clear the channel
	 * to propagate to the global channel status register
	 */
	while (quark_se_ipm_sts_get() & (0x3 << (channel * 2))) {
40030842:	b8 03 00 00 00       	mov    $0x3,%eax
40030847:	d3 e0                	shl    %cl,%eax
static inline __attribute__((always_inline))
	uint32_t sys_read32(mm_reg_t addr)
{
	uint32_t ret;

	__asm__ volatile("movl	%1, %0;\n\t"
40030849:	8b 0d c0 0a 80 b0    	mov    0xb0800ac0,%ecx
4003084f:	8b 1d 28 65 00 a8    	mov    0xa8006528,%ebx
40030855:	21 c3                	and    %eax,%ebx
40030857:	85 cb                	test   %ecx,%ebx
40030859:	75 ee                	jne    40030849 <quark_se_ipm_isr+0x80>
4003085b:	80 e6 02             	and    $0x2,%dh
4003085e:	74 01                	je     40030861 <quark_se_ipm_isr+0x98>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40030860:	fb                   	sti    
		/* Busy-wait */
	}
	irq_unlock(key);
}
40030861:	5b                   	pop    %ebx
40030862:	5e                   	pop    %esi
40030863:	5f                   	pop    %edi
40030864:	5d                   	pop    %ebp
40030865:	c3                   	ret    

40030866 <quark_se_ipm_controller_initialize>:
	.max_id_val_get = quark_se_ipm_max_id_val_get,
	.set_enabled = quark_se_ipm_set_enabled
};

int quark_se_ipm_controller_initialize(struct device *d)
{
40030866:	55                   	push   %ebp
	struct quark_se_ipm_controller_config_info *config = d->config->config_info;
40030867:	8b 00                	mov    (%eax),%eax
	.max_id_val_get = quark_se_ipm_max_id_val_get,
	.set_enabled = quark_se_ipm_set_enabled
};

int quark_se_ipm_controller_initialize(struct device *d)
{
40030869:	89 e5                	mov    %esp,%ebp
	struct quark_se_ipm_controller_config_info *config = d->config->config_info;
4003086b:	8b 48 08             	mov    0x8(%eax),%ecx
}

static inline __attribute__((always_inline))
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
4003086e:	83 c8 ff             	or     $0xffffffff,%eax
40030871:	a3 a0 04 80 b0       	mov    %eax,0xb08004a0
40030876:	b8 00 0a 80 b0       	mov    $0xb0800a00,%eax
	 */
	sys_write32(0xFFFFFFFF, QUARK_SE_IPM_MASK);
	for (i = 0; i < QUARK_SE_IPM_CHANNELS; ++i) {
		volatile struct quark_se_ipm *ipm = QUARK_SE_IPM(i);

		ipm->sts.sts = 0;
4003087b:	8b 50 14             	mov    0x14(%eax),%edx
4003087e:	83 c0 18             	add    $0x18,%eax
40030881:	83 e2 fe             	and    $0xfffffffe,%edx
40030884:	89 50 fc             	mov    %edx,-0x4(%eax)
		ipm->sts.irq = 0;
40030887:	8b 50 fc             	mov    -0x4(%eax),%edx
4003088a:	83 e2 fd             	and    $0xfffffffd,%edx
4003088d:	89 50 fc             	mov    %edx,-0x4(%eax)

	/* Mask all mailbox interrupts, we'll enable them
	 * individually later. Clear out any pending messages
	 */
	sys_write32(0xFFFFFFFF, QUARK_SE_IPM_MASK);
	for (i = 0; i < QUARK_SE_IPM_CHANNELS; ++i) {
40030890:	3d c0 0a 80 b0       	cmp    $0xb0800ac0,%eax
40030895:	75 e4                	jne    4003087b <quark_se_ipm_controller_initialize+0x15>
		ipm->sts.sts = 0;
		ipm->sts.irq = 0;
	}
#endif

	if (config->controller_init) {
40030897:	8b 01                	mov    (%ecx),%eax
40030899:	85 c0                	test   %eax,%eax
4003089b:	74 03                	je     400308a0 <quark_se_ipm_controller_initialize+0x3a>
		return config->controller_init();
	}
	return DEV_OK;
}
4003089d:	5d                   	pop    %ebp
		ipm->sts.irq = 0;
	}
#endif

	if (config->controller_init) {
		return config->controller_init();
4003089e:	ff e0                	jmp    *%eax
	}
	return DEV_OK;
}
400308a0:	31 c0                	xor    %eax,%eax
400308a2:	5d                   	pop    %ebp
400308a3:	c3                   	ret    

400308a4 <quark_se_ipm_initialize>:


int quark_se_ipm_initialize(struct device *d)
{
400308a4:	55                   	push   %ebp
	struct quark_se_ipm_config_info *config = d->config->config_info;
400308a5:	8b 10                	mov    (%eax),%edx
	return DEV_OK;
}


int quark_se_ipm_initialize(struct device *d)
{
400308a7:	89 e5                	mov    %esp,%ebp
	struct quark_se_ipm_config_info *config = d->config->config_info;
400308a9:	8b 52 08             	mov    0x8(%edx),%edx

	device_by_channel[config->channel] = d;
400308ac:	8b 0a                	mov    (%edx),%ecx
	d->driver_api = &api_funcs;
400308ae:	c7 40 04 2c 64 00 a8 	movl   $0xa800642c,0x4(%eax)
	if (config->direction == QUARK_SE_IPM_INBOUND) {
400308b5:	83 7a 04 01          	cmpl   $0x1,0x4(%edx)

int quark_se_ipm_initialize(struct device *d)
{
	struct quark_se_ipm_config_info *config = d->config->config_info;

	device_by_channel[config->channel] = d;
400308b9:	89 04 8d 40 65 00 a8 	mov    %eax,-0x57ff9ac0(,%ecx,4)
	d->driver_api = &api_funcs;
	if (config->direction == QUARK_SE_IPM_INBOUND) {
400308c0:	75 0f                	jne    400308d1 <quark_se_ipm_initialize+0x2d>
		inbound_channels |= (0x3 << (config->channel * 2));
400308c2:	01 c9                	add    %ecx,%ecx
400308c4:	b8 03 00 00 00       	mov    $0x3,%eax
400308c9:	d3 e0                	shl    %cl,%eax
400308cb:	09 05 28 65 00 a8    	or     %eax,0xa8006528
	}

	return DEV_OK;
}
400308d1:	31 c0                	xor    %eax,%eax
400308d3:	5d                   	pop    %ebp
400308d4:	c3                   	ret    

400308d5 <main>:
 * Nanokernel version of hello world demo
 */


void main(void)
{
400308d5:	55                   	push   %ebp
400308d6:	89 e5                	mov    %esp,%ebp
400308d8:	53                   	push   %ebx
400308d9:	83 ec 1c             	sub    $0x1c,%esp
	struct nano_timer timer;
	void *timer_data[1];
	
	nano_timer_init(&timer, timer_data);
400308dc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
400308df:	8d 55 e0             	lea    -0x20(%ebp),%edx
400308e2:	e8 1b 14 00 00       	call   40031d02 <nano_timer_init>

	int v1 = 0;
400308e7:	31 c0                	xor    %eax,%eax
	int v2 = 100;
	while(1) {
		PRINT("{\"ch-1\": %d, \"ch-2\": %d}\n", v1++, v2++);
400308e9:	8d 50 64             	lea    0x64(%eax),%edx
400308ec:	8d 58 01             	lea    0x1(%eax),%ebx
400308ef:	52                   	push   %edx
400308f0:	50                   	push   %eax
400308f1:	68 12 28 03 40       	push   $0x40032812
400308f6:	e8 53 16 00 00       	call   40031f4e <printk>
400308fb:	83 c4 0c             	add    $0xc,%esp
		nano_timer_start(&timer, SLEEPTICKS);
400308fe:	ba 14 00 00 00       	mov    $0x14,%edx
40030903:	8d 45 e4             	lea    -0x1c(%ebp),%eax
40030906:	e8 0f 14 00 00       	call   40031d1a <_timer_start>
 *
 * @warning If called from an ISR, then @a timeout_in_ticks must be TICKS_NONE.
 */
static inline void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
	return nano_lifo_get(&timer->lifo, timeout_in_ticks);
4003090b:	83 ca ff             	or     $0xffffffff,%edx
4003090e:	8d 45 ec             	lea    -0x14(%ebp),%eax
40030911:	e8 47 11 00 00       	call   40031a5d <nano_lifo_get>
	nano_timer_init(&timer, timer_data);

	int v1 = 0;
	int v2 = 100;
	while(1) {
		PRINT("{\"ch-1\": %d, \"ch-2\": %d}\n", v1++, v2++);
40030916:	89 d8                	mov    %ebx,%eax
40030918:	eb cf                	jmp    400308e9 <main+0x14>

4003091a <printf>:

	return r;
}

int printf(const char *_Restrict format, ...)
{
4003091a:	55                   	push   %ebp
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = _prf(fputc, DESC(stdout), format, vargs);
4003091b:	ba 02 00 00 00       	mov    $0x2,%edx

	return r;
}

int printf(const char *_Restrict format, ...)
{
40030920:	89 e5                	mov    %esp,%ebp
	va_list vargs;
	int     r;

	va_start(vargs, format);
40030922:	8d 45 0c             	lea    0xc(%ebp),%eax
	r = _prf(fputc, DESC(stdout), format, vargs);
40030925:	8b 4d 08             	mov    0x8(%ebp),%ecx
40030928:	50                   	push   %eax
40030929:	b8 e3 17 03 40       	mov    $0x400317e3,%eax
4003092e:	e8 de 02 00 00       	call   40030c11 <_prf>
40030933:	5a                   	pop    %edx
	va_end(vargs);

	return r;
}
40030934:	c9                   	leave  
40030935:	c3                   	ret    

40030936 <_to_hex>:
#ifndef DOUBLE
#define DOUBLE 1
#endif

static int _to_hex(char *buf, uint32_t value, int alt_form, int precision, int prefix)
{
40030936:	55                   	push   %ebp
40030937:	89 e5                	mov    %esp,%ebp
40030939:	57                   	push   %edi
4003093a:	56                   	push   %esi
4003093b:	53                   	push   %ebx
4003093c:	53                   	push   %ebx
4003093d:	89 55 f0             	mov    %edx,-0x10(%ebp)
40030940:	8b 7d 08             	mov    0x8(%ebp),%edi

#if (MAXFLD < (2 + 7))
  #error buffer size MAXFLD is too small
#endif

	if (precision < 0)
40030943:	85 ff                	test   %edi,%edi
40030945:	79 05                	jns    4003094c <_to_hex+0x16>
		precision = 1;
40030947:	bf 01 00 00 00       	mov    $0x1,%edi
	*buf = '\0';
	if (alt_form) {
4003094c:	85 c9                	test   %ecx,%ecx
4003094e:	75 07                	jne    40030957 <_to_hex+0x21>
  #error buffer size MAXFLD is too small
#endif

	if (precision < 0)
		precision = 1;
	*buf = '\0';
40030950:	c6 00 00             	movb   $0x0,(%eax)
40030953:	89 c3                	mov    %eax,%ebx
40030955:	eb 17                	jmp    4003096e <_to_hex+0x38>
	if (alt_form) {
		buf[0] = '0';
		buf[1] = (prefix == 'X') ? 'X' : 'x';
40030957:	83 7d 0c 58          	cmpl   $0x58,0xc(%ebp)
4003095b:	0f 95 c2             	setne  %dl
4003095e:	4a                   	dec    %edx

	if (precision < 0)
		precision = 1;
	*buf = '\0';
	if (alt_form) {
		buf[0] = '0';
4003095f:	c6 00 30             	movb   $0x30,(%eax)
		buf[1] = (prefix == 'X') ? 'X' : 'x';
40030962:	83 e2 e0             	and    $0xffffffe0,%edx
		buf += 2;
40030965:	8d 58 02             	lea    0x2(%eax),%ebx
	if (precision < 0)
		precision = 1;
	*buf = '\0';
	if (alt_form) {
		buf[0] = '0';
		buf[1] = (prefix == 'X') ? 'X' : 'x';
40030968:	83 c2 78             	add    $0x78,%edx
4003096b:	88 50 01             	mov    %dl,0x1(%eax)
  #error buffer size MAXFLD is too small
#endif

	if (precision < 0)
		precision = 1;
	*buf = '\0';
4003096e:	be 07 00 00 00       	mov    $0x7,%esi
		buf[0] = '0';
		buf[1] = (prefix == 'X') ? 'X' : 'x';
		buf += 2;
	}
	for (i = 7; i >= 0; i--) {
		temp = (value >> (i * 4)) & 0xF;
40030973:	8d 0c b5 00 00 00 00 	lea    0x0(,%esi,4),%ecx
4003097a:	8b 55 f0             	mov    -0x10(%ebp),%edx
4003097d:	d3 ea                	shr    %cl,%edx
4003097f:	83 e2 0f             	and    $0xf,%edx
		if ((precision > i) || (temp != 0)) {
40030982:	39 fe                	cmp    %edi,%esi
40030984:	7c 04                	jl     4003098a <_to_hex+0x54>
40030986:	85 d2                	test   %edx,%edx
40030988:	74 21                	je     400309ab <_to_hex+0x75>
			precision = i;
			if (temp < 10)
4003098a:	83 fa 09             	cmp    $0x9,%edx
4003098d:	8d 4b 01             	lea    0x1(%ebx),%ecx
40030990:	7f 05                	jg     40030997 <_to_hex+0x61>
				*buf++ = (char) (temp + '0');
40030992:	83 c2 30             	add    $0x30,%edx
40030995:	eb 0e                	jmp    400309a5 <_to_hex+0x6f>
			else {
				if (prefix == 'X')
40030997:	83 7d 0c 58          	cmpl   $0x58,0xc(%ebp)
4003099b:	75 05                	jne    400309a2 <_to_hex+0x6c>
					*buf++ = (char) (temp - 10 + 'A');
4003099d:	83 c2 37             	add    $0x37,%edx
400309a0:	eb 03                	jmp    400309a5 <_to_hex+0x6f>
				else
					*buf++ = (char) (temp - 10 + 'a');
400309a2:	83 c2 57             	add    $0x57,%edx
400309a5:	88 13                	mov    %dl,(%ebx)
400309a7:	89 f7                	mov    %esi,%edi
400309a9:	89 cb                	mov    %ecx,%ebx
	if (alt_form) {
		buf[0] = '0';
		buf[1] = (prefix == 'X') ? 'X' : 'x';
		buf += 2;
	}
	for (i = 7; i >= 0; i--) {
400309ab:	4e                   	dec    %esi
400309ac:	83 fe ff             	cmp    $0xffffffff,%esi
400309af:	75 c2                	jne    40030973 <_to_hex+0x3d>
				else
					*buf++ = (char) (temp - 10 + 'a');
			}
		}
	}
	*buf = 0;
400309b1:	c6 03 00             	movb   $0x0,(%ebx)

	return buf - start;
400309b4:	29 c3                	sub    %eax,%ebx
}
400309b6:	5a                   	pop    %edx
			}
		}
	}
	*buf = 0;

	return buf - start;
400309b7:	89 d8                	mov    %ebx,%eax
}
400309b9:	5b                   	pop    %ebx
400309ba:	5e                   	pop    %esi
400309bb:	5f                   	pop    %edi
400309bc:	5d                   	pop    %ebp
400309bd:	c3                   	ret    

400309be <_to_udec>:

	return buf - start;
}

static int _to_udec(char *buf, uint32_t value, int precision)
{
400309be:	55                   	push   %ebp
400309bf:	89 e5                	mov    %esp,%ebp
400309c1:	57                   	push   %edi
400309c2:	56                   	push   %esi
400309c3:	53                   	push   %ebx
400309c4:	83 ec 08             	sub    $0x8,%esp
400309c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
400309ca:	89 55 ec             	mov    %edx,-0x14(%ebp)
#if (MAXFLD < 9)
  #error buffer size MAXFLD is too small
#endif

	divisor = 1000000000;
	if (precision < 0)
400309cd:	85 c9                	test   %ecx,%ecx
400309cf:	79 05                	jns    400309d6 <_to_udec+0x18>
		precision = 1;
400309d1:	b9 01 00 00 00       	mov    $0x1,%ecx
400309d6:	8b 5d f0             	mov    -0x10(%ebp),%ebx
400309d9:	be 09 00 00 00       	mov    $0x9,%esi
400309de:	bf 00 ca 9a 3b       	mov    $0x3b9aca00,%edi
	for (i = 9; i >= 0; i--, divisor /= 10) {
		temp = value / divisor;
		value = value % divisor;
400309e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
400309e6:	31 d2                	xor    %edx,%edx
400309e8:	f7 f7                	div    %edi
400309ea:	89 55 ec             	mov    %edx,-0x14(%ebp)
		if ((precision > i) || (temp != 0)) {
400309ed:	39 f1                	cmp    %esi,%ecx
400309ef:	7f 04                	jg     400309f5 <_to_udec+0x37>
400309f1:	85 c0                	test   %eax,%eax
400309f3:	74 08                	je     400309fd <_to_udec+0x3f>
			precision = i;
			*buf++ = (char) (temp + '0');
400309f5:	83 c0 30             	add    $0x30,%eax
400309f8:	89 f1                	mov    %esi,%ecx
400309fa:	88 03                	mov    %al,(%ebx)
400309fc:	43                   	inc    %ebx
#endif

	divisor = 1000000000;
	if (precision < 0)
		precision = 1;
	for (i = 9; i >= 0; i--, divisor /= 10) {
400309fd:	89 f8                	mov    %edi,%eax
400309ff:	31 d2                	xor    %edx,%edx
40030a01:	bf 0a 00 00 00       	mov    $0xa,%edi
40030a06:	4e                   	dec    %esi
40030a07:	f7 f7                	div    %edi
40030a09:	89 c7                	mov    %eax,%edi
40030a0b:	83 fe ff             	cmp    $0xffffffff,%esi
40030a0e:	75 d3                	jne    400309e3 <_to_udec+0x25>
		if ((precision > i) || (temp != 0)) {
			precision = i;
			*buf++ = (char) (temp + '0');
		}
	}
	*buf = 0;
40030a10:	c6 03 00             	movb   $0x0,(%ebx)

	return buf - start;
40030a13:	89 d8                	mov    %ebx,%eax
40030a15:	2b 45 f0             	sub    -0x10(%ebp),%eax
}
40030a18:	5a                   	pop    %edx
40030a19:	59                   	pop    %ecx
40030a1a:	5b                   	pop    %ebx
40030a1b:	5e                   	pop    %esi
40030a1c:	5f                   	pop    %edi
40030a1d:	5d                   	pop    %ebp
40030a1e:	c3                   	ret    

40030a1f <_llshift>:

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
}

static void _llshift(uint32_t value[])
{
40030a1f:	55                   	push   %ebp
	if (value[0] & 0x80000000)
40030a20:	8b 08                	mov    (%eax),%ecx

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
}

static void _llshift(uint32_t value[])
{
40030a22:	89 e5                	mov    %esp,%ebp
	if (value[0] & 0x80000000)
40030a24:	85 c9                	test   %ecx,%ecx
40030a26:	8b 50 04             	mov    0x4(%eax),%edx
40030a29:	79 07                	jns    40030a32 <_llshift+0x13>
		value[1] = (value[1] << 1) | 1;
40030a2b:	01 d2                	add    %edx,%edx
40030a2d:	83 ca 01             	or     $0x1,%edx
40030a30:	eb 02                	jmp    40030a34 <_llshift+0x15>
	else
		value[1] <<= 1;
40030a32:	01 d2                	add    %edx,%edx
	value[0] <<= 1;
40030a34:	01 c9                	add    %ecx,%ecx
static void _llshift(uint32_t value[])
{
	if (value[0] & 0x80000000)
		value[1] = (value[1] << 1) | 1;
	else
		value[1] <<= 1;
40030a36:	89 50 04             	mov    %edx,0x4(%eax)
	value[0] <<= 1;
40030a39:	89 08                	mov    %ecx,(%eax)
}
40030a3b:	5d                   	pop    %ebp
40030a3c:	c3                   	ret    

40030a3d <_ladd>:
		value[0] = (value[0] >> 1) & 0x7FFFFFFF;
	value[1] = (value[1] >> 1) & 0x7FFFFFFF;
}

static void _ladd(uint32_t result[], uint32_t value[])
{
40030a3d:	55                   	push   %ebp
	uint32_t carry;
	uint32_t temp;

	carry = 0;
	temp = result[0] + value[0];
40030a3e:	8b 08                	mov    (%eax),%ecx
		value[0] = (value[0] >> 1) & 0x7FFFFFFF;
	value[1] = (value[1] >> 1) & 0x7FFFFFFF;
}

static void _ladd(uint32_t result[], uint32_t value[])
{
40030a40:	89 e5                	mov    %esp,%ebp
40030a42:	56                   	push   %esi
40030a43:	53                   	push   %ebx
	uint32_t carry;
	uint32_t temp;

	carry = 0;
	temp = result[0] + value[0];
	if (result[0] & 0x80000000) {
40030a44:	85 c9                	test   %ecx,%ecx
{
	uint32_t carry;
	uint32_t temp;

	carry = 0;
	temp = result[0] + value[0];
40030a46:	8b 32                	mov    (%edx),%esi
40030a48:	8d 1c 31             	lea    (%ecx,%esi,1),%ebx
	if (result[0] & 0x80000000) {
40030a4b:	79 0b                	jns    40030a58 <_ladd+0x1b>
		if ((value[0] & 0x80000000) || ((temp & 0x80000000) == 0))
			carry = 1;
40030a4d:	b9 01 00 00 00       	mov    $0x1,%ecx
	uint32_t temp;

	carry = 0;
	temp = result[0] + value[0];
	if (result[0] & 0x80000000) {
		if ((value[0] & 0x80000000) || ((temp & 0x80000000) == 0))
40030a52:	85 f6                	test   %esi,%esi
40030a54:	79 08                	jns    40030a5e <_ladd+0x21>
40030a56:	eb 0d                	jmp    40030a65 <_ladd+0x28>
static void _ladd(uint32_t result[], uint32_t value[])
{
	uint32_t carry;
	uint32_t temp;

	carry = 0;
40030a58:	31 c9                	xor    %ecx,%ecx
	temp = result[0] + value[0];
	if (result[0] & 0x80000000) {
		if ((value[0] & 0x80000000) || ((temp & 0x80000000) == 0))
			carry = 1;
	} else {
		if ((value[0] & 0x80000000) && ((temp & 0x80000000) == 0))
40030a5a:	85 f6                	test   %esi,%esi
40030a5c:	79 07                	jns    40030a65 <_ladd+0x28>

	carry = 0;
	temp = result[0] + value[0];
	if (result[0] & 0x80000000) {
		if ((value[0] & 0x80000000) || ((temp & 0x80000000) == 0))
			carry = 1;
40030a5e:	89 d9                	mov    %ebx,%ecx
40030a60:	f7 d1                	not    %ecx
40030a62:	c1 e9 1f             	shr    $0x1f,%ecx
	} else {
		if ((value[0] & 0x80000000) && ((temp & 0x80000000) == 0))
			carry = 1;
	}
	result[0] = temp;
40030a65:	89 18                	mov    %ebx,(%eax)
	result[1] = result[1] + value[1] + carry;
}
40030a67:	5b                   	pop    %ebx
	} else {
		if ((value[0] & 0x80000000) && ((temp & 0x80000000) == 0))
			carry = 1;
	}
	result[0] = temp;
	result[1] = result[1] + value[1] + carry;
40030a68:	8b 52 04             	mov    0x4(%edx),%edx
}
40030a6b:	5e                   	pop    %esi
	} else {
		if ((value[0] & 0x80000000) && ((temp & 0x80000000) == 0))
			carry = 1;
	}
	result[0] = temp;
	result[1] = result[1] + value[1] + carry;
40030a6c:	03 50 04             	add    0x4(%eax),%edx
}
40030a6f:	5d                   	pop    %ebp
	} else {
		if ((value[0] & 0x80000000) && ((temp & 0x80000000) == 0))
			carry = 1;
	}
	result[0] = temp;
	result[1] = result[1] + value[1] + carry;
40030a70:	01 d1                	add    %edx,%ecx
40030a72:	89 48 04             	mov    %ecx,0x4(%eax)
}
40030a75:	c3                   	ret    

40030a76 <_rlrshift>:

static	void _rlrshift(uint32_t value[])
{
40030a76:	55                   	push   %ebp
40030a77:	89 e5                	mov    %esp,%ebp
40030a79:	83 ec 08             	sub    $0x8,%esp
	uint32_t temp[2];

	temp[0] = value[0] & 1;
40030a7c:	8b 10                	mov    (%eax),%edx
40030a7e:	89 d1                	mov    %edx,%ecx
	temp[1] = 0;
40030a80:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}

static void _lrshift(uint32_t value[])
{
	if (value[1] & 1)
		value[0] = (value[0] >> 1) | 0x80000000;
40030a87:	d1 ea                	shr    %edx

static	void _rlrshift(uint32_t value[])
{
	uint32_t temp[2];

	temp[0] = value[0] & 1;
40030a89:	83 e1 01             	and    $0x1,%ecx
40030a8c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
	value[0] <<= 1;
}

static void _lrshift(uint32_t value[])
{
	if (value[1] & 1)
40030a8f:	8b 48 04             	mov    0x4(%eax),%ecx
40030a92:	f6 c1 01             	test   $0x1,%cl
40030a95:	74 06                	je     40030a9d <_rlrshift+0x27>
		value[0] = (value[0] >> 1) | 0x80000000;
40030a97:	81 ca 00 00 00 80    	or     $0x80000000,%edx
	else
		value[0] = (value[0] >> 1) & 0x7FFFFFFF;
	value[1] = (value[1] >> 1) & 0x7FFFFFFF;
40030a9d:	d1 e9                	shr    %ecx
static void _lrshift(uint32_t value[])
{
	if (value[1] & 1)
		value[0] = (value[0] >> 1) | 0x80000000;
	else
		value[0] = (value[0] >> 1) & 0x7FFFFFFF;
40030a9f:	89 10                	mov    %edx,(%eax)
	value[1] = (value[1] >> 1) & 0x7FFFFFFF;
40030aa1:	89 48 04             	mov    %ecx,0x4(%eax)
	uint32_t temp[2];

	temp[0] = value[0] & 1;
	temp[1] = 0;
	_lrshift(value);
	_ladd(value, temp);
40030aa4:	8d 55 f8             	lea    -0x8(%ebp),%edx
40030aa7:	e8 91 ff ff ff       	call   40030a3d <_ladd>
}
40030aac:	c9                   	leave  
40030aad:	c3                   	ret    

40030aae <_get_digit>:
static	char _get_digit(uint32_t fract[], int *digit_count)
{
	int		rval;
	uint32_t	temp[2];

	if (*digit_count > 0) {
40030aae:	8b 0a                	mov    (%edx),%ecx
40030ab0:	85 c9                	test   %ecx,%ecx
40030ab2:	7e 4f                	jle    40030b03 <_get_digit+0x55>
	value[0] = result[0];
	value[1] = result[1];
}

static	char _get_digit(uint32_t fract[], int *digit_count)
{
40030ab4:	55                   	push   %ebp
	int		rval;
	uint32_t	temp[2];

	if (*digit_count > 0) {
		*digit_count -= 1;
40030ab5:	49                   	dec    %ecx
	value[0] = result[0];
	value[1] = result[1];
}

static	char _get_digit(uint32_t fract[], int *digit_count)
{
40030ab6:	89 e5                	mov    %esp,%ebp
40030ab8:	53                   	push   %ebx
40030ab9:	83 ec 08             	sub    $0x8,%esp
40030abc:	89 c3                	mov    %eax,%ebx
	int		rval;
	uint32_t	temp[2];

	if (*digit_count > 0) {
		*digit_count -= 1;
40030abe:	89 0a                	mov    %ecx,(%edx)
		temp[0] = fract[0];
40030ac0:	8b 00                	mov    (%eax),%eax
40030ac2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		temp[1] = fract[1];
40030ac5:	8b 43 04             	mov    0x4(%ebx),%eax
40030ac8:	89 45 f8             	mov    %eax,-0x8(%ebp)
		_llshift(fract);	/* Multiply by 10 */
40030acb:	89 d8                	mov    %ebx,%eax
40030acd:	e8 4d ff ff ff       	call   40030a1f <_llshift>
		_llshift(fract);
40030ad2:	89 d8                	mov    %ebx,%eax
40030ad4:	e8 46 ff ff ff       	call   40030a1f <_llshift>
		_ladd(fract, temp);
40030ad9:	8d 55 f4             	lea    -0xc(%ebp),%edx
40030adc:	89 d8                	mov    %ebx,%eax
40030ade:	e8 5a ff ff ff       	call   40030a3d <_ladd>
		_llshift(fract);
40030ae3:	89 d8                	mov    %ebx,%eax
40030ae5:	e8 35 ff ff ff       	call   40030a1f <_llshift>
		rval = ((fract[1] >> 28) & 0xF) + '0';
40030aea:	8b 53 04             	mov    0x4(%ebx),%edx
40030aed:	89 d0                	mov    %edx,%eax
		fract[1] &= 0x0FFFFFFF;
40030aef:	81 e2 ff ff ff 0f    	and    $0xfffffff,%edx
		temp[1] = fract[1];
		_llshift(fract);	/* Multiply by 10 */
		_llshift(fract);
		_ladd(fract, temp);
		_llshift(fract);
		rval = ((fract[1] >> 28) & 0xF) + '0';
40030af5:	c1 e8 1c             	shr    $0x1c,%eax
		fract[1] &= 0x0FFFFFFF;
40030af8:	89 53 04             	mov    %edx,0x4(%ebx)
	} else
		rval = '0';
	return (char) (rval);
}
40030afb:	5a                   	pop    %edx
		temp[1] = fract[1];
		_llshift(fract);	/* Multiply by 10 */
		_llshift(fract);
		_ladd(fract, temp);
		_llshift(fract);
		rval = ((fract[1] >> 28) & 0xF) + '0';
40030afc:	83 c0 30             	add    $0x30,%eax
		fract[1] &= 0x0FFFFFFF;
	} else
		rval = '0';
	return (char) (rval);
}
40030aff:	59                   	pop    %ecx
40030b00:	5b                   	pop    %ebx
40030b01:	5d                   	pop    %ebp
40030b02:	c3                   	ret    
		_ladd(fract, temp);
		_llshift(fract);
		rval = ((fract[1] >> 28) & 0xF) + '0';
		fract[1] &= 0x0FFFFFFF;
	} else
		rval = '0';
40030b03:	b8 30 00 00 00       	mov    $0x30,%eax
40030b08:	c3                   	ret    

40030b09 <_ldiv5>:
  * 64 bit divide by 5 function for _to_float.
  * The result is ROUNDED, not TRUNCATED.
  */

static	void _ldiv5(uint32_t value[])
{
40030b09:	55                   	push   %ebp
	register int  shift;
	uint32_t      temp1[2];
	uint32_t      temp2[2];

	result[0] = 0;		/* Result accumulator */
	result[1] = value[1] / 5;
40030b0a:	b9 05 00 00 00       	mov    $0x5,%ecx
  * 64 bit divide by 5 function for _to_float.
  * The result is ROUNDED, not TRUNCATED.
  */

static	void _ldiv5(uint32_t value[])
{
40030b0f:	89 e5                	mov    %esp,%ebp
40030b11:	56                   	push   %esi
40030b12:	53                   	push   %ebx
	register int  shift;
	uint32_t      temp1[2];
	uint32_t      temp2[2];

	result[0] = 0;		/* Result accumulator */
	result[1] = value[1] / 5;
40030b13:	31 d2                	xor    %edx,%edx
  * 64 bit divide by 5 function for _to_float.
  * The result is ROUNDED, not TRUNCATED.
  */

static	void _ldiv5(uint32_t value[])
{
40030b15:	83 ec 18             	sub    $0x18,%esp
40030b18:	89 c3                	mov    %eax,%ebx
	register int  shift;
	uint32_t      temp1[2];
	uint32_t      temp2[2];

	result[0] = 0;		/* Result accumulator */
	result[1] = value[1] / 5;
40030b1a:	8b 40 04             	mov    0x4(%eax),%eax
	uint32_t      result[2];
	register int  shift;
	uint32_t      temp1[2];
	uint32_t      temp2[2];

	result[0] = 0;		/* Result accumulator */
40030b1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	result[1] = value[1] / 5;
40030b24:	f7 f1                	div    %ecx
40030b26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	temp1[0] = value[0];	/* Dividend for this pass */
40030b29:	8b 03                	mov    (%ebx),%eax
40030b2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	temp1[1] = value[1] % 5;
40030b2e:	89 55 ec             	mov    %edx,-0x14(%ebp)
	temp2[1] = 0;
40030b31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
40030b38:	8b 45 e8             	mov    -0x18(%ebp),%eax

	while (1) {
		for (shift = 0; temp1[1] != 0; shift++)
40030b3b:	31 c9                	xor    %ecx,%ecx
40030b3d:	31 f6                	xor    %esi,%esi
40030b3f:	8b 55 ec             	mov    -0x14(%ebp),%edx
40030b42:	85 d2                	test   %edx,%edx
40030b44:	74 16                	je     40030b5c <_ldiv5+0x53>
}

static void _lrshift(uint32_t value[])
{
	if (value[1] & 1)
		value[0] = (value[0] >> 1) | 0x80000000;
40030b46:	d1 e8                	shr    %eax
	value[0] <<= 1;
}

static void _lrshift(uint32_t value[])
{
	if (value[1] & 1)
40030b48:	f6 c2 01             	test   $0x1,%dl
40030b4b:	74 05                	je     40030b52 <_ldiv5+0x49>
		value[0] = (value[0] >> 1) | 0x80000000;
40030b4d:	0d 00 00 00 80       	or     $0x80000000,%eax
	else
		value[0] = (value[0] >> 1) & 0x7FFFFFFF;
	value[1] = (value[1] >> 1) & 0x7FFFFFFF;
40030b52:	d1 ea                	shr    %edx
	temp1[0] = value[0];	/* Dividend for this pass */
	temp1[1] = value[1] % 5;
	temp2[1] = 0;

	while (1) {
		for (shift = 0; temp1[1] != 0; shift++)
40030b54:	46                   	inc    %esi
{
	if (value[1] & 1)
		value[0] = (value[0] >> 1) | 0x80000000;
	else
		value[0] = (value[0] >> 1) & 0x7FFFFFFF;
	value[1] = (value[1] >> 1) & 0x7FFFFFFF;
40030b55:	89 55 ec             	mov    %edx,-0x14(%ebp)
40030b58:	b1 01                	mov    $0x1,%cl
40030b5a:	eb e3                	jmp    40030b3f <_ldiv5+0x36>
40030b5c:	84 c9                	test   %cl,%cl
40030b5e:	74 03                	je     40030b63 <_ldiv5+0x5a>
40030b60:	89 45 e8             	mov    %eax,-0x18(%ebp)
	temp2[1] = 0;

	while (1) {
		for (shift = 0; temp1[1] != 0; shift++)
			_lrshift(temp1);
		temp2[0] = temp1[0] / 5;
40030b63:	31 d2                	xor    %edx,%edx
40030b65:	8b 45 e8             	mov    -0x18(%ebp),%eax
40030b68:	b9 05 00 00 00       	mov    $0x5,%ecx
40030b6d:	f7 f1                	div    %ecx
40030b6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (temp2[0] == 0) {
40030b72:	85 c0                	test   %eax,%eax
40030b74:	75 1d                	jne    40030b93 <_ldiv5+0x8a>
			if (temp1[0] % 5 > (5 / 2)) {
40030b76:	83 fa 02             	cmp    $0x2,%edx
40030b79:	0f 86 80 00 00 00    	jbe    40030bff <_ldiv5+0xf6>
				temp1[0] = 1;
				_ladd(result, temp1);
40030b7f:	8d 55 e8             	lea    -0x18(%ebp),%edx
40030b82:	8d 45 e0             	lea    -0x20(%ebp),%eax
		for (shift = 0; temp1[1] != 0; shift++)
			_lrshift(temp1);
		temp2[0] = temp1[0] / 5;
		if (temp2[0] == 0) {
			if (temp1[0] % 5 > (5 / 2)) {
				temp1[0] = 1;
40030b85:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
				_ladd(result, temp1);
40030b8c:	e8 ac fe ff ff       	call   40030a3d <_ladd>
40030b91:	eb 6c                	jmp    40030bff <_ldiv5+0xf6>
			}
			break;
		}
		temp1[0] = temp2[0];
40030b93:	89 45 e8             	mov    %eax,-0x18(%ebp)
		while (shift-- != 0)
40030b96:	4e                   	dec    %esi
40030b97:	83 fe ff             	cmp    $0xffffffff,%esi
40030b9a:	74 0a                	je     40030ba6 <_ldiv5+0x9d>
			_llshift(temp1);
40030b9c:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030b9f:	e8 7b fe ff ff       	call   40030a1f <_llshift>
40030ba4:	eb f0                	jmp    40030b96 <_ldiv5+0x8d>
		_ladd(result, temp1);	/* Update result accumulator */
40030ba6:	8d 55 e8             	lea    -0x18(%ebp),%edx
40030ba9:	8d 45 e0             	lea    -0x20(%ebp),%eax
40030bac:	e8 8c fe ff ff       	call   40030a3d <_ladd>
		temp1[0] = result[0];
40030bb1:	8b 45 e0             	mov    -0x20(%ebp),%eax
40030bb4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		temp1[1] = result[1];
40030bb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40030bba:	89 45 ec             	mov    %eax,-0x14(%ebp)
		_llshift(temp1);	/* Compute (current_result*5) */
40030bbd:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030bc0:	e8 5a fe ff ff       	call   40030a1f <_llshift>
		_llshift(temp1);
40030bc5:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030bc8:	e8 52 fe ff ff       	call   40030a1f <_llshift>
		_ladd(temp1, result);
40030bcd:	8d 55 e0             	lea    -0x20(%ebp),%edx
40030bd0:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030bd3:	e8 65 fe ff ff       	call   40030a3d <_ladd>
		temp1[0] = ~temp1[0];	/* Compute -(current_result*5) */
		temp1[1] = ~temp1[1];
		temp2[0] = 1;
		_ladd(temp1, temp2);
40030bd8:	8d 55 f0             	lea    -0x10(%ebp),%edx
40030bdb:	8d 45 e8             	lea    -0x18(%ebp),%eax
		_llshift(temp1);	/* Compute (current_result*5) */
		_llshift(temp1);
		_ladd(temp1, result);
		temp1[0] = ~temp1[0];	/* Compute -(current_result*5) */
		temp1[1] = ~temp1[1];
		temp2[0] = 1;
40030bde:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		temp1[0] = result[0];
		temp1[1] = result[1];
		_llshift(temp1);	/* Compute (current_result*5) */
		_llshift(temp1);
		_ladd(temp1, result);
		temp1[0] = ~temp1[0];	/* Compute -(current_result*5) */
40030be5:	f7 55 e8             	notl   -0x18(%ebp)
		temp1[1] = ~temp1[1];
40030be8:	f7 55 ec             	notl   -0x14(%ebp)
		temp2[0] = 1;
		_ladd(temp1, temp2);
40030beb:	e8 4d fe ff ff       	call   40030a3d <_ladd>
		_ladd(temp1, value);	/* Compute #-(current_result*5) */
40030bf0:	89 da                	mov    %ebx,%edx
40030bf2:	8d 45 e8             	lea    -0x18(%ebp),%eax
40030bf5:	e8 43 fe ff ff       	call   40030a3d <_ladd>
	}
40030bfa:	e9 39 ff ff ff       	jmp    40030b38 <_ldiv5+0x2f>
	value[0] = result[0];
40030bff:	8b 45 e0             	mov    -0x20(%ebp),%eax
40030c02:	89 03                	mov    %eax,(%ebx)
	value[1] = result[1];
40030c04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
40030c07:	89 43 04             	mov    %eax,0x4(%ebx)
}
40030c0a:	83 c4 18             	add    $0x18,%esp
40030c0d:	5b                   	pop    %ebx
40030c0e:	5e                   	pop    %esi
40030c0f:	5d                   	pop    %ebp
40030c10:	c3                   	ret    

40030c11 <_prf>:
	*sptr = p;
	return i;
}

int _prf(int (*func)(), void *dest, char *format, va_list vargs)
{
40030c11:	55                   	push   %ebp
40030c12:	89 e5                	mov    %esp,%ebp
40030c14:	57                   	push   %edi
40030c15:	56                   	push   %esi
40030c16:	53                   	push   %ebx
40030c17:	81 ec 18 01 00 00    	sub    $0x118,%esp
40030c1d:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
40030c23:	89 95 dc fe ff ff    	mov    %edx,-0x124(%ebp)
40030c29:	8b 7d 08             	mov    0x8(%ebp),%edi
	int32_t			*int32ptr_temp;
	int32_t			int32_temp;
	uint32_t			uint32_temp;
	uint32_t			double_temp[2];

	count = 0;
40030c2c:	c7 85 00 ff ff ff 00 	movl   $0x0,-0x100(%ebp)
40030c33:	00 00 00 

	while ((c = *format++)) {
40030c36:	8d 41 01             	lea    0x1(%ecx),%eax
40030c39:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
40030c3f:	0f be 01             	movsbl (%ecx),%eax
40030c42:	85 c0                	test   %eax,%eax
40030c44:	0f 84 c8 0a 00 00    	je     40031712 <_prf+0xb01>
		if (c != '%') {
40030c4a:	83 f8 25             	cmp    $0x25,%eax
40030c4d:	75 31                	jne    40030c80 <_prf+0x6f>
40030c4f:	c6 85 fb fe ff ff 20 	movb   $0x20,-0x105(%ebp)
40030c56:	c7 85 ec fe ff ff 00 	movl   $0x0,-0x114(%ebp)
40030c5d:	00 00 00 
40030c60:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
40030c67:	00 00 00 
40030c6a:	c7 85 e8 fe ff ff 00 	movl   $0x0,-0x118(%ebp)
40030c71:	00 00 00 
40030c74:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
40030c7b:	00 00 00 
40030c7e:	eb 40                	jmp    40030cc0 <_prf+0xaf>
			if ((*func) (c, dest) == EOF) {
40030c80:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
40030c86:	8b 8d e0 fe ff ff    	mov    -0x120(%ebp),%ecx
40030c8c:	ff d1                	call   *%ecx
40030c8e:	40                   	inc    %eax
40030c8f:	75 08                	jne    40030c99 <_prf+0x88>
				return EOF;
40030c91:	83 c8 ff             	or     $0xffffffff,%eax
40030c94:	e9 3a 0b 00 00       	jmp    400317d3 <_prf+0xbc2>
			}

			count++;
40030c99:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
40030c9f:	e9 4d 0a 00 00       	jmp    400316f1 <_prf+0xae0>
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
40030ca4:	80 fb 23             	cmp    $0x23,%bl
40030ca7:	74 72                	je     40030d1b <_prf+0x10a>
40030ca9:	7e 41                	jle    40030cec <_prf+0xdb>
40030cab:	80 fb 2d             	cmp    $0x2d,%bl
40030cae:	75 55                	jne    40030d05 <_prf+0xf4>
				case '-':
					fminus = true;
40030cb0:	c7 85 e8 fe ff ff 01 	movl   $0x1,-0x118(%ebp)
40030cb7:	00 00 00 
					break;

				case '+':
					fplus = true;
40030cba:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
40030cc0:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
40030cc6:	0f be 30             	movsbl (%eax),%esi
40030cc9:	8d 48 01             	lea    0x1(%eax),%ecx
40030ccc:	89 f2                	mov    %esi,%edx
40030cce:	b8 2c 28 03 40       	mov    $0x4003282c,%eax
40030cd3:	89 8d 10 ff ff ff    	mov    %ecx,-0xf0(%ebp)
40030cd9:	e8 19 0b 00 00       	call   400317f7 <strchr>
40030cde:	89 f3                	mov    %esi,%ebx
40030ce0:	85 c0                	test   %eax,%eax
40030ce2:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
40030ce8:	75 ba                	jne    40030ca4 <_prf+0x93>
40030cea:	eb 44                	jmp    40030d30 <_prf+0x11f>
				switch (c) {
40030cec:	84 db                	test   %bl,%bl
40030cee:	0f 84 1e 0a 00 00    	je     40031712 <_prf+0xb01>
40030cf4:	80 fb 20             	cmp    $0x20,%bl
40030cf7:	75 c1                	jne    40030cba <_prf+0xa9>
				case '+':
					fplus = true;
					break;

				case ' ':
					fspace = true;
40030cf9:	c7 85 ec fe ff ff 01 	movl   $0x1,-0x114(%ebp)
40030d00:	00 00 00 
					break;
40030d03:	eb b5                	jmp    40030cba <_prf+0xa9>
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
40030d05:	80 fb 30             	cmp    $0x30,%bl
40030d08:	74 1d                	je     40030d27 <_prf+0x116>
40030d0a:	80 fb 2b             	cmp    $0x2b,%bl
40030d0d:	75 ab                	jne    40030cba <_prf+0xa9>
				case '-':
					fminus = true;
					break;

				case '+':
					fplus = true;
40030d0f:	c7 85 f0 fe ff ff 01 	movl   $0x1,-0x110(%ebp)
40030d16:	00 00 00 
					break;
40030d19:	eb 9f                	jmp    40030cba <_prf+0xa9>
				case ' ':
					fspace = true;
					break;

				case '#':
					falt = true;
40030d1b:	c7 85 fc fe ff ff 01 	movl   $0x1,-0x104(%ebp)
40030d22:	00 00 00 
					break;
40030d25:	eb 93                	jmp    40030cba <_prf+0xa9>

				case '0':
					pad = '0';
40030d27:	c6 85 fb fe ff ff 30 	movb   $0x30,-0x105(%ebp)
					break;
40030d2e:	eb 8a                	jmp    40030cba <_prf+0xa9>
				case '\0':
					return count;
				}
			}

			if (c == '*') {
40030d30:	83 fe 2a             	cmp    $0x2a,%esi
40030d33:	75 27                	jne    40030d5c <_prf+0x14b>
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
40030d35:	8d 47 04             	lea    0x4(%edi),%eax
40030d38:	8b 3f                	mov    (%edi),%edi
40030d3a:	89 bd 04 ff ff ff    	mov    %edi,-0xfc(%ebp)
				if (width < 0) {
40030d40:	85 ff                	test   %edi,%edi
40030d42:	79 10                	jns    40030d54 <_prf+0x143>
					fminus = true;
					width = -width;
40030d44:	f7 9d 04 ff ff ff    	negl   -0xfc(%ebp)

			if (c == '*') {
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
				if (width < 0) {
					fminus = true;
40030d4a:	c7 85 e8 fe ff ff 01 	movl   $0x1,-0x118(%ebp)
40030d51:	00 00 00 
					width = -width;
				}
				c = *format++;
40030d54:	0f be 31             	movsbl (%ecx),%esi
				}
			}

			if (c == '*') {
				/* Is the width a parameter? */
				width = (int32_t) va_arg(vargs, int32_t);
40030d57:	89 c7                	mov    %eax,%edi
				if (width < 0) {
					fminus = true;
					width = -width;
				}
				c = *format++;
40030d59:	41                   	inc    %ecx
40030d5a:	eb 45                	jmp    40030da1 <_prf+0x190>
			} else if (!isdigit(c))
40030d5c:	8d 46 d0             	lea    -0x30(%esi),%eax
				width = 0;
40030d5f:	c7 85 04 ff ff ff 00 	movl   $0x0,-0xfc(%ebp)
40030d66:	00 00 00 
				if (width < 0) {
					fminus = true;
					width = -width;
				}
				c = *format++;
			} else if (!isdigit(c))
40030d69:	83 f8 09             	cmp    $0x9,%eax
40030d6c:	77 49                	ja     40030db7 <_prf+0x1a6>
	register int   i;

	i = 0;
	p = *sptr;
	p--;
	while (isdigit(((int) *p)))
40030d6e:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
40030d74:	0f be 30             	movsbl (%eax),%esi
40030d77:	8d 46 d0             	lea    -0x30(%esi),%eax
40030d7a:	83 f8 09             	cmp    $0x9,%eax
40030d7d:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
40030d83:	8d 48 01             	lea    0x1(%eax),%ecx
40030d86:	77 19                	ja     40030da1 <_prf+0x190>
		i = 10 * i + *p++ - '0';
40030d88:	6b 85 04 ff ff ff 0a 	imul   $0xa,-0xfc(%ebp),%eax
40030d8f:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40030d95:	8d 44 30 d0          	lea    -0x30(%eax,%esi,1),%eax
40030d99:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
40030d9f:	eb cd                	jmp    40030d6e <_prf+0x15d>
			else {
				width = _atoi(&format);	/* Find width */
				c = *format++;
			}

			if (width > MAXFLD)
40030da1:	81 bd 04 ff ff ff c8 	cmpl   $0xc8,-0xfc(%ebp)
40030da8:	00 00 00 
40030dab:	7e 0a                	jle    40030db7 <_prf+0x1a6>
				width = MAXFLD;
40030dad:	c7 85 04 ff ff ff c8 	movl   $0xc8,-0xfc(%ebp)
40030db4:	00 00 00 
			count++;

		} else {
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */
40030db7:	c7 85 10 ff ff ff ff 	movl   $0xffffffff,-0xf0(%ebp)
40030dbe:	ff ff ff 
			}

			if (width > MAXFLD)
				width = MAXFLD;

			if (c == '.') {
40030dc1:	83 fe 2e             	cmp    $0x2e,%esi
40030dc4:	75 5e                	jne    40030e24 <_prf+0x213>
				c = *format++;
				if (c == '*') {
40030dc6:	80 39 2a             	cmpb   $0x2a,(%ecx)
40030dc9:	74 0e                	je     40030dd9 <_prf+0x1c8>
40030dcb:	c7 85 10 ff ff ff 00 	movl   $0x0,-0xf0(%ebp)
40030dd2:	00 00 00 
40030dd5:	89 c8                	mov    %ecx,%eax
40030dd7:	eb 10                	jmp    40030de9 <_prf+0x1d8>
					precision = (int32_t)
40030dd9:	8b 17                	mov    (%edi),%edx

			if (width > MAXFLD)
				width = MAXFLD;

			if (c == '.') {
				c = *format++;
40030ddb:	8d 41 01             	lea    0x1(%ecx),%eax
				if (c == '*') {
					precision = (int32_t)
40030dde:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
40030de4:	83 c7 04             	add    $0x4,%edi
40030de7:	eb 1f                	jmp    40030e08 <_prf+0x1f7>
	register int   i;

	i = 0;
	p = *sptr;
	p--;
	while (isdigit(((int) *p)))
40030de9:	0f be 10             	movsbl (%eax),%edx
40030dec:	8d 4a d0             	lea    -0x30(%edx),%ecx
40030def:	83 f9 09             	cmp    $0x9,%ecx
40030df2:	77 14                	ja     40030e08 <_prf+0x1f7>
		i = 10 * i + *p++ - '0';
40030df4:	6b 8d 10 ff ff ff 0a 	imul   $0xa,-0xf0(%ebp),%ecx
40030dfb:	40                   	inc    %eax
40030dfc:	8d 54 11 d0          	lea    -0x30(%ecx,%edx,1),%edx
40030e00:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
40030e06:	eb e1                	jmp    40030de9 <_prf+0x1d8>
					precision = (int32_t)
					va_arg(vargs, int32_t);
				} else
					precision = _atoi(&format);

				if (precision > MAXFLD)
40030e08:	81 bd 10 ff ff ff c8 	cmpl   $0xc8,-0xf0(%ebp)
40030e0f:	00 00 00 
40030e12:	7e 0a                	jle    40030e1e <_prf+0x20d>
					precision = -1;
40030e14:	c7 85 10 ff ff ff ff 	movl   $0xffffffff,-0xf0(%ebp)
40030e1b:	ff ff ff 
				c = *format++;
40030e1e:	0f be 30             	movsbl (%eax),%esi
40030e21:	8d 48 01             	lea    0x1(%eax),%ecx
			 *    l: long
			 *    L: long double
			 * No further special processing is done for them.
			 */

			if (strchr("hlL", c) != NULL) {
40030e24:	89 f2                	mov    %esi,%edx
40030e26:	b8 32 28 03 40       	mov    $0x40032832,%eax
40030e2b:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40030e31:	e8 c1 09 00 00       	call   400317f7 <strchr>
40030e36:	8b 8d 0c ff ff ff    	mov    -0xf4(%ebp),%ecx
40030e3c:	85 c0                	test   %eax,%eax
40030e3e:	74 43                	je     40030e83 <_prf+0x272>
				i = c;
				c = *format++;
40030e40:	8d 41 01             	lea    0x1(%ecx),%eax
				switch (i) {
40030e43:	83 fe 68             	cmp    $0x68,%esi
			 * No further special processing is done for them.
			 */

			if (strchr("hlL", c) != NULL) {
				i = c;
				c = *format++;
40030e46:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
40030e4c:	0f be 01             	movsbl (%ecx),%eax
40030e4f:	89 c3                	mov    %eax,%ebx
40030e51:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%ebp)
				switch (i) {
40030e57:	74 18                	je     40030e71 <_prf+0x260>
40030e59:	83 fe 6c             	cmp    $0x6c,%esi
40030e5c:	74 13                	je     40030e71 <_prf+0x260>
40030e5e:	83 fe 4c             	cmp    $0x4c,%esi
40030e61:	0f 85 7c 01 00 00    	jne    40030fe3 <_prf+0x3d2>
					if (strchr("diouxX", c) == NULL)
						break;
					break;

				case 'L':
					if (strchr("eEfgG", c) == NULL)
40030e67:	0f be d0             	movsbl %al,%edx
40030e6a:	b8 3d 28 03 40       	mov    $0x4003283d,%eax
40030e6f:	eb 08                	jmp    40030e79 <_prf+0x268>
					if (strchr("diouxX", c) == NULL)
						break;
					break;

				case 'l':
					if (strchr("diouxX", c) == NULL)
40030e71:	0f be d3             	movsbl %bl,%edx
40030e74:	b8 36 28 03 40       	mov    $0x40032836,%eax
						break;
					break;

				case 'L':
					if (strchr("eEfgG", c) == NULL)
40030e79:	e8 79 09 00 00       	call   400317f7 <strchr>
40030e7e:	e9 60 01 00 00       	jmp    40030fe3 <_prf+0x3d2>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
40030e83:	83 fe 67             	cmp    $0x67,%esi
40030e86:	7f 4c                	jg     40030ed4 <_prf+0x2c3>
40030e88:	83 fe 65             	cmp    $0x65,%esi
40030e8b:	0f 8d 4a 01 00 00    	jge    40030fdb <_prf+0x3ca>
40030e91:	83 fe 47             	cmp    $0x47,%esi
40030e94:	0f 84 41 01 00 00    	je     40030fdb <_prf+0x3ca>
40030e9a:	7f 1f                	jg     40030ebb <_prf+0x2aa>
40030e9c:	83 fe 25             	cmp    $0x25,%esi
40030e9f:	0f 84 c1 07 00 00    	je     40031666 <_prf+0xa55>
40030ea5:	83 fe 45             	cmp    $0x45,%esi
40030ea8:	0f 84 2d 01 00 00    	je     40030fdb <_prf+0x3ca>
40030eae:	85 f6                	test   %esi,%esi
40030eb0:	0f 84 5c 08 00 00    	je     40031712 <_prf+0xb01>
40030eb6:	e9 cb 08 00 00       	jmp    40031786 <_prf+0xb75>
40030ebb:	83 fe 63             	cmp    $0x63,%esi
40030ebe:	74 64                	je     40030f24 <_prf+0x313>
40030ec0:	0f 8f 85 00 00 00    	jg     40030f4b <_prf+0x33a>
40030ec6:	83 fe 58             	cmp    $0x58,%esi
40030ec9:	0f 84 20 07 00 00    	je     400315ef <_prf+0x9de>
40030ecf:	e9 b2 08 00 00       	jmp    40031786 <_prf+0xb75>
40030ed4:	83 fe 70             	cmp    $0x70,%esi
40030ed7:	0f 84 58 06 00 00    	je     40031535 <_prf+0x924>
40030edd:	7f 1f                	jg     40030efe <_prf+0x2ed>
40030edf:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40030ee5:	83 fe 6e             	cmp    $0x6e,%esi
40030ee8:	0f 84 a7 05 00 00    	je     40031495 <_prf+0x884>
40030eee:	0f 8f b9 05 00 00    	jg     400314ad <_prf+0x89c>
40030ef4:	83 fe 69             	cmp    $0x69,%esi
40030ef7:	74 52                	je     40030f4b <_prf+0x33a>
40030ef9:	e9 88 08 00 00       	jmp    40031786 <_prf+0xb75>
40030efe:	83 fe 75             	cmp    $0x75,%esi
40030f01:	0f 84 c2 06 00 00    	je     400315c9 <_prf+0x9b8>
40030f07:	83 fe 78             	cmp    $0x78,%esi
40030f0a:	0f 84 df 06 00 00    	je     400315ef <_prf+0x9de>
40030f10:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40030f16:	83 fe 73             	cmp    $0x73,%esi
40030f19:	0f 84 59 06 00 00    	je     40031578 <_prf+0x967>
40030f1f:	e9 62 08 00 00       	jmp    40031786 <_prf+0xb75>
40030f24:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
			case 'c':
				buf[0] = (char) ((int32_t) va_arg(vargs, int32_t));
40030f2a:	8b 07                	mov    (%edi),%eax
40030f2c:	8d 77 04             	lea    0x4(%edi),%esi
40030f2f:	88 85 2b ff ff ff    	mov    %al,-0xd5(%ebp)
				buf[1] = '\0';
40030f35:	c6 85 2c ff ff ff 00 	movb   $0x0,-0xd4(%ebp)
				need_justifying = true;
				c = 1;
40030f3c:	c7 85 10 ff ff ff 01 	movl   $0x1,-0xf0(%ebp)
40030f43:	00 00 00 
				break;
40030f46:	e9 6b 08 00 00       	jmp    400317b6 <_prf+0xba5>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
40030f4b:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
				c = 1;
				break;

			case 'd':
			case 'i':
				int32_temp = (int32_t) va_arg(vargs, int32_t);
40030f51:	8d 47 04             	lea    0x4(%edi),%eax
40030f54:	8b 37                	mov    (%edi),%esi
40030f56:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)

#if (MAXFLD < 10)
  #error buffer size MAXFLD is too small
#endif

	if (value < 0) {
40030f5c:	85 f6                	test   %esi,%esi
40030f5e:	79 1a                	jns    40030f7a <_prf+0x369>
		*buf++ = '-';
40030f60:	c6 85 2b ff ff ff 2d 	movb   $0x2d,-0xd5(%ebp)
		if (value != 0x80000000)
40030f67:	ba 00 00 00 80       	mov    $0x80000000,%edx
40030f6c:	81 fe 00 00 00 80    	cmp    $0x80000000,%esi
40030f72:	74 2a                	je     40030f9e <_prf+0x38d>
			value = -value;
40030f74:	89 f2                	mov    %esi,%edx
40030f76:	f7 da                	neg    %edx
40030f78:	eb 24                	jmp    40030f9e <_prf+0x38d>
	} else if (fplus)
40030f7a:	83 bd f0 fe ff ff 00 	cmpl   $0x0,-0x110(%ebp)
40030f81:	74 09                	je     40030f8c <_prf+0x37b>
		*buf++ = '+';
40030f83:	c6 85 2b ff ff ff 2b 	movb   $0x2b,-0xd5(%ebp)
40030f8a:	eb 10                	jmp    40030f9c <_prf+0x38b>
	else if (fspace)
40030f8c:	83 bd ec fe ff ff 00 	cmpl   $0x0,-0x114(%ebp)
40030f93:	74 11                	je     40030fa6 <_prf+0x395>
		*buf++ = ' ';
40030f95:	c6 85 2b ff ff ff 20 	movb   $0x20,-0xd5(%ebp)
40030f9c:	89 f2                	mov    %esi,%edx
40030f9e:	8d 9d 2c ff ff ff    	lea    -0xd4(%ebp),%ebx
40030fa4:	eb 08                	jmp    40030fae <_prf+0x39d>
		*buf++ = '-';
		if (value != 0x80000000)
			value = -value;
	} else if (fplus)
		*buf++ = '+';
	else if (fspace)
40030fa6:	89 f2                	mov    %esi,%edx
40030fa8:	8d 9d 2b ff ff ff    	lea    -0xd5(%ebp),%ebx
		*buf++ = ' ';

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
40030fae:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
40030fb4:	89 d8                	mov    %ebx,%eax
40030fb6:	e8 03 fa ff ff       	call   400309be <_to_udec>
					break;
				}
			}

			need_justifying = false;
			prefix = 0;
40030fbb:	8b 95 f0 fe ff ff    	mov    -0x110(%ebp),%edx
40030fc1:	0b 95 ec fe ff ff    	or     -0x114(%ebp),%edx
	} else if (fplus)
		*buf++ = '+';
	else if (fspace)
		*buf++ = ' ';

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
40030fc7:	01 d8                	add    %ebx,%eax
					break;
				}
			}

			need_justifying = false;
			prefix = 0;
40030fc9:	c1 ee 1f             	shr    $0x1f,%esi
	} else if (fplus)
		*buf++ = '+';
	else if (fspace)
		*buf++ = ' ';

	return (buf + _to_udec(buf, (uint32_t) value, precision)) - start;
40030fcc:	8d bd 2b ff ff ff    	lea    -0xd5(%ebp),%edi
40030fd2:	29 f8                	sub    %edi,%eax
					break;
				}
			}

			need_justifying = false;
			prefix = 0;
40030fd4:	09 d6                	or     %edx,%esi
40030fd6:	e9 79 06 00 00       	jmp    40031654 <_prf+0xa43>
			switch (c) {
40030fdb:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40030fe1:	eb 18                	jmp    40030ffb <_prf+0x3ea>
40030fe3:	80 fb 67             	cmp    $0x67,%bl
40030fe6:	0f 8f 95 04 00 00    	jg     40031481 <_prf+0x870>
40030fec:	80 fb 65             	cmp    $0x65,%bl
40030fef:	0f 8c 02 06 00 00    	jl     400315f7 <_prf+0x9e6>
40030ff5:	8b b5 08 ff ff ff    	mov    -0xf8(%ebp),%esi
						uint32_t u1;
						uint32_t u2;
						} s;
				} u;

				u.d = (double) va_arg(vargs, double);
40030ffb:	8d 47 08             	lea    0x8(%edi),%eax
40030ffe:	8b 0f                	mov    (%edi),%ecx
40031000:	8b 7f 04             	mov    0x4(%edi),%edi
40031003:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
	char           *start = buf;

	if (full) {			/* IEEE double */
		exp = (double_temp[1] >> 20) & 0x7FF;
		fract[1] = (double_temp[1] << 11) & 0x7FFFF800;
		fract[1] |= ((double_temp[0] >> 21) & 0x000007FF);
40031009:	89 f8                	mov    %edi,%eax
4003100b:	89 ca                	mov    %ecx,%edx
4003100d:	c1 e0 0b             	shl    $0xb,%eax
	uint32_t        ltemp[2];
	int             prune_zero;
	char           *start = buf;

	if (full) {			/* IEEE double */
		exp = (double_temp[1] >> 20) & 0x7FF;
40031010:	89 fb                	mov    %edi,%ebx
40031012:	c1 eb 14             	shr    $0x14,%ebx
		fract[1] = (double_temp[1] << 11) & 0x7FFFF800;
		fract[1] |= ((double_temp[0] >> 21) & 0x000007FF);
40031015:	25 00 f8 ff 7f       	and    $0x7ffff800,%eax
4003101a:	c1 ea 15             	shr    $0x15,%edx
	uint32_t        ltemp[2];
	int             prune_zero;
	char           *start = buf;

	if (full) {			/* IEEE double */
		exp = (double_temp[1] >> 20) & 0x7FF;
4003101d:	81 e3 ff 07 00 00    	and    $0x7ff,%ebx
		fract[1] = (double_temp[1] << 11) & 0x7FFFF800;
		fract[1] |= ((double_temp[0] >> 21) & 0x000007FF);
		fract[0] = double_temp[0] << 11;
40031023:	c1 e1 0b             	shl    $0xb,%ecx
	char           *start = buf;

	if (full) {			/* IEEE double */
		exp = (double_temp[1] >> 20) & 0x7FF;
		fract[1] = (double_temp[1] << 11) & 0x7FFFF800;
		fract[1] |= ((double_temp[0] >> 21) & 0x000007FF);
40031026:	09 d0                	or     %edx,%eax
40031028:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
		fract[0] = double_temp[0] << 11;
4003102e:	89 8d 18 ff ff ff    	mov    %ecx,-0xe8(%ebp)
		exp = (double_temp[0] >> 23) & 0xFF;
		fract[1] = (double_temp[0] << 8) & 0x7FFFFF00;
		fract[0] = 0;
	}

	if ((full && (exp == 0x7FF)) || ((!full) && (exp == 0xFF))) {
40031034:	81 fb ff 07 00 00    	cmp    $0x7ff,%ebx
4003103a:	74 0a                	je     40031046 <_prf+0x435>
		}
		*buf = 0;
		return buf - start;
	}

	if ((exp | fract[1] | fract[0]) != 0) {
4003103c:	09 c1                	or     %eax,%ecx
4003103e:	09 d9                	or     %ebx,%ecx
40031040:	75 5c                	jne    4003109e <_prf+0x48d>
40031042:	31 db                	xor    %ebx,%ebx
40031044:	eb 76                	jmp    400310bc <_prf+0x4ab>
		fract[1] = (double_temp[0] << 8) & 0x7FFFFF00;
		fract[0] = 0;
	}

	if ((full && (exp == 0x7FF)) || ((!full) && (exp == 0xFF))) {
		if ((fract[1] | fract[0]) == 0) {
40031046:	09 c8                	or     %ecx,%eax
40031048:	75 31                	jne    4003107b <_prf+0x46a>
			if ((full && (double_temp[1] & 0x80000000))
4003104a:	85 ff                	test   %edi,%edi
4003104c:	79 09                	jns    40031057 <_prf+0x446>
				|| (!full && (double_temp[0] & 0x80000000))) {
				*buf++ = '-';
4003104e:	c6 85 2b ff ff ff 2d 	movb   $0x2d,-0xd5(%ebp)
40031055:	eb 07                	jmp    4003105e <_prf+0x44d>
				*buf++ = 'I';
				*buf++ = 'N';
				*buf++ = 'F';
			} else {
				*buf++ = '+';
40031057:	c6 85 2b ff ff ff 2b 	movb   $0x2b,-0xd5(%ebp)
				*buf++ = 'I';
4003105e:	c6 85 2c ff ff ff 49 	movb   $0x49,-0xd4(%ebp)
				*buf++ = 'N';
40031065:	c6 85 2d ff ff ff 4e 	movb   $0x4e,-0xd3(%ebp)
				*buf++ = 'F';
4003106c:	c6 85 2e ff ff ff 46 	movb   $0x46,-0xd2(%ebp)
40031073:	8d 85 2f ff ff ff    	lea    -0xd1(%ebp),%eax
40031079:	eb 1b                	jmp    40031096 <_prf+0x485>
			}
		} else {
			*buf++ = 'N';
4003107b:	c6 85 2b ff ff ff 4e 	movb   $0x4e,-0xd5(%ebp)
			*buf++ = 'a';
40031082:	c6 85 2c ff ff ff 61 	movb   $0x61,-0xd4(%ebp)
			*buf++ = 'N';
40031089:	c6 85 2d ff ff ff 4e 	movb   $0x4e,-0xd3(%ebp)
40031090:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
		}
		*buf = 0;
40031096:	c6 00 00             	movb   $0x0,(%eax)
40031099:	e9 b1 03 00 00       	jmp    4003144f <_prf+0x83e>
	if ((exp | fract[1] | fract[0]) != 0) {
		if (full)
			exp -= (1023 - 1);	/* +1 since .1 vs 1. */
		else
			exp -= (127 - 1);	/* +1 since .1 vs 1. */
		fract[1] |= 0x80000000;
4003109e:	0d 00 00 00 80       	or     $0x80000000,%eax
		return buf - start;
	}

	if ((exp | fract[1] | fract[0]) != 0) {
		if (full)
			exp -= (1023 - 1);	/* +1 since .1 vs 1. */
400310a3:	81 eb fe 03 00 00    	sub    $0x3fe,%ebx
		else
			exp -= (127 - 1);	/* +1 since .1 vs 1. */
		fract[1] |= 0x80000000;
400310a9:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%ebp)
		decexp = true;		/* Wasn't zero */
	} else
		decexp = false;		/* It was zero */

	if (decexp && ((full && (double_temp[1] & 0x80000000))
400310af:	85 ff                	test   %edi,%edi
400310b1:	79 09                	jns    400310bc <_prf+0x4ab>
					|| (!full && (double_temp[0] & 0x80000000)))) {
		*buf++ = '-';
400310b3:	c6 85 2b ff ff ff 2d 	movb   $0x2d,-0xd5(%ebp)
400310ba:	eb 28                	jmp    400310e4 <_prf+0x4d3>
	} else if (fplus)
400310bc:	83 bd f0 fe ff ff 00 	cmpl   $0x0,-0x110(%ebp)
400310c3:	74 09                	je     400310ce <_prf+0x4bd>
		*buf++ = '+';
400310c5:	c6 85 2b ff ff ff 2b 	movb   $0x2b,-0xd5(%ebp)
400310cc:	eb 16                	jmp    400310e4 <_prf+0x4d3>
	else if (fspace)
400310ce:	8d bd 2b ff ff ff    	lea    -0xd5(%ebp),%edi
400310d4:	83 bd ec fe ff ff 00 	cmpl   $0x0,-0x114(%ebp)
400310db:	74 0d                	je     400310ea <_prf+0x4d9>
		*buf++ = ' ';
400310dd:	c6 85 2b ff ff ff 20 	movb   $0x20,-0xd5(%ebp)
400310e4:	8d bd 2c ff ff ff    	lea    -0xd4(%ebp),%edi

	decexp = 0;
400310ea:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
400310f1:	00 00 00 
	while (exp <= -3) {
400310f4:	83 fb fe             	cmp    $0xfffffffe,%ebx
400310f7:	7d 72                	jge    4003116b <_prf+0x55a>
		while (fract[1] >= (MAXFP1 / 5)) {
400310f9:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
400310ff:	3d 32 33 33 33       	cmp    $0x33333332,%eax
40031104:	76 0e                	jbe    40031114 <_prf+0x503>
			_rlrshift(fract);
40031106:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
			exp++;
4003110c:	43                   	inc    %ebx
		*buf++ = ' ';

	decexp = 0;
	while (exp <= -3) {
		while (fract[1] >= (MAXFP1 / 5)) {
			_rlrshift(fract);
4003110d:	e8 64 f9 ff ff       	call   40030a76 <_rlrshift>
40031112:	eb e5                	jmp    400310f9 <_prf+0x4e8>
			exp++;
		}
		ltemp[0] = fract[0];
40031114:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
		ltemp[1] = fract[1];
4003111a:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
		_llshift(fract);
40031120:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
	while (exp <= -3) {
		while (fract[1] >= (MAXFP1 / 5)) {
			_rlrshift(fract);
			exp++;
		}
		ltemp[0] = fract[0];
40031126:	89 95 20 ff ff ff    	mov    %edx,-0xe0(%ebp)
		ltemp[1] = fract[1];
		_llshift(fract);
4003112c:	e8 ee f8 ff ff       	call   40030a1f <_llshift>
		_llshift(fract);
40031131:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
40031137:	e8 e3 f8 ff ff       	call   40030a1f <_llshift>
		_ladd(fract, ltemp);
4003113c:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
40031142:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
		exp++;
40031148:	43                   	inc    %ebx
		}
		ltemp[0] = fract[0];
		ltemp[1] = fract[1];
		_llshift(fract);
		_llshift(fract);
		_ladd(fract, ltemp);
40031149:	e8 ef f8 ff ff       	call   40030a3d <_ladd>
		exp++;
		decexp--;
4003114e:	ff 8d 08 ff ff ff    	decl   -0xf8(%ebp)

		while (fract[1] <= (MAXFP1 / 2)) {
40031154:	83 bd 1c ff ff ff 00 	cmpl   $0x0,-0xe4(%ebp)
4003115b:	78 97                	js     400310f4 <_prf+0x4e3>
			_llshift(fract);
4003115d:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
			exp--;
40031163:	4b                   	dec    %ebx
		_ladd(fract, ltemp);
		exp++;
		decexp--;

		while (fract[1] <= (MAXFP1 / 2)) {
			_llshift(fract);
40031164:	e8 b6 f8 ff ff       	call   40030a1f <_llshift>
40031169:	eb e9                	jmp    40031154 <_prf+0x543>
			exp--;
		}
	}

	while (exp > 0) {
4003116b:	85 db                	test   %ebx,%ebx
4003116d:	7e 29                	jle    40031198 <_prf+0x587>
		_ldiv5(fract);
4003116f:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
		exp--;
40031175:	4b                   	dec    %ebx
			exp--;
		}
	}

	while (exp > 0) {
		_ldiv5(fract);
40031176:	e8 8e f9 ff ff       	call   40030b09 <_ldiv5>
		exp--;
		decexp++;
4003117b:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
		while (fract[1] <= (MAXFP1 / 2)) {
40031181:	83 bd 1c ff ff ff 00 	cmpl   $0x0,-0xe4(%ebp)
40031188:	78 e1                	js     4003116b <_prf+0x55a>
			_llshift(fract);
4003118a:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
			exp--;
40031190:	4b                   	dec    %ebx
	while (exp > 0) {
		_ldiv5(fract);
		exp--;
		decexp++;
		while (fract[1] <= (MAXFP1 / 2)) {
			_llshift(fract);
40031191:	e8 89 f8 ff ff       	call   40030a1f <_llshift>
40031196:	eb e9                	jmp    40031181 <_prf+0x570>
			exp--;
		}
	}

	while (exp < (0 + 4)) {
		_rlrshift(fract);
40031198:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
		exp++;
4003119e:	43                   	inc    %ebx
			exp--;
		}
	}

	while (exp < (0 + 4)) {
		_rlrshift(fract);
4003119f:	e8 d2 f8 ff ff       	call   40030a76 <_rlrshift>
			_llshift(fract);
			exp--;
		}
	}

	while (exp < (0 + 4)) {
400311a4:	83 fb 04             	cmp    $0x4,%ebx
400311a7:	75 ef                	jne    40031198 <_prf+0x587>
		_rlrshift(fract);
		exp++;
	}

	if (precision < 0)
400311a9:	83 bd 10 ff ff ff 00 	cmpl   $0x0,-0xf0(%ebp)
400311b0:	79 0a                	jns    400311bc <_prf+0x5ab>
		precision = 6;		/* Default precision if none given */
400311b2:	c7 85 10 ff ff ff 06 	movl   $0x6,-0xf0(%ebp)
400311b9:	00 00 00 
	prune_zero = false;		/* Assume trailing 0's allowed     */
	if ((c == 'g') || (c == 'G')) {
400311bc:	89 f0                	mov    %esi,%eax
400311be:	83 e0 df             	and    $0xffffffdf,%eax
400311c1:	83 f8 47             	cmp    $0x47,%eax
400311c4:	75 46                	jne    4003120c <_prf+0x5fb>
		exp++;
	}

	if (precision < 0)
		precision = 6;		/* Default precision if none given */
	prune_zero = false;		/* Assume trailing 0's allowed     */
400311c6:	8b 95 fc fe ff ff    	mov    -0x104(%ebp),%edx
400311cc:	83 f2 01             	xor    $0x1,%edx
400311cf:	83 bd 10 ff ff ff 00 	cmpl   $0x0,-0xf0(%ebp)
400311d6:	0f 9f c0             	setg   %al
400311d9:	21 c2                	and    %eax,%edx
400311db:	89 95 e4 fe ff ff    	mov    %edx,-0x11c(%ebp)
	if ((c == 'g') || (c == 'G')) {
		if (!falt && (precision > 0))
			prune_zero = true;
		if ((decexp < (-4 + 1)) || (decexp > (precision + 1))) {
400311e1:	83 bd 08 ff ff ff fd 	cmpl   $0xfffffffd,-0xf8(%ebp)
400311e8:	7c 0f                	jl     400311f9 <_prf+0x5e8>
400311ea:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
400311f0:	40                   	inc    %eax
400311f1:	39 85 08 ff ff ff    	cmp    %eax,-0xf8(%ebp)
400311f7:	7e 22                	jle    4003121b <_prf+0x60a>
			if (c == 'g')
				c = 'e';
			else
				c = 'E';
400311f9:	31 c0                	xor    %eax,%eax
400311fb:	83 fe 67             	cmp    $0x67,%esi
400311fe:	0f 94 c0             	sete   %al
40031201:	89 c6                	mov    %eax,%esi
40031203:	4e                   	dec    %esi
40031204:	83 e6 e0             	and    $0xffffffe0,%esi
40031207:	83 c6 65             	add    $0x65,%esi
4003120a:	eb 26                	jmp    40031232 <_prf+0x621>
		exp++;
	}

	if (precision < 0)
		precision = 6;		/* Default precision if none given */
	prune_zero = false;		/* Assume trailing 0's allowed     */
4003120c:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%ebp)
40031213:	00 00 00 
				c = 'E';
		} else
			c = 'f';
	}

	if (c == 'f') {
40031216:	83 fe 66             	cmp    $0x66,%esi
40031219:	75 17                	jne    40031232 <_prf+0x621>
4003121b:	8b 9d 08 ff ff ff    	mov    -0xf8(%ebp),%ebx
40031221:	03 9d 10 ff ff ff    	add    -0xf0(%ebp),%ebx
40031227:	79 02                	jns    4003122b <_prf+0x61a>
40031229:	31 db                	xor    %ebx,%ebx
		exp = precision + decexp;
4003122b:	be 66 00 00 00       	mov    $0x66,%esi
40031230:	eb 09                	jmp    4003123b <_prf+0x62a>
		if (exp < 0)
			exp = 0;
	} else
		exp = precision + 1;
40031232:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
40031238:	8d 58 01             	lea    0x1(%eax),%ebx
	if (full) {
		digit_count = 16;
4003123b:	c7 85 14 ff ff ff 10 	movl   $0x10,-0xec(%ebp)
40031242:	00 00 00 
40031245:	83 fb 10             	cmp    $0x10,%ebx
40031248:	7e 05                	jle    4003124f <_prf+0x63e>
4003124a:	bb 10 00 00 00       	mov    $0x10,%ebx
		digit_count = 8;
		if (exp > 8)
			exp = 8;
	}

	ltemp[0] = 0;
4003124f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
40031256:	00 00 00 
	ltemp[1] = 0x08000000;
40031259:	c7 85 24 ff ff ff 00 	movl   $0x8000000,-0xdc(%ebp)
40031260:	00 00 08 
	while (exp--) {
40031263:	4b                   	dec    %ebx
40031264:	83 fb ff             	cmp    $0xffffffff,%ebx
40031267:	74 18                	je     40031281 <_prf+0x670>
		_ldiv5(ltemp);
40031269:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
4003126f:	e8 95 f8 ff ff       	call   40030b09 <_ldiv5>
		_rlrshift(ltemp);
40031274:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
4003127a:	e8 f7 f7 ff ff       	call   40030a76 <_rlrshift>
4003127f:	eb e2                	jmp    40031263 <_prf+0x652>
	}

	_ladd(fract, ltemp);
40031281:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
40031287:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
4003128d:	e8 ab f7 ff ff       	call   40030a3d <_ladd>
	if (fract[1] & 0xF0000000) {
40031292:	f7 85 1c ff ff ff 00 	testl  $0xf0000000,-0xe4(%ebp)
40031299:	00 00 f0 
4003129c:	74 1c                	je     400312ba <_prf+0x6a9>
		_ldiv5(fract);
4003129e:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
400312a4:	e8 60 f8 ff ff       	call   40030b09 <_ldiv5>
		_rlrshift(fract);
400312a9:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
400312af:	e8 c2 f7 ff ff       	call   40030a76 <_rlrshift>
		decexp++;
400312b4:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
	}

	if (c == 'f') {
400312ba:	83 fe 66             	cmp    $0x66,%esi
400312bd:	0f 85 ab 00 00 00    	jne    4003136e <_prf+0x75d>
		if (decexp > 0) {
400312c3:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
400312ca:	7e 2d                	jle    400312f9 <_prf+0x6e8>
400312cc:	8b 9d 08 ff ff ff    	mov    -0xf8(%ebp),%ebx
400312d2:	01 fb                	add    %edi,%ebx
			while (decexp > 0) {
				*buf++ = _get_digit(fract, &digit_count);
400312d4:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
400312da:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
400312e0:	e8 c9 f7 ff ff       	call   40030aae <_get_digit>
400312e5:	47                   	inc    %edi
		decexp++;
	}

	if (c == 'f') {
		if (decexp > 0) {
			while (decexp > 0) {
400312e6:	39 fb                	cmp    %edi,%ebx
				*buf++ = _get_digit(fract, &digit_count);
400312e8:	88 47 ff             	mov    %al,-0x1(%edi)
		decexp++;
	}

	if (c == 'f') {
		if (decexp > 0) {
			while (decexp > 0) {
400312eb:	75 e7                	jne    400312d4 <_prf+0x6c3>
400312ed:	c7 85 08 ff ff ff 00 	movl   $0x0,-0xf8(%ebp)
400312f4:	00 00 00 
400312f7:	eb 06                	jmp    400312ff <_prf+0x6ee>
				*buf++ = _get_digit(fract, &digit_count);
				decexp--;
			}
		} else
			*buf++ = '0';
400312f9:	8d 5f 01             	lea    0x1(%edi),%ebx
400312fc:	c6 07 30             	movb   $0x30,(%edi)
		if (falt || (precision > 0))
400312ff:	83 bd 10 ff ff ff 00 	cmpl   $0x0,-0xf0(%ebp)
40031306:	7f 0d                	jg     40031315 <_prf+0x704>
40031308:	83 bd fc fe ff ff 00 	cmpl   $0x0,-0x104(%ebp)
4003130f:	0f 84 88 04 00 00    	je     4003179d <_prf+0xb8c>
			*buf++ = '.';
40031315:	c6 03 2e             	movb   $0x2e,(%ebx)
40031318:	8d 7b 02             	lea    0x2(%ebx),%edi
4003131b:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
		while (precision-- > 0) {
40031321:	49                   	dec    %ecx
40031322:	83 f9 ff             	cmp    $0xffffffff,%ecx
40031325:	74 38                	je     4003135f <_prf+0x74e>
			if (decexp < 0) {
40031327:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
4003132e:	74 0c                	je     4003133c <_prf+0x72b>
				*buf++ = '0';
40031330:	c6 47 ff 30          	movb   $0x30,-0x1(%edi)
				decexp++;
40031334:	ff 85 08 ff ff ff    	incl   -0xf8(%ebp)
4003133a:	eb 20                	jmp    4003135c <_prf+0x74b>
			} else
				*buf++ = _get_digit(fract, &digit_count);
4003133c:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
40031342:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
40031348:	89 8d fc fe ff ff    	mov    %ecx,-0x104(%ebp)
4003134e:	e8 5b f7 ff ff       	call   40030aae <_get_digit>
40031353:	8b 8d fc fe ff ff    	mov    -0x104(%ebp),%ecx
40031359:	88 47 ff             	mov    %al,-0x1(%edi)
4003135c:	47                   	inc    %edi
4003135d:	eb c2                	jmp    40031321 <_prf+0x710>
4003135f:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
40031365:	8d 5c 03 01          	lea    0x1(%ebx,%eax,1),%ebx
40031369:	e9 2f 04 00 00       	jmp    4003179d <_prf+0xb8c>
		}
	} else {
		*buf = _get_digit(fract, &digit_count);
4003136e:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
40031374:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
4003137a:	e8 2f f7 ff ff       	call   40030aae <_get_digit>
		if (*buf++ != '0')
			decexp--;
4003137f:	3c 30                	cmp    $0x30,%al
				decexp++;
			} else
				*buf++ = _get_digit(fract, &digit_count);
		}
	} else {
		*buf = _get_digit(fract, &digit_count);
40031381:	88 07                	mov    %al,(%edi)
		if (*buf++ != '0')
			decexp--;
40031383:	0f 95 c0             	setne  %al
40031386:	0f b6 c0             	movzbl %al,%eax
40031389:	29 85 08 ff ff ff    	sub    %eax,-0xf8(%ebp)
		if (falt || (precision > 0))
4003138f:	83 bd 10 ff ff ff 00 	cmpl   $0x0,-0xf0(%ebp)
40031396:	7f 0c                	jg     400313a4 <_prf+0x793>
			} else
				*buf++ = _get_digit(fract, &digit_count);
		}
	} else {
		*buf = _get_digit(fract, &digit_count);
		if (*buf++ != '0')
40031398:	8d 5f 01             	lea    0x1(%edi),%ebx
			decexp--;
		if (falt || (precision > 0))
4003139b:	83 bd fc fe ff ff 00 	cmpl   $0x0,-0x104(%ebp)
400313a2:	74 36                	je     400313da <_prf+0x7c9>
			*buf++ = '.';
400313a4:	8d 4f 02             	lea    0x2(%edi),%ecx
400313a7:	8b 9d 10 ff ff ff    	mov    -0xf0(%ebp),%ebx
400313ad:	c6 47 01 2e          	movb   $0x2e,0x1(%edi)
400313b1:	01 cb                	add    %ecx,%ebx
		while (precision-- > 0)
400313b3:	39 cb                	cmp    %ecx,%ebx
400313b5:	74 23                	je     400313da <_prf+0x7c9>
			*buf++ = _get_digit(fract, &digit_count);
400313b7:	41                   	inc    %ecx
400313b8:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
400313be:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
400313c4:	89 8d 10 ff ff ff    	mov    %ecx,-0xf0(%ebp)
400313ca:	e8 df f6 ff ff       	call   40030aae <_get_digit>
400313cf:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
400313d5:	88 41 ff             	mov    %al,-0x1(%ecx)
400313d8:	eb d9                	jmp    400313b3 <_prf+0x7a2>
	}

	if (prune_zero) {
400313da:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
400313e1:	74 11                	je     400313f4 <_prf+0x7e3>
		while (*--buf == '0')
400313e3:	89 d8                	mov    %ebx,%eax
400313e5:	4b                   	dec    %ebx
400313e6:	8a 13                	mov    (%ebx),%dl
400313e8:	80 fa 30             	cmp    $0x30,%dl
400313eb:	74 f6                	je     400313e3 <_prf+0x7d2>
			;
		if (*buf != '.')
400313ed:	80 fa 2e             	cmp    $0x2e,%dl
400313f0:	74 02                	je     400313f4 <_prf+0x7e3>
400313f2:	89 c3                	mov    %eax,%ebx
			buf++;
	}

	if ((c == 'e') || (c == 'E')) {
400313f4:	89 f0                	mov    %esi,%eax
400313f6:	83 e0 df             	and    $0xffffffdf,%eax
400313f9:	83 f8 45             	cmp    $0x45,%eax
400313fc:	75 4c                	jne    4003144a <_prf+0x839>
		*buf++ = (char) c;
400313fe:	89 f0                	mov    %esi,%eax
40031400:	8d 4b 02             	lea    0x2(%ebx),%ecx
40031403:	88 03                	mov    %al,(%ebx)
		if (decexp < 0) {
40031405:	83 bd 08 ff ff ff 00 	cmpl   $0x0,-0xf8(%ebp)
4003140c:	79 0c                	jns    4003141a <_prf+0x809>
			decexp = -decexp;
4003140e:	f7 9d 08 ff ff ff    	negl   -0xf8(%ebp)
			*buf++ = '-';
40031414:	c6 43 01 2d          	movb   $0x2d,0x1(%ebx)
40031418:	eb 04                	jmp    4003141e <_prf+0x80d>
		} else
			*buf++ = '+';
4003141a:	c6 43 01 2b          	movb   $0x2b,0x1(%ebx)
		*buf++ = (char) ((decexp / 100) + '0');
4003141e:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
40031424:	bf 64 00 00 00       	mov    $0x64,%edi
40031429:	99                   	cltd   
4003142a:	f7 ff                	idiv   %edi
4003142c:	83 c0 30             	add    $0x30,%eax
		decexp %= 100;
		*buf++ = (char) ((decexp / 10) + '0');
4003142f:	bb 0a 00 00 00       	mov    $0xa,%ebx
		if (decexp < 0) {
			decexp = -decexp;
			*buf++ = '-';
		} else
			*buf++ = '+';
		*buf++ = (char) ((decexp / 100) + '0');
40031434:	88 01                	mov    %al,(%ecx)
		decexp %= 100;
		*buf++ = (char) ((decexp / 10) + '0');
40031436:	89 d0                	mov    %edx,%eax
40031438:	99                   	cltd   
40031439:	f7 fb                	idiv   %ebx
4003143b:	83 c0 30             	add    $0x30,%eax
		decexp %= 10;
		*buf++ = (char) (decexp + '0');
4003143e:	83 c2 30             	add    $0x30,%edx
			*buf++ = '-';
		} else
			*buf++ = '+';
		*buf++ = (char) ((decexp / 100) + '0');
		decexp %= 100;
		*buf++ = (char) ((decexp / 10) + '0');
40031441:	88 41 01             	mov    %al,0x1(%ecx)
		decexp %= 10;
		*buf++ = (char) (decexp + '0');
40031444:	8d 59 03             	lea    0x3(%ecx),%ebx
40031447:	88 51 02             	mov    %dl,0x2(%ecx)
	}
	*buf = 0;
4003144a:	c6 03 00             	movb   $0x0,(%ebx)

	return buf - start;
4003144d:	89 d8                	mov    %ebx,%eax
4003144f:	8d bd 2b ff ff ff    	lea    -0xd5(%ebp),%edi
			}

				c = _to_float(buf, double_temp, DOUBLE, c, falt, fplus,
								fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
					prefix = 1;
40031455:	be 01 00 00 00       	mov    $0x1,%esi
		decexp %= 10;
		*buf++ = (char) (decexp + '0');
	}
	*buf = 0;

	return buf - start;
4003145a:	29 f8                	sub    %edi,%eax
#endif
			}

				c = _to_float(buf, double_temp, DOUBLE, c, falt, fplus,
								fspace, precision);
				if (fplus || fspace || (buf[0] == '-'))
4003145c:	8b bd f0 fe ff ff    	mov    -0x110(%ebp),%edi
40031462:	0b bd ec fe ff ff    	or     -0x114(%ebp),%edi
40031468:	0f 85 25 02 00 00    	jne    40031693 <_prf+0xa82>
					break;
				}
			}

			need_justifying = false;
			prefix = 0;
4003146e:	31 d2                	xor    %edx,%edx
40031470:	80 bd 2b ff ff ff 2d 	cmpb   $0x2d,-0xd5(%ebp)
40031477:	0f 94 c2             	sete   %dl
4003147a:	89 d6                	mov    %edx,%esi
4003147c:	e9 12 02 00 00       	jmp    40031693 <_prf+0xa82>
			switch (c) {
40031481:	80 fb 70             	cmp    $0x70,%bl
40031484:	0f 84 b1 00 00 00    	je     4003153b <_prf+0x92a>
4003148a:	0f 8f d1 00 00 00    	jg     40031561 <_prf+0x950>
40031490:	80 fb 6e             	cmp    $0x6e,%bl
40031493:	75 12                	jne    400314a7 <_prf+0x896>
				need_justifying = true;
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
40031495:	8b 07                	mov    (%edi),%eax
					prefix = 1;
				need_justifying = true;
				break;

			case 'n':
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
40031497:	8d 77 04             	lea    0x4(%edi),%esi
				*int32ptr_temp = count;
4003149a:	8b bd 00 ff ff ff    	mov    -0x100(%ebp),%edi
400314a0:	89 38                	mov    %edi,(%eax)
				break;
400314a2:	e9 08 03 00 00       	jmp    400317af <_prf+0xb9e>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
400314a7:	0f 8e 18 03 00 00    	jle    400317c5 <_prf+0xbb4>
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
400314ad:	8d 47 04             	lea    0x4(%edi),%eax

#if (MAXFLD < 10)
  #error buffer size MAXFLD is too small
#endif

	if (precision < 0)
400314b0:	8b 9d 10 ff ff ff    	mov    -0xf0(%ebp),%ebx
				int32ptr_temp = (int32_t *)va_arg(vargs, int32_t *);
				*int32ptr_temp = count;
				break;

			case 'o':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
400314b6:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
400314bc:	8b 3f                	mov    (%edi),%edi

#if (MAXFLD < 10)
  #error buffer size MAXFLD is too small
#endif

	if (precision < 0)
400314be:	85 db                	test   %ebx,%ebx
400314c0:	79 05                	jns    400314c7 <_prf+0x8b6>
		precision = 1;
400314c2:	bb 01 00 00 00       	mov    $0x1,%ebx
	*buf = '\0';
400314c7:	c6 85 2b ff ff ff 00 	movb   $0x0,-0xd5(%ebp)
400314ce:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
	for (i = 10; i >= 0; i--) {
400314d4:	ba 0a 00 00 00       	mov    $0xa,%edx
		temp = (value >> (i * 3));
400314d9:	8d 0c 52             	lea    (%edx,%edx,2),%ecx
400314dc:	89 fe                	mov    %edi,%esi
400314de:	d3 ee                	shr    %cl,%esi
400314e0:	89 f1                	mov    %esi,%ecx
		if (i == 10)
			temp &= 0x3;
		else
			temp &= 0x7;
400314e2:	83 e6 07             	and    $0x7,%esi
	if (precision < 0)
		precision = 1;
	*buf = '\0';
	for (i = 10; i >= 0; i--) {
		temp = (value >> (i * 3));
		if (i == 10)
400314e5:	83 fa 0a             	cmp    $0xa,%edx
400314e8:	75 05                	jne    400314ef <_prf+0x8de>
			temp &= 0x3;
400314ea:	83 e1 03             	and    $0x3,%ecx
400314ed:	89 ce                	mov    %ecx,%esi
		else
			temp &= 0x7;
		if ((precision > i) || (temp != 0)) {
400314ef:	85 f6                	test   %esi,%esi
400314f1:	0f 95 c1             	setne  %cl
400314f4:	39 d3                	cmp    %edx,%ebx
400314f6:	7f 04                	jg     400314fc <_prf+0x8eb>
400314f8:	84 c9                	test   %cl,%cl
400314fa:	74 23                	je     4003151f <_prf+0x90e>
			precision = i;
			if ((temp != 0) && alt_form)
400314fc:	83 bd fc fe ff ff 00 	cmpl   $0x0,-0x104(%ebp)
40031503:	74 08                	je     4003150d <_prf+0x8fc>
40031505:	84 c9                	test   %cl,%cl
40031507:	74 04                	je     4003150d <_prf+0x8fc>
				*buf++ = '0';
40031509:	c6 00 30             	movb   $0x30,(%eax)
4003150c:	40                   	inc    %eax
			alt_form = false;
			*buf++ = (char) (temp + '0');
4003150d:	8d 4e 30             	lea    0x30(%esi),%ecx
40031510:	89 d3                	mov    %edx,%ebx
40031512:	88 08                	mov    %cl,(%eax)
			temp &= 0x7;
		if ((precision > i) || (temp != 0)) {
			precision = i;
			if ((temp != 0) && alt_form)
				*buf++ = '0';
			alt_form = false;
40031514:	c7 85 fc fe ff ff 00 	movl   $0x0,-0x104(%ebp)
4003151b:	00 00 00 
			*buf++ = (char) (temp + '0');
4003151e:	40                   	inc    %eax
#endif

	if (precision < 0)
		precision = 1;
	*buf = '\0';
	for (i = 10; i >= 0; i--) {
4003151f:	4a                   	dec    %edx
40031520:	83 fa ff             	cmp    $0xffffffff,%edx
40031523:	75 b4                	jne    400314d9 <_prf+0x8c8>
			*buf++ = (char) (temp + '0');
		}
	}
	*buf = 0;

	return buf - start;
40031525:	8d bd 2b ff ff ff    	lea    -0xd5(%ebp),%edi
				*buf++ = '0';
			alt_form = false;
			*buf++ = (char) (temp + '0');
		}
	}
	*buf = 0;
4003152b:	c6 00 00             	movb   $0x0,(%eax)

	return buf - start;
4003152e:	29 f8                	sub    %edi,%eax
40031530:	e9 b6 00 00 00       	jmp    400315eb <_prf+0x9da>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
40031535:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
4003153b:	6a 78                	push   $0x78
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
4003153d:	8d 47 04             	lea    0x4(%edi),%eax
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
40031540:	6a 08                	push   $0x8
				if (precision != -1)
					pad = ' ';
				break;

			case 'p':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
40031542:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
				c = _to_hex(buf, uint32_temp, true, 8, (int) 'x');
40031548:	b9 01 00 00 00       	mov    $0x1,%ecx
4003154d:	8b 17                	mov    (%edi),%edx
4003154f:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
40031555:	e8 dc f3 ff ff       	call   40030936 <_to_hex>
4003155a:	5b                   	pop    %ebx
4003155b:	5e                   	pop    %esi
4003155c:	e9 8a 00 00 00       	jmp    400315eb <_prf+0x9da>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
40031561:	80 fb 75             	cmp    $0x75,%bl
40031564:	74 69                	je     400315cf <_prf+0x9be>
40031566:	80 fb 78             	cmp    $0x78,%bl
40031569:	0f 84 af 00 00 00    	je     4003161e <_prf+0xa0d>
4003156f:	80 fb 73             	cmp    $0x73,%bl
40031572:	0f 85 79 01 00 00    	jne    400316f1 <_prf+0xae0>
				if (precision != -1)
					pad = ' ';
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
40031578:	8d 77 04             	lea    0x4(%edi),%esi
4003157b:	8b 17                	mov    (%edi),%edx
				/* Get the string length */
				for (c = 0; c < MAXFLD; c++) {
4003157d:	31 c0                	xor    %eax,%eax
					if (cptr_temp[c] == '\0') {
4003157f:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
40031583:	74 08                	je     4003158d <_prf+0x97c>
				break;

			case 's':
				cptr_temp = (char *) va_arg(vargs, char *);
				/* Get the string length */
				for (c = 0; c < MAXFLD; c++) {
40031585:	40                   	inc    %eax
40031586:	3d c8 00 00 00       	cmp    $0xc8,%eax
4003158b:	75 f2                	jne    4003157f <_prf+0x96e>
					if (cptr_temp[c] == '\0') {
						break;
					}
				}
				if ((precision >= 0) && (precision < c))
4003158d:	8b bd 10 ff ff ff    	mov    -0xf0(%ebp),%edi
40031593:	83 ef 00             	sub    $0x0,%edi
40031596:	78 08                	js     400315a0 <_prf+0x98f>
40031598:	39 85 10 ff ff ff    	cmp    %eax,-0xf0(%ebp)
4003159e:	7c 06                	jl     400315a6 <_prf+0x995>
400315a0:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%ebp)
					c = precision;
				if (c > 0) {
400315a6:	83 bd 10 ff ff ff 00 	cmpl   $0x0,-0xf0(%ebp)
400315ad:	0f 84 fc 01 00 00    	je     400317af <_prf+0xb9e>
					memcpy(buf, cptr_temp, (size_t) c);
400315b3:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
400315b9:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
400315bf:	e8 a7 02 00 00       	call   4003186b <memcpy>
400315c4:	e9 ed 01 00 00       	jmp    400317b6 <_prf+0xba5>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
400315c9:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
					need_justifying = true;
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
400315cf:	8d 47 04             	lea    0x4(%edi),%eax
				c = _to_udec(buf, uint32_temp, precision);
400315d2:	8b 8d 10 ff ff ff    	mov    -0xf0(%ebp),%ecx
					need_justifying = true;
				}
				break;

			case 'u':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
400315d8:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
				c = _to_udec(buf, uint32_temp, precision);
400315de:	8b 17                	mov    (%edi),%edx
400315e0:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
400315e6:	e8 d3 f3 ff ff       	call   400309be <_to_udec>
					break;
				}
			}

			need_justifying = false;
			prefix = 0;
400315eb:	31 f6                	xor    %esi,%esi
400315ed:	eb 65                	jmp    40031654 <_prf+0xa43>
			switch (c) {
400315ef:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
400315f5:	eb 2d                	jmp    40031624 <_prf+0xa13>
400315f7:	80 fb 47             	cmp    $0x47,%bl
400315fa:	0f 84 f5 f9 ff ff    	je     40030ff5 <_prf+0x3e4>
40031600:	0f 8e f6 00 00 00    	jle    400316fc <_prf+0xaeb>
40031606:	80 fb 63             	cmp    $0x63,%bl
40031609:	0f 84 1b f9 ff ff    	je     40030f2a <_prf+0x319>
4003160f:	0f 8f 3c f9 ff ff    	jg     40030f51 <_prf+0x340>
40031615:	80 fb 58             	cmp    $0x58,%bl
40031618:	0f 85 d3 00 00 00    	jne    400316f1 <_prf+0xae0>
4003161e:	8b b5 08 ff ff ff    	mov    -0xf8(%ebp),%esi
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
40031624:	56                   	push   %esi
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
40031625:	8d 47 04             	lea    0x4(%edi),%eax
				c = _to_hex(buf, uint32_temp, falt, precision, c);
40031628:	ff b5 10 ff ff ff    	pushl  -0xf0(%ebp)
					pad = ' ';
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
4003162e:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
				c = _to_hex(buf, uint32_temp, falt, precision, c);
40031634:	8b 8d fc fe ff ff    	mov    -0x104(%ebp),%ecx
4003163a:	8b 17                	mov    (%edi),%edx
4003163c:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
40031642:	e8 ef f2 ff ff       	call   40030936 <_to_hex>
				if (falt)
					prefix = 2;
40031647:	8b b5 fc fe ff ff    	mov    -0x104(%ebp),%esi
4003164d:	f7 de                	neg    %esi
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
4003164f:	5a                   	pop    %edx
				if (falt)
					prefix = 2;
40031650:	83 e6 02             	and    $0x2,%esi
				break;

			case 'x':
			case 'X':
				uint32_temp = (uint32_t) va_arg(vargs, uint32_t);
				c = _to_hex(buf, uint32_temp, falt, precision, c);
40031653:	59                   	pop    %ecx
				if (falt)
					prefix = 2;
				need_justifying = true;
				if (precision != -1)
40031654:	83 bd 10 ff ff ff ff 	cmpl   $0xffffffff,-0xf0(%ebp)
4003165b:	74 36                	je     40031693 <_prf+0xa82>
					pad = ' ';
4003165d:	c6 85 fb fe ff ff 20 	movb   $0x20,-0x105(%ebp)
40031664:	eb 2d                	jmp    40031693 <_prf+0xa82>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
40031666:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
				if (precision != -1)
					pad = ' ';
				break;

			case '%':
				if ((*func)('%', dest) == EOF) {
4003166c:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
40031672:	b8 25 00 00 00       	mov    $0x25,%eax
40031677:	8b 8d e0 fe ff ff    	mov    -0x120(%ebp),%ecx
4003167d:	ff d1                	call   *%ecx
4003167f:	40                   	inc    %eax
40031680:	0f 84 0b f6 ff ff    	je     40030c91 <_prf+0x80>
					return EOF;
				}

				count++;
40031686:	ff 85 00 ff ff ff    	incl   -0x100(%ebp)
				break;
4003168c:	89 fe                	mov    %edi,%esi
4003168e:	e9 1c 01 00 00       	jmp    400317af <_prf+0xb9e>

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1)
40031693:	3d c8 00 00 00       	cmp    $0xc8,%eax
40031698:	0f 8f f3 f5 ff ff    	jg     40030c91 <_prf+0x80>
4003169e:	8b bd f4 fe ff ff    	mov    -0x10c(%ebp),%edi
				return EOF;

			if (need_justifying) {
				if (c < width) {
400316a4:	39 85 04 ff ff ff    	cmp    %eax,-0xfc(%ebp)
400316aa:	7e 71                	jle    4003171d <_prf+0xb0c>
					if (fminus)	{
400316ac:	83 bd e8 fe ff ff 00 	cmpl   $0x0,-0x118(%ebp)
400316b3:	74 70                	je     40031725 <_prf+0xb14>
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
400316b5:	c6 84 28 2b ff ff ff 	movb   $0x20,-0xd5(%eax,%ebp,1)
400316bc:	20 

			if (need_justifying) {
				if (c < width) {
					if (fminus)	{
						/* Left justify? */
						for (i = c; i < width; i++)
400316bd:	40                   	inc    %eax
400316be:	39 85 04 ff ff ff    	cmp    %eax,-0xfc(%ebp)
400316c4:	75 ef                	jne    400316b5 <_prf+0xaa4>
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
						if (pad == ' ')
							prefix = 0;
400316c6:	8d b5 2b ff ff ff    	lea    -0xd5(%ebp),%esi
400316cc:	8b 9d 00 ff ff ff    	mov    -0x100(%ebp),%ebx
400316d2:	29 f3                	sub    %esi,%ebx
400316d4:	8b 95 04 ff ff ff    	mov    -0xfc(%ebp),%edx
400316da:	8d 8d 2b ff ff ff    	lea    -0xd5(%ebp),%ecx
400316e0:	29 f2                	sub    %esi,%edx
400316e2:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
400316e5:	01 ca                	add    %ecx,%edx
							buf[i] = pad;
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
400316e7:	85 d2                	test   %edx,%edx
400316e9:	7f 7d                	jg     40031768 <_prf+0xb57>
400316eb:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1)
400316f1:	8b 8d 0c ff ff ff    	mov    -0xf4(%ebp),%ecx
400316f7:	e9 3a f5 ff ff       	jmp    40030c36 <_prf+0x25>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
400316fc:	80 fb 25             	cmp    $0x25,%bl
400316ff:	0f 84 67 ff ff ff    	je     4003166c <_prf+0xa5b>
40031705:	80 fb 45             	cmp    $0x45,%bl
40031708:	0f 84 e7 f8 ff ff    	je     40030ff5 <_prf+0x3e4>
4003170e:	84 db                	test   %bl,%bl
40031710:	75 df                	jne    400316f1 <_prf+0xae0>
			fminus = fplus = fspace = falt = false;
			pad = ' ';		/* Default pad character    */
			precision = -1;	/* No precision specified   */

			while (strchr("-+ #0", (c = *format++)) != NULL) {
				switch (c) {
40031712:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
40031718:	e9 b6 00 00 00       	jmp    400317d3 <_prf+0xbc2>
4003171d:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%ebp)
40031723:	eb a1                	jmp    400316c6 <_prf+0xab5>
						/* Left justify? */
						for (i = c; i < width; i++)
							buf[i] = ' ';
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
40031725:	8b 9d 04 ff ff ff    	mov    -0xfc(%ebp),%ebx
4003172b:	8d 48 01             	lea    0x1(%eax),%ecx
4003172e:	29 c3                	sub    %eax,%ebx
40031730:	8d 85 2b ff ff ff    	lea    -0xd5(%ebp),%eax
40031736:	01 d8                	add    %ebx,%eax
40031738:	8d 95 2b ff ff ff    	lea    -0xd5(%ebp),%edx
4003173e:	e8 f7 00 00 00       	call   4003183a <memmove>
										+ 1));
						if (pad == ' ')
40031743:	80 bd fb fe ff ff 20 	cmpb   $0x20,-0x105(%ebp)
4003174a:	75 02                	jne    4003174e <_prf+0xb3d>
							prefix = 0;
4003174c:	31 f6                	xor    %esi,%esi
						c = width - c + prefix;
4003174e:	01 f3                	add    %esi,%ebx
						for (i = prefix; i < c; i++)
40031750:	39 de                	cmp    %ebx,%esi
40031752:	0f 8d 6e ff ff ff    	jge    400316c6 <_prf+0xab5>
							buf[i] = pad;
40031758:	8a 85 fb fe ff ff    	mov    -0x105(%ebp),%al
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
						if (pad == ' ')
							prefix = 0;
						c = width - c + prefix;
						for (i = prefix; i < c; i++)
4003175e:	46                   	inc    %esi
							buf[i] = pad;
4003175f:	88 84 2e 2a ff ff ff 	mov    %al,-0xd6(%esi,%ebp,1)
40031766:	eb e8                	jmp    40031750 <_prf+0xb3f>
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
					if ((*func)(*cptr, dest) == EOF)
40031768:	0f be 06             	movsbl (%esi),%eax
4003176b:	8b 95 dc fe ff ff    	mov    -0x124(%ebp),%edx
40031771:	8b 8d e0 fe ff ff    	mov    -0x120(%ebp),%ecx
40031777:	ff d1                	call   *%ecx
40031779:	40                   	inc    %eax
4003177a:	0f 84 11 f5 ff ff    	je     40030c91 <_prf+0x80>
							buf[i] = pad;
					}
					c = width;
				}

				for (cptr = buf; c > 0; c--, cptr++, count++) {
40031780:	46                   	inc    %esi
40031781:	e9 4e ff ff ff       	jmp    400316d4 <_prf+0xac3>

			case 0:
				return count;
			}

			if (c >= MAXFLD + 1)
40031786:	81 fe c8 00 00 00    	cmp    $0xc8,%esi
4003178c:	0f 8f ff f4 ff ff    	jg     40030c91 <_prf+0x80>
40031792:	89 8d 0c ff ff ff    	mov    %ecx,-0xf4(%ebp)
40031798:	e9 54 ff ff ff       	jmp    400316f1 <_prf+0xae0>
			*buf++ = '.';
		while (precision-- > 0)
			*buf++ = _get_digit(fract, &digit_count);
	}

	if (prune_zero) {
4003179d:	83 bd e4 fe ff ff 00 	cmpl   $0x0,-0x11c(%ebp)
400317a4:	0f 85 39 fc ff ff    	jne    400313e3 <_prf+0x7d2>
400317aa:	e9 9b fc ff ff       	jmp    4003144a <_prf+0x839>
					} else {
						/* Right justify */
						(void) memmove((buf + (width - c)), buf, (size_t) (c
										+ 1));
						if (pad == ' ')
							prefix = 0;
400317af:	89 f7                	mov    %esi,%edi
400317b1:	e9 3b ff ff ff       	jmp    400316f1 <_prf+0xae0>
				}
			}

			need_justifying = false;
			prefix = 0;
			switch (c) {
400317b6:	89 f7                	mov    %esi,%edi
400317b8:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
400317be:	31 f6                	xor    %esi,%esi
400317c0:	e9 df fe ff ff       	jmp    400316a4 <_prf+0xa93>
400317c5:	80 fb 69             	cmp    $0x69,%bl
400317c8:	0f 84 83 f7 ff ff    	je     40030f51 <_prf+0x340>
400317ce:	e9 1e ff ff ff       	jmp    400316f1 <_prf+0xae0>
				}
			}
		}
	}
	return count;
}
400317d3:	8d 65 f4             	lea    -0xc(%ebp),%esp
400317d6:	5b                   	pop    %ebx
400317d7:	5e                   	pop    %esi
400317d8:	5f                   	pop    %edi
400317d9:	5d                   	pop    %ebp
400317da:	c3                   	ret    

400317db <_stdout_hook_default>:
 */

#include <stdio.h>

static int _stdout_hook_default(int c)
{
400317db:	55                   	push   %ebp
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
400317dc:	83 c8 ff             	or     $0xffffffff,%eax
 */

#include <stdio.h>

static int _stdout_hook_default(int c)
{
400317df:	89 e5                	mov    %esp,%ebp
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
400317e1:	5d                   	pop    %ebp
400317e2:	c3                   	ret    

400317e3 <fputc>:
{
	_stdout_hook = hook;
}

int fputc(int c, FILE *stream)
{
400317e3:	55                   	push   %ebp
	return (stdout == stream) ? _stdout_hook(c) : EOF;
400317e4:	83 fa 02             	cmp    $0x2,%edx
{
	_stdout_hook = hook;
}

int fputc(int c, FILE *stream)
{
400317e7:	89 e5                	mov    %esp,%ebp
	return (stdout == stream) ? _stdout_hook(c) : EOF;
400317e9:	75 07                	jne    400317f2 <fputc+0xf>
}
400317eb:	5d                   	pop    %ebp
	_stdout_hook = hook;
}

int fputc(int c, FILE *stream)
{
	return (stdout == stream) ? _stdout_hook(c) : EOF;
400317ec:	ff 25 40 64 00 a8    	jmp    *0xa8006440
}
400317f2:	83 c8 ff             	or     $0xffffffff,%eax
400317f5:	5d                   	pop    %ebp
400317f6:	c3                   	ret    

400317f7 <strchr>:
 *
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
400317f7:	55                   	push   %ebp
400317f8:	89 c1                	mov    %eax,%ecx
400317fa:	89 e5                	mov    %esp,%ebp
400317fc:	53                   	push   %ebx
	char tmp = (char) c;
400317fd:	88 d3                	mov    %dl,%bl

	while ((*s != tmp) && (*s != '\0'))
400317ff:	8a 01                	mov    (%ecx),%al
40031801:	38 c3                	cmp    %al,%bl
40031803:	74 0d                	je     40031812 <strchr+0x1b>
40031805:	84 c0                	test   %al,%al
40031807:	74 03                	je     4003180c <strchr+0x15>
		s++;
40031809:	41                   	inc    %ecx
4003180a:	eb f3                	jmp    400317ff <strchr+0x8>

	return (*s == tmp) ? (char *) s : NULL;
4003180c:	31 c0                	xor    %eax,%eax
4003180e:	84 d2                	test   %dl,%dl
40031810:	75 02                	jne    40031814 <strchr+0x1d>
40031812:	89 c8                	mov    %ecx,%eax
}
40031814:	5b                   	pop    %ebx
40031815:	5d                   	pop    %ebp
40031816:	c3                   	ret    

40031817 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
40031817:	55                   	push   %ebp
40031818:	89 e5                	mov    %esp,%ebp
4003181a:	56                   	push   %esi
	while ((*s1 == *s2) && (*s1 != '\0')) {
4003181b:	31 f6                	xor    %esi,%esi
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
4003181d:	53                   	push   %ebx
	while ((*s1 == *s2) && (*s1 != '\0')) {
4003181e:	0f be 1c 32          	movsbl (%edx,%esi,1),%ebx
40031822:	8a 0c 30             	mov    (%eax,%esi,1),%cl
40031825:	38 d9                	cmp    %bl,%cl
40031827:	75 08                	jne    40031831 <strcmp+0x1a>
40031829:	46                   	inc    %esi
4003182a:	84 c9                	test   %cl,%cl
4003182c:	75 f0                	jne    4003181e <strcmp+0x7>
4003182e:	0f be d9             	movsbl %cl,%ebx
		s1++;
		s2++;
	}

	return *s1 - *s2;
40031831:	0f be c1             	movsbl %cl,%eax
40031834:	29 d8                	sub    %ebx,%eax
}
40031836:	5b                   	pop    %ebx
40031837:	5e                   	pop    %esi
40031838:	5d                   	pop    %ebp
40031839:	c3                   	ret    

4003183a <memmove>:
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
4003183a:	55                   	push   %ebp
4003183b:	89 e5                	mov    %esp,%ebp
4003183d:	56                   	push   %esi
4003183e:	53                   	push   %ebx
	char *dest = d;
	const char *src  = s;

	if ((size_t) (d - s) < n) {
4003183f:	89 c3                	mov    %eax,%ebx
40031841:	29 d3                	sub    %edx,%ebx
 *
 * @return pointer to destination buffer <d>
 */

void *memmove(void *d, const void *s, size_t n)
{
40031843:	89 ce                	mov    %ecx,%esi
	char *dest = d;
	const char *src  = s;

	if ((size_t) (d - s) < n) {
40031845:	39 cb                	cmp    %ecx,%ebx
40031847:	72 04                	jb     4003184d <memmove+0x13>
40031849:	31 db                	xor    %ebx,%ebx
4003184b:	eb 0d                	jmp    4003185a <memmove+0x20>
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
			n--;
4003184d:	4e                   	dec    %esi
		/*
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
4003184e:	85 f6                	test   %esi,%esi
			n--;
			dest[n] = src[n];
40031850:	8a 1c 32             	mov    (%edx,%esi,1),%bl
40031853:	88 1c 30             	mov    %bl,(%eax,%esi,1)
		/*
		 * The <src> buffer overlaps with the start of the <dest> buffer.
		 * Copy backwards to prevent the premature corruption of <src>.
		 */

		while (n > 0) {
40031856:	75 f5                	jne    4003184d <memmove+0x13>
40031858:	eb 0d                	jmp    40031867 <memmove+0x2d>
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
4003185a:	39 de                	cmp    %ebx,%esi
4003185c:	74 09                	je     40031867 <memmove+0x2d>
			*dest = *src;
4003185e:	8a 0c 1a             	mov    (%edx,%ebx,1),%cl
40031861:	88 0c 18             	mov    %cl,(%eax,%ebx,1)
40031864:	43                   	inc    %ebx
40031865:	eb f3                	jmp    4003185a <memmove+0x20>
			n--;
		}
	}

	return d;
}
40031867:	5b                   	pop    %ebx
40031868:	5e                   	pop    %esi
40031869:	5d                   	pop    %ebp
4003186a:	c3                   	ret    

4003186b <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_Restrict d, const void *_Restrict s, size_t n)
{
4003186b:	55                   	push   %ebp
4003186c:	89 e5                	mov    %esp,%ebp
4003186e:	57                   	push   %edi
4003186f:	56                   	push   %esi
40031870:	53                   	push   %ebx
40031871:	53                   	push   %ebx
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
40031872:	89 c3                	mov    %eax,%ebx
40031874:	31 d3                	xor    %edx,%ebx
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_Restrict d, const void *_Restrict s, size_t n)
{
40031876:	89 45 f0             	mov    %eax,-0x10(%ebp)
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {
40031879:	80 e3 03             	and    $0x3,%bl
4003187c:	89 c3                	mov    %eax,%ebx
4003187e:	74 14                	je     40031894 <memcpy+0x29>

void *memcpy(void *_Restrict d, const void *_Restrict s, size_t n)
{
	/* attempt word-sized copying only if buffers have identical alignment */

	unsigned char *d_byte = (unsigned char *)d;
40031880:	8b 5d f0             	mov    -0x10(%ebp),%ebx
40031883:	31 f6                	xor    %esi,%esi
40031885:	eb 3b                	jmp    400318c2 <memcpy+0x57>
	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
40031887:	85 c9                	test   %ecx,%ecx
40031889:	74 44                	je     400318cf <memcpy+0x64>
				return d;
			}
			*(d_byte++) = *(s_byte++);
4003188b:	42                   	inc    %edx
4003188c:	43                   	inc    %ebx
4003188d:	8a 42 ff             	mov    -0x1(%edx),%al
			n--;
40031890:	49                   	dec    %ecx

		while (((unsigned int)d_byte) & 0x3) {
			if (n == 0) {
				return d;
			}
			*(d_byte++) = *(s_byte++);
40031891:	88 43 ff             	mov    %al,-0x1(%ebx)

	if ((((unsigned int)d ^ (unsigned int)s_byte) & 0x3) == 0) {

		/* do byte-sized copying until word-aligned or finished */

		while (((unsigned int)d_byte) & 0x3) {
40031894:	f6 c3 03             	test   $0x3,%bl
40031897:	75 ee                	jne    40031887 <memcpy+0x1c>
40031899:	31 f6                	xor    %esi,%esi
		/* do word-sized copying as long as possible */

		unsigned int *d_word = (unsigned int *)d_byte;
		const unsigned int *s_word = (const unsigned int *)s_byte;

		while (n >= sizeof(unsigned int)) {
4003189b:	89 cf                	mov    %ecx,%edi
4003189d:	29 f7                	sub    %esi,%edi
4003189f:	83 ff 03             	cmp    $0x3,%edi
400318a2:	76 0b                	jbe    400318af <memcpy+0x44>
			*(d_word++) = *(s_word++);
400318a4:	8b 3c 32             	mov    (%edx,%esi,1),%edi
400318a7:	89 3c 33             	mov    %edi,(%ebx,%esi,1)
400318aa:	83 c6 04             	add    $0x4,%esi
400318ad:	eb ec                	jmp    4003189b <memcpy+0x30>
400318af:	89 ce                	mov    %ecx,%esi
400318b1:	c1 ee 02             	shr    $0x2,%esi
400318b4:	6b fe fc             	imul   $0xfffffffc,%esi,%edi
400318b7:	c1 e6 02             	shl    $0x2,%esi
400318ba:	01 f9                	add    %edi,%ecx
400318bc:	01 f3                	add    %esi,%ebx
400318be:	01 f2                	add    %esi,%edx
400318c0:	eb c1                	jmp    40031883 <memcpy+0x18>
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
400318c2:	39 f1                	cmp    %esi,%ecx
400318c4:	74 09                	je     400318cf <memcpy+0x64>
		*(d_byte++) = *(s_byte++);
400318c6:	8a 04 32             	mov    (%edx,%esi,1),%al
400318c9:	88 04 33             	mov    %al,(%ebx,%esi,1)
400318cc:	46                   	inc    %esi
400318cd:	eb f3                	jmp    400318c2 <memcpy+0x57>
		n--;
	}

	return d;
}
400318cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
400318d2:	5a                   	pop    %edx
400318d3:	5b                   	pop    %ebx
400318d4:	5e                   	pop    %esi
400318d5:	5f                   	pop    %edi
400318d6:	5d                   	pop    %ebp
400318d7:	c3                   	ret    

400318d8 <_nano_fiber_ready>:
 * while this routine is executing!
 *
 * @return N/A
 */
void _nano_fiber_ready(struct tcs *tcs)
{
400318d8:	55                   	push   %ebp
	struct tcs *pQ = (struct tcs *)&_nanokernel.fiber;
400318d9:	b9 64 65 00 a8       	mov    $0xa8006564,%ecx
 * while this routine is executing!
 *
 * @return N/A
 */
void _nano_fiber_ready(struct tcs *tcs)
{
400318de:	89 e5                	mov    %esp,%ebp
400318e0:	53                   	push   %ebx
	/*
	 * Search until end of list or until a fiber with numerically
	 * higher priority is located.
	 */

	while (pQ->link && (tcs->prio >= pQ->link->prio)) {
400318e1:	8b 11                	mov    (%ecx),%edx
400318e3:	85 d2                	test   %edx,%edx
400318e5:	74 0c                	je     400318f3 <_nano_fiber_ready+0x1b>
400318e7:	8b 5a 0c             	mov    0xc(%edx),%ebx
400318ea:	39 58 0c             	cmp    %ebx,0xc(%eax)
400318ed:	7c 04                	jl     400318f3 <_nano_fiber_ready+0x1b>
400318ef:	89 d1                	mov    %edx,%ecx
400318f1:	eb ee                	jmp    400318e1 <_nano_fiber_ready+0x9>
		pQ = pQ->link;
	}

	/* Insert fiber, following any equal priority fibers */

	tcs->link = pQ->link;
400318f3:	89 10                	mov    %edx,(%eax)
	pQ->link = tcs;
400318f5:	89 01                	mov    %eax,(%ecx)
}
400318f7:	5b                   	pop    %ebx
400318f8:	5d                   	pop    %ebp
400318f9:	c3                   	ret    

400318fa <_fiber_start>:
		nano_fiber_entry_t pEntry,
		int parameter1,
		int parameter2,
		unsigned priority,
		unsigned options)
{
400318fa:	55                   	push   %ebp
400318fb:	89 e5                	mov    %esp,%ebp
400318fd:	56                   	push   %esi
400318fe:	53                   	push   %ebx
400318ff:	89 c6                	mov    %eax,%esi
	struct tcs *tcs;
	unsigned int imask;

	tcs = (struct tcs *) pStack;
	_new_thread(pStack,
40031901:	ff 75 14             	pushl  0x14(%ebp)
40031904:	ff 75 10             	pushl  0x10(%ebp)
40031907:	6a 00                	push   $0x0
40031909:	ff 75 0c             	pushl  0xc(%ebp)
4003190c:	ff 75 08             	pushl  0x8(%ebp)
4003190f:	e8 9c 09 00 00       	call   400322b0 <_new_thread>
40031914:	83 c4 14             	add    $0x14,%esp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40031917:	9c                   	pushf  
40031918:	fa                   	cli    
40031919:	5b                   	pop    %ebx

	imask = irq_lock();

	/* make the newly crafted TCS a runnable fiber */

	_nano_fiber_ready(tcs);
4003191a:	89 f0                	mov    %esi,%eax
4003191c:	e8 b7 ff ff ff       	call   400318d8 <_nano_fiber_ready>
	/*
	 * Simply return to the caller if the current thread is FIBER,
	 * otherwise swap into the newly created fiber
	 */

	if ((_nanokernel.current->flags & TASK) == TASK) {
40031921:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
40031926:	f6 40 04 01          	testb  $0x1,0x4(%eax)
4003192a:	74 0d                	je     40031939 <_fiber_start+0x3f>
		_Swap(imask);
	} else {
		irq_unlock(imask);
	}
}
4003192c:	8d 65 f8             	lea    -0x8(%ebp),%esp
	 * Simply return to the caller if the current thread is FIBER,
	 * otherwise swap into the newly created fiber
	 */

	if ((_nanokernel.current->flags & TASK) == TASK) {
		_Swap(imask);
4003192f:	89 d8                	mov    %ebx,%eax
	} else {
		irq_unlock(imask);
	}
}
40031931:	5b                   	pop    %ebx
40031932:	5e                   	pop    %esi
40031933:	5d                   	pop    %ebp
	 * Simply return to the caller if the current thread is FIBER,
	 * otherwise swap into the newly created fiber
	 */

	if ((_nanokernel.current->flags & TASK) == TASK) {
		_Swap(imask);
40031934:	e9 c1 08 00 00       	jmp    400321fa <_Swap>
40031939:	80 e7 02             	and    $0x2,%bh
4003193c:	74 01                	je     4003193f <_fiber_start+0x45>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
4003193e:	fb                   	sti    
	} else {
		irq_unlock(imask);
	}
}
4003193f:	8d 65 f8             	lea    -0x8(%ebp),%esp
40031942:	5b                   	pop    %ebx
40031943:	5e                   	pop    %esi
40031944:	5d                   	pop    %ebp
40031945:	c3                   	ret    

40031946 <_nano_fiber_swap>:
 * This routine can only be called from a fiber.
 *
 * @return This function never returns
 */
FUNC_NORETURN void _nano_fiber_swap(void)
{
40031946:	55                   	push   %ebp
40031947:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40031949:	9c                   	pushf  
4003194a:	fa                   	cli    
4003194b:	58                   	pop    %eax
	 * switch to the highest priority fiber, or the highest priority task
	 * if there are no runnable fibers.
	 */

	imask = irq_lock();
	_Swap(imask);
4003194c:	e8 a9 08 00 00       	call   400321fa <_Swap>

40031951 <fiber_abort>:
	CODE_UNREACHABLE;
}

#ifndef CONFIG_ARCH_HAS_NANO_FIBER_ABORT
FUNC_NORETURN void fiber_abort(void)
{
40031951:	55                   	push   %ebp
40031952:	89 e5                	mov    %esp,%ebp
	/* Do normal thread exit cleanup, then give up CPU control */

	_thread_exit(_nanokernel.current);
	_nano_fiber_swap();
40031954:	e8 ed ff ff ff       	call   40031946 <_nano_fiber_swap>

40031959 <nano_task_lifo_get>:
	irq_unlock(imask);
	return data;
}

void *nano_task_lifo_get(struct nano_lifo *lifo, int32_t timeout_in_ticks)
{
40031959:	55                   	push   %ebp
4003195a:	89 c1                	mov    %eax,%ecx
4003195c:	89 e5                	mov    %esp,%ebp
4003195e:	57                   	push   %edi
4003195f:	56                   	push   %esi
40031960:	53                   	push   %ebx
40031961:	83 ec 08             	sub    $0x8,%esp
40031964:	9c                   	pushf  
40031965:	fa                   	cli    
40031966:	58                   	pop    %eax
	int64_t cur_ticks;
	int64_t limit = 0x7fffffffffffffffll;
40031967:	83 ce ff             	or     $0xffffffff,%esi
4003196a:	bf ff ff ff 7f       	mov    $0x7fffffff,%edi
	unsigned int imask;

	imask = irq_lock();
	cur_ticks = _NANO_TIMEOUT_TICK_GET();
	if (timeout_in_ticks != TICKS_UNLIMITED) {
4003196f:	83 fa ff             	cmp    $0xffffffff,%edx
40031972:	74 07                	je     4003197b <nano_task_lifo_get+0x22>
		limit = cur_ticks + timeout_in_ticks;
40031974:	89 d7                	mov    %edx,%edi
40031976:	89 d6                	mov    %edx,%esi
40031978:	c1 ff 1f             	sar    $0x1f,%edi
		/*
		 * Predict that the branch will be taken to break out of the loop.
		 * There is little cost to a misprediction since that leads to idle.
		 */

		if (likely(lifo->list != NULL)) {
4003197b:	8b 59 08             	mov    0x8(%ecx),%ebx
4003197e:	85 db                	test   %ebx,%ebx
40031980:	74 07                	je     40031989 <nano_task_lifo_get+0x30>
			void *data = lifo->list;

			lifo->list = *(void **) data;
40031982:	8b 13                	mov    (%ebx),%edx
40031984:	89 51 08             	mov    %edx,0x8(%ecx)
40031987:	eb 24                	jmp    400319ad <nano_task_lifo_get+0x54>
			irq_unlock(imask);

			return data;
		}

		if (timeout_in_ticks != TICKS_NONE) {
40031989:	85 d2                	test   %edx,%edx
4003198b:	74 14                	je     400319a1 <nano_task_lifo_get+0x48>
4003198d:	89 55 ec             	mov    %edx,-0x14(%ebp)
40031990:	89 4d f0             	mov    %ecx,-0x10(%ebp)

			_NANO_TIMEOUT_SET_TASK_TIMEOUT(timeout_in_ticks);

			/* see explanation in nano_stack.c:nano_task_stack_pop() */
			nano_cpu_atomic_idle(imask);
40031993:	e8 86 0b 00 00       	call   4003251e <nano_cpu_atomic_idle>
40031998:	9c                   	pushf  
40031999:	fa                   	cli    
4003199a:	58                   	pop    %eax
4003199b:	8b 55 ec             	mov    -0x14(%ebp),%edx
4003199e:	8b 4d f0             	mov    -0x10(%ebp),%ecx

			imask = irq_lock();
			cur_ticks = _NANO_TIMEOUT_TICK_GET();
		}
	} while (cur_ticks < limit);
400319a1:	83 ff 00             	cmp    $0x0,%edi
400319a4:	7f d5                	jg     4003197b <nano_task_lifo_get+0x22>
400319a6:	7c 05                	jl     400319ad <nano_task_lifo_get+0x54>
400319a8:	83 fe 00             	cmp    $0x0,%esi
400319ab:	77 ce                	ja     4003197b <nano_task_lifo_get+0x22>
400319ad:	f6 c4 02             	test   $0x2,%ah
400319b0:	74 01                	je     400319b3 <nano_task_lifo_get+0x5a>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
400319b2:	fb                   	sti    

	irq_unlock(imask);

	return NULL;
}
400319b3:	5a                   	pop    %edx
400319b4:	89 d8                	mov    %ebx,%eax
400319b6:	59                   	pop    %ecx
400319b7:	5b                   	pop    %ebx
400319b8:	5e                   	pop    %esi
400319b9:	5f                   	pop    %edi
400319ba:	5d                   	pop    %ebp
400319bb:	c3                   	ret    

400319bc <_lifo_get>:

FUNC_ALIAS(_lifo_get, nano_isr_lifo_get, void *);
FUNC_ALIAS(_lifo_get, nano_fiber_lifo_get, void *);

void *_lifo_get(struct nano_lifo *lifo, int32_t timeout_in_ticks)
{
400319bc:	55                   	push   %ebp
400319bd:	89 c1                	mov    %eax,%ecx
400319bf:	89 e5                	mov    %esp,%ebp
400319c1:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400319c2:	9c                   	pushf  
400319c3:	fa                   	cli    
400319c4:	58                   	pop    %eax
	void *data = NULL;
	unsigned int imask;

	imask = irq_lock();

	if (likely(lifo->list != NULL)) {
400319c5:	8b 59 08             	mov    0x8(%ecx),%ebx
400319c8:	85 db                	test   %ebx,%ebx
400319ca:	74 07                	je     400319d3 <_lifo_get+0x17>
		data = lifo->list;
		lifo->list = *(void **) data;
400319cc:	8b 13                	mov    (%ebx),%edx
400319ce:	89 51 08             	mov    %edx,0x8(%ecx)
400319d1:	eb 19                	jmp    400319ec <_lifo_get+0x30>
	} else if (timeout_in_ticks != TICKS_NONE) {
400319d3:	85 d2                	test   %edx,%edx
400319d5:	74 15                	je     400319ec <_lifo_get+0x30>
}

/* put current fiber on specified wait queue */
static inline void _nano_wait_q_put(struct _nano_queue *wait_q)
{
	((struct tcs *)wait_q->tail)->link = _nanokernel.current;
400319d7:	8b 59 04             	mov    0x4(%ecx),%ebx
400319da:	8b 15 6c 65 00 a8    	mov    0xa800656c,%edx
400319e0:	89 13                	mov    %edx,(%ebx)
	wait_q->tail = _nanokernel.current;
400319e2:	89 51 04             	mov    %edx,0x4(%ecx)
		return data;
	}

	irq_unlock(imask);
	return data;
}
400319e5:	5b                   	pop    %ebx
400319e6:	5d                   	pop    %ebp
		data = lifo->list;
		lifo->list = *(void **) data;
	} else if (timeout_in_ticks != TICKS_NONE) {
		_NANO_TIMEOUT_ADD(&lifo->wait_q, timeout_in_ticks);
		_nano_wait_q_put(&lifo->wait_q);
		data = (void *) _Swap(imask);
400319e7:	e9 0e 08 00 00       	jmp    400321fa <_Swap>
400319ec:	f6 c4 02             	test   $0x2,%ah
400319ef:	74 01                	je     400319f2 <_lifo_get+0x36>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
400319f1:	fb                   	sti    
		return data;
	}

	irq_unlock(imask);
	return data;
}
400319f2:	89 d8                	mov    %ebx,%eax
400319f4:	5b                   	pop    %ebx
400319f5:	5d                   	pop    %ebp
400319f6:	c3                   	ret    

400319f7 <_lifo_put_non_preemptible>:
 * ISR context.  However, the nano_isr_lifo_put and nano_fiber_lifo_put aliases
 * are created to support any required implementation differences in the future
 * without introducing a source code migration issue.
 */
void _lifo_put_non_preemptible(struct nano_lifo *lifo, void *data)
{
400319f7:	55                   	push   %ebp
400319f8:	89 e5                	mov    %esp,%ebp
400319fa:	57                   	push   %edi
400319fb:	56                   	push   %esi
400319fc:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
400319fd:	9c                   	pushf  
400319fe:	fa                   	cli    
400319ff:	5e                   	pop    %esi
 * Remove first fiber from a wait queue and put it on the ready queue.
 * Abort and return NULL if the wait queue is empty.
 */
static inline struct tcs *_nano_wait_q_remove(struct _nano_queue *wait_q)
{
	return wait_q->head ? _nano_wait_q_remove_no_check(wait_q) : NULL;
40031a00:	8b 18                	mov    (%eax),%ebx
40031a02:	85 db                	test   %ebx,%ebx
40031a04:	74 33                	je     40031a39 <_lifo_put_non_preemptible+0x42>
static inline
struct tcs *_nano_wait_q_remove_no_check(struct _nano_queue *wait_q)
{
	struct tcs *tcs = wait_q->head;

	if (wait_q->tail == wait_q->head) {
40031a06:	3b 58 04             	cmp    0x4(%eax),%ebx
40031a09:	75 0b                	jne    40031a16 <_lifo_put_non_preemptible+0x1f>
#endif

/* reset a wait queue, call during operation */
static inline void _nano_wait_q_reset(struct _nano_queue *wait_q)
{
	wait_q->head = (void *)0;
40031a0b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	wait_q->tail = (void *)&(wait_q->head);
40031a11:	89 40 04             	mov    %eax,0x4(%eax)
40031a14:	eb 04                	jmp    40031a1a <_lifo_put_non_preemptible+0x23>
	struct tcs *tcs = wait_q->head;

	if (wait_q->tail == wait_q->head) {
		_nano_wait_q_reset(wait_q);
	} else {
		wait_q->head = tcs->link;
40031a16:	8b 0b                	mov    (%ebx),%ecx
40031a18:	89 08                	mov    %ecx,(%eax)
	}
	tcs->link = 0;

	_nano_fiber_ready(tcs);
40031a1a:	89 d8                	mov    %ebx,%eax
	if (wait_q->tail == wait_q->head) {
		_nano_wait_q_reset(wait_q);
	} else {
		wait_q->head = tcs->link;
	}
	tcs->link = 0;
40031a1c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
40031a22:	89 d7                	mov    %edx,%edi

	_nano_fiber_ready(tcs);
40031a24:	e8 af fe ff ff       	call   400318d8 <_nano_fiber_ready>
 */
static inline void fiberRtnValueSet(struct tcs *fiber, unsigned int value)
{
	/* write into 'eax' slot created in _Swap() entry */

	*(unsigned int *)(fiber->coopReg.esp) = value;
40031a29:	8b 43 08             	mov    0x8(%ebx),%eax
40031a2c:	89 38                	mov    %edi,(%eax)
40031a2e:	81 e6 00 02 00 00    	and    $0x200,%esi
40031a34:	74 0d                	je     40031a43 <_lifo_put_non_preemptible+0x4c>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40031a36:	fb                   	sti    
		*(void **) data = lifo->list;
		lifo->list = data;
	}

	irq_unlock(imask);
}
40031a37:	eb 0a                	jmp    40031a43 <_lifo_put_non_preemptible+0x4c>
	tcs = _nano_wait_q_remove(&lifo->wait_q);
	if (tcs) {
		_nano_timeout_abort(tcs);
		fiberRtnValueSet(tcs, (unsigned int) data);
	} else {
		*(void **) data = lifo->list;
40031a39:	8b 48 08             	mov    0x8(%eax),%ecx
40031a3c:	89 0a                	mov    %ecx,(%edx)
		lifo->list = data;
40031a3e:	89 50 08             	mov    %edx,0x8(%eax)
40031a41:	eb eb                	jmp    40031a2e <_lifo_put_non_preemptible+0x37>
	}

	irq_unlock(imask);
}
40031a43:	5b                   	pop    %ebx
40031a44:	5e                   	pop    %esi
40031a45:	5f                   	pop    %edi
40031a46:	5d                   	pop    %ebp
40031a47:	c3                   	ret    

40031a48 <nano_lifo_init>:
 * Although the existing implementation will support invocation from an ISR
 * context, for future flexibility, this API will be restricted from ISR
 * level invocation.
 */
void nano_lifo_init(struct nano_lifo *lifo)
{
40031a48:	55                   	push   %ebp
	lifo->list = (void *) 0;
40031a49:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Although the existing implementation will support invocation from an ISR
 * context, for future flexibility, this API will be restricted from ISR
 * level invocation.
 */
void nano_lifo_init(struct nano_lifo *lifo)
{
40031a50:	89 e5                	mov    %esp,%ebp
#endif

/* reset a wait queue, call during operation */
static inline void _nano_wait_q_reset(struct _nano_queue *wait_q)
{
	wait_q->head = (void *)0;
40031a52:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	wait_q->tail = (void *)&(wait_q->head);
40031a58:	89 40 04             	mov    %eax,0x4(%eax)
	lifo->list = (void *) 0;
	_nano_wait_q_init(&lifo->wait_q);
	DEBUG_TRACING_OBJ_INIT(struct nano_lifo *, lifo, _track_list_nano_lifo);
}
40031a5b:	5d                   	pop    %ebp
40031a5c:	c3                   	ret    

40031a5d <nano_lifo_get>:

	return NULL;
}

void *nano_lifo_get(struct nano_lifo *lifo, int32_t timeout)
{
40031a5d:	55                   	push   %ebp
40031a5e:	89 e5                	mov    %esp,%ebp
40031a60:	53                   	push   %ebx
40031a61:	89 c3                	mov    %eax,%ebx
40031a63:	51                   	push   %ecx
40031a64:	89 55 f8             	mov    %edx,-0x8(%ebp)
		nano_isr_lifo_get,
		nano_fiber_lifo_get,
		nano_task_lifo_get
	};

	return func[sys_execution_context_type_get()](lifo, timeout);
40031a67:	e8 73 00 00 00       	call   40031adf <sys_execution_context_type_get>
40031a6c:	8b 55 f8             	mov    -0x8(%ebp),%edx
40031a6f:	8b 0c 85 44 28 03 40 	mov    0x40032844(,%eax,4),%ecx
40031a76:	89 d8                	mov    %ebx,%eax
}
40031a78:	5b                   	pop    %ebx
40031a79:	5b                   	pop    %ebx
40031a7a:	5d                   	pop    %ebp
		nano_isr_lifo_get,
		nano_fiber_lifo_get,
		nano_task_lifo_get
	};

	return func[sys_execution_context_type_get()](lifo, timeout);
40031a7b:	ff e1                	jmp    *%ecx

40031a7d <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the fibers pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
40031a7d:	55                   	push   %ebp
40031a7e:	89 e5                	mov    %esp,%ebp
40031a80:	57                   	push   %edi
40031a81:	56                   	push   %esi
40031a82:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40031a83:	9c                   	pushf  
40031a84:	fa                   	cli    
40031a85:	5b                   	pop    %ebx
	unsigned int  key;

	key = irq_lock();
	_sys_clock_tick_count += ticks;
40031a86:	89 c7                	mov    %eax,%edi
/* handle the expired nano timers in the nano timers queue */
#ifdef CONFIG_NANO_TIMERS
#include <sys_clock.h>
static inline void handle_expired_nano_timers(int ticks)
{
	if (_nano_timer_list) {
40031a88:	8b 15 e8 6b 00 a8    	mov    0xa8006be8,%edx
void _nano_sys_clock_tick_announce(int32_t ticks)
{
	unsigned int  key;

	key = irq_lock();
	_sys_clock_tick_count += ticks;
40031a8e:	c1 ff 1f             	sar    $0x1f,%edi
40031a91:	01 05 e0 6b 00 a8    	add    %eax,0xa8006be0
40031a97:	11 3d e4 6b 00 a8    	adc    %edi,0xa8006be4
/* handle the expired nano timers in the nano timers queue */
#ifdef CONFIG_NANO_TIMERS
#include <sys_clock.h>
static inline void handle_expired_nano_timers(int ticks)
{
	if (_nano_timer_list) {
40031a9d:	85 d2                	test   %edx,%edx
40031a9f:	75 08                	jne    40031aa9 <_nano_sys_clock_tick_announce+0x2c>
40031aa1:	80 e7 02             	and    $0x2,%bh
40031aa4:	74 2a                	je     40031ad0 <_nano_sys_clock_tick_announce+0x53>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40031aa6:	fb                   	sti    
	key = irq_lock();
	_sys_clock_tick_count += ticks;
	handle_expired_nano_timeouts(ticks);
	handle_expired_nano_timers(ticks);
	irq_unlock(key);
}
40031aa7:	eb 27                	jmp    40031ad0 <_nano_sys_clock_tick_announce+0x53>
#ifdef CONFIG_NANO_TIMERS
#include <sys_clock.h>
static inline void handle_expired_nano_timers(int ticks)
{
	if (_nano_timer_list) {
		_nano_timer_list->ticks -= ticks;
40031aa9:	29 42 04             	sub    %eax,0x4(%edx)

		while (_nano_timer_list && (!_nano_timer_list->ticks)) {
40031aac:	a1 e8 6b 00 a8       	mov    0xa8006be8,%eax
40031ab1:	85 c0                	test   %eax,%eax
40031ab3:	74 ec                	je     40031aa1 <_nano_sys_clock_tick_announce+0x24>
40031ab5:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
40031ab9:	75 e6                	jne    40031aa1 <_nano_sys_clock_tick_announce+0x24>
			struct nano_timer *expired = _nano_timer_list;
			struct nano_lifo *lifo = &expired->lifo;

			_nano_timer_list = expired->link;
40031abb:	8b 10                	mov    (%eax),%edx
	if (_nano_timer_list) {
		_nano_timer_list->ticks -= ticks;

		while (_nano_timer_list && (!_nano_timer_list->ticks)) {
			struct nano_timer *expired = _nano_timer_list;
			struct nano_lifo *lifo = &expired->lifo;
40031abd:	83 c0 08             	add    $0x8,%eax

			_nano_timer_list = expired->link;
40031ac0:	89 15 e8 6b 00 a8    	mov    %edx,0xa8006be8
			nano_isr_lifo_put(lifo, expired->userData);
40031ac6:	8b 50 0c             	mov    0xc(%eax),%edx
40031ac9:	e8 29 ff ff ff       	call   400319f7 <_lifo_put_non_preemptible>
40031ace:	eb dc                	jmp    40031aac <_nano_sys_clock_tick_announce+0x2f>
	key = irq_lock();
	_sys_clock_tick_count += ticks;
	handle_expired_nano_timeouts(ticks);
	handle_expired_nano_timers(ticks);
	irq_unlock(key);
}
40031ad0:	5b                   	pop    %ebx
40031ad1:	5e                   	pop    %esi
40031ad2:	5f                   	pop    %edi
40031ad3:	5d                   	pop    %ebp
40031ad4:	c3                   	ret    

40031ad5 <sys_thread_self_get>:
#include <sys_clock.h>
#include <drivers/system_timer.h>


nano_thread_id_t sys_thread_self_get(void)
{
40031ad5:	55                   	push   %ebp
	return _nanokernel.current;
}
40031ad6:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
#include <sys_clock.h>
#include <drivers/system_timer.h>


nano_thread_id_t sys_thread_self_get(void)
{
40031adb:	89 e5                	mov    %esp,%ebp
	return _nanokernel.current;
}
40031add:	5d                   	pop    %ebp
40031ade:	c3                   	ret    

40031adf <sys_execution_context_type_get>:

nano_context_type_t sys_execution_context_type_get(void)
{
40031adf:	55                   	push   %ebp
40031ae0:	31 c0                	xor    %eax,%eax
40031ae2:	89 e5                	mov    %esp,%ebp
	if (_IS_IN_ISR())
40031ae4:	83 3d 70 65 00 a8 00 	cmpl   $0x0,0xa8006570
40031aeb:	75 13                	jne    40031b00 <sys_execution_context_type_get+0x21>
		return NANO_CTX_ISR;

	if ((_nanokernel.current->flags & TASK) == TASK)
40031aed:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
40031af2:	8b 40 04             	mov    0x4(%eax),%eax
40031af5:	83 e0 01             	and    $0x1,%eax
		return NANO_CTX_TASK;

	return NANO_CTX_FIBER;
40031af8:	83 f8 01             	cmp    $0x1,%eax
40031afb:	19 c0                	sbb    %eax,%eax
40031afd:	83 c0 02             	add    $0x2,%eax
}
40031b00:	5d                   	pop    %ebp
40031b01:	c3                   	ret    

40031b02 <_is_thread_essential>:
 *
 * @return Non-zero if specified thread is essential, zero if it is not
 */
int _is_thread_essential(struct tcs *pCtx /* pointer to thread */
					   )
{
40031b02:	55                   	push   %ebp
	return ((pCtx == NULL) ? _nanokernel.current : pCtx)->flags & ESSENTIAL;
40031b03:	85 c0                	test   %eax,%eax
 *
 * @return Non-zero if specified thread is essential, zero if it is not
 */
int _is_thread_essential(struct tcs *pCtx /* pointer to thread */
					   )
{
40031b05:	89 e5                	mov    %esp,%ebp
	return ((pCtx == NULL) ? _nanokernel.current : pCtx)->flags & ESSENTIAL;
40031b07:	75 05                	jne    40031b0e <_is_thread_essential+0xc>
40031b09:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
40031b0e:	8b 40 04             	mov    0x4(%eax),%eax
}
40031b11:	5d                   	pop    %ebp
 * @return Non-zero if specified thread is essential, zero if it is not
 */
int _is_thread_essential(struct tcs *pCtx /* pointer to thread */
					   )
{
	return ((pCtx == NULL) ? _nanokernel.current : pCtx)->flags & ESSENTIAL;
40031b12:	25 00 02 00 00       	and    $0x200,%eax
}
40031b17:	c3                   	ret    

40031b18 <_thread_entry>:
 */
FUNC_NORETURN void _thread_entry(_thread_entry_t pEntry,
					_thread_arg_t parameter1,
					_thread_arg_t parameter2,
					_thread_arg_t parameter3)
{
40031b18:	55                   	push   %ebp
40031b19:	89 e5                	mov    %esp,%ebp
40031b1b:	53                   	push   %ebx
40031b1c:	89 c3                	mov    %eax,%ebx
40031b1e:	89 d0                	mov    %edx,%eax
40031b20:	89 ca                	mov    %ecx,%edx
	/* Execute the "application" entry point function */

	pEntry(parameter1, parameter2, parameter3);
40031b22:	8b 4d 08             	mov    0x8(%ebp),%ecx
40031b25:	ff d3                	call   *%ebx

	/* Determine if thread can legally terminate itself via "return" */

	if (_is_thread_essential(NULL)) {
40031b27:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
40031b2c:	f6 40 05 02          	testb  $0x2,0x5(%eax)
40031b30:	74 21                	je     40031b53 <_thread_entry+0x3b>
		/*
		 * Nanokernel's background task must always be present,
		 * so if it has nothing left to do just let it idle forever
		 */

		while (((_nanokernel.current)->flags & TASK) == TASK) {
40031b32:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
40031b37:	f6 40 04 01          	testb  $0x1,0x4(%eax)
40031b3b:	74 07                	je     40031b44 <_thread_entry+0x2c>
			nano_cpu_idle();
40031b3d:	e8 d5 09 00 00       	call   40032517 <nano_cpu_idle>
40031b42:	eb ee                	jmp    40031b32 <_thread_entry+0x1a>
		}
#endif /*  CONFIG_NANOKERNEL */

		/* Loss of essential thread is a system fatal error */

		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
40031b44:	ba 80 2a 03 40       	mov    $0x40032a80,%edx
40031b49:	b8 03 00 00 00       	mov    $0x3,%eax
40031b4e:	e8 dd 07 00 00       	call   40032330 <_NanoFatalErrorHandler>
		extern FUNC_NORETURN void _TaskAbort(void);
		_TaskAbort();
	} else
#endif /* CONFIG_MICROKERNEL */
	{
		fiber_abort();
40031b53:	e8 f9 fd ff ff       	call   40031951 <fiber_abort>

40031b58 <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void)
{
40031b58:	55                   	push   %ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
40031b59:	b8 01 00 00 00       	mov    $0x1,%eax
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void)
{
40031b5e:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
40031b60:	e8 44 01 00 00       	call   40031ca9 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
40031b65:	b8 02 00 00 00       	mov    $0x2,%eax
40031b6a:	e8 3a 01 00 00       	call   40031ca9 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
40031b6f:	b8 04 00 00 00       	mov    $0x4,%eax
40031b74:	e8 30 01 00 00       	call   40031ca9 <_sys_device_do_config_level>
	__do_init_array_aux();
#endif

	extern void main(void);
	main();
}
40031b79:	5d                   	pop    %ebp
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	extern void main(void);
	main();
40031b7a:	e9 56 ed ff ff       	jmp    400308d5 <main>

40031b7f <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
40031b7f:	55                   	push   %ebp
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031b80:	b9 58 1b 03 40       	mov    $0x40031b58,%ecx
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
40031b85:	89 e5                	mov    %esp,%ebp
40031b87:	83 ec 14             	sub    $0x14,%esp
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031b8a:	ba 00 04 00 00       	mov    $0x400,%edx
	/*
	 * Initialize the thread control block (TCS) for the main task (either
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;
40031b8f:	c7 05 68 65 00 a8 80 	movl   $0xa8007480,0xa8006568
40031b96:	74 00 a8 
	 * output if an exception should happen during nanokernel initialization.
	 * However, don't waste effort initializing the fields of the dummy thread
	 * beyond those needed to identify it as a dummy thread.
	 */

	_nanokernel.current = dummyOutContext;
40031b99:	8d 45 ec             	lea    -0x14(%ebp),%eax
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031b9c:	6a 00                	push   $0x0
	 * output if an exception should happen during nanokernel initialization.
	 * However, don't waste effort initializing the fields of the dummy thread
	 * beyond those needed to identify it as a dummy thread.
	 */

	_nanokernel.current = dummyOutContext;
40031b9e:	a3 6c 65 00 a8       	mov    %eax,0xa800656c
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031ba3:	b8 80 74 00 a8       	mov    $0xa8007480,%eax
40031ba8:	6a ff                	push   $0xffffffff

	/*
	 * Do not insert dummy execution context in the list of fibers, so that it
	 * does not get scheduled back in once context-switched out.
	 */
	dummyOutContext->link = (struct tcs *)NULL;
40031baa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031bb1:	6a 00                	push   $0x0
	 * Do not insert dummy execution context in the list of fibers, so that it
	 * does not get scheduled back in once context-switched out.
	 */
	dummyOutContext->link = (struct tcs *)NULL;

	dummyOutContext->flags = FIBER | ESSENTIAL;
40031bb3:	c7 45 f0 00 02 00 00 	movl   $0x200,-0x10(%ebp)
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031bba:	6a 00                	push   $0x0
	 * does not get scheduled back in once context-switched out.
	 */
	dummyOutContext->link = (struct tcs *)NULL;

	dummyOutContext->flags = FIBER | ESSENTIAL;
	dummyOutContext->prio = 0;
40031bbc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031bc3:	6a 00                	push   $0x0
40031bc5:	e8 e6 06 00 00       	call   400322b0 <_new_thread>
			    0				 /* options */
			    );

	/* indicate that failure of this task may be fatal to the entire system */

	_nanokernel.task->flags |= ESSENTIAL;
40031bca:	a1 68 65 00 a8       	mov    0xa8006568,%eax
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
40031bcf:	83 c4 14             	add    $0x14,%esp
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
40031bd2:	c7 05 50 6c 00 a8 00 	movl   $0x800,0xa8006c50
40031bd9:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_ExcEnt;
40031bdc:	c7 05 00 6c 00 a8 77 	movl   $0x40032577,0xa8006c00
40031be3:	25 03 40 
			    0				 /* options */
			    );

	/* indicate that failure of this task may be fatal to the entire system */

	_nanokernel.task->flags |= ESSENTIAL;
40031be6:	81 48 04 00 02 00 00 	orl    $0x200,0x4(%eax)
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];
	extern void _ExcEnt(void);

	_nanokernel.nested = 0;

	_nanokernel.common_isp = (char *)STACK_ROUND_DOWN(
40031bed:	b8 7f 74 00 a8       	mov    $0xa800747f,%eax
	extern void *_dummy_spurious_interrupt;
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];
	extern void _ExcEnt(void);

	_nanokernel.nested = 0;
40031bf2:	c7 05 70 65 00 a8 00 	movl   $0x0,0xa8006570
40031bf9:	00 00 00 

	_nanokernel.common_isp = (char *)STACK_ROUND_DOWN(
40031bfc:	83 e0 fc             	and    $0xfffffffc,%eax
40031bff:	a3 74 65 00 a8       	mov    %eax,0xa8006574

	nano_init((struct tcs *)&dummyTCS);

	/* perform basic hardware initialization */

	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
40031c04:	31 c0                	xor    %eax,%eax
40031c06:	e8 9e 00 00 00       	call   40031ca9 <_sys_device_do_config_level>

	PRINT_BOOT_BANNER();

	/* context switch to main task (entry function is _main()) */

	_nano_fiber_swap();
40031c0b:	e8 36 fd ff ff       	call   40031946 <_nano_fiber_swap>

40031c10 <_sem_take>:

FUNC_ALIAS(_sem_take, nano_isr_sem_take, int);
FUNC_ALIAS(_sem_take, nano_fiber_sem_take, int);

int _sem_take(struct nano_sem *sem, int32_t timeout_in_ticks)
{
40031c10:	55                   	push   %ebp
40031c11:	89 c1                	mov    %eax,%ecx
40031c13:	89 e5                	mov    %esp,%ebp
40031c15:	56                   	push   %esi
40031c16:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40031c17:	9c                   	pushf  
40031c18:	fa                   	cli    
40031c19:	5e                   	pop    %esi
	unsigned int key = irq_lock();

	if (likely(sem->nsig > 0)) {
40031c1a:	8b 58 08             	mov    0x8(%eax),%ebx
40031c1d:	85 db                	test   %ebx,%ebx
40031c1f:	7e 0b                	jle    40031c2c <_sem_take+0x1c>
		sem->nsig--;
40031c21:	4b                   	dec    %ebx
40031c22:	89 58 08             	mov    %ebx,0x8(%eax)
		irq_unlock(key);
		return 1;
40031c25:	b8 01 00 00 00       	mov    $0x1,%eax
40031c2a:	eb 1d                	jmp    40031c49 <_sem_take+0x39>
		_nano_wait_q_put(&sem->wait_q);
		return _Swap(key);
	}

	irq_unlock(key);
	return 0;
40031c2c:	31 c0                	xor    %eax,%eax
		sem->nsig--;
		irq_unlock(key);
		return 1;
	}

	if (timeout_in_ticks != TICKS_NONE) {
40031c2e:	85 d2                	test   %edx,%edx
40031c30:	74 17                	je     40031c49 <_sem_take+0x39>
}

/* put current fiber on specified wait queue */
static inline void _nano_wait_q_put(struct _nano_queue *wait_q)
{
	((struct tcs *)wait_q->tail)->link = _nanokernel.current;
40031c32:	8b 51 04             	mov    0x4(%ecx),%edx
40031c35:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
40031c3a:	89 02                	mov    %eax,(%edx)
	wait_q->tail = _nanokernel.current;
40031c3c:	89 41 04             	mov    %eax,0x4(%ecx)
		_NANO_TIMEOUT_ADD(&sem->wait_q, timeout_in_ticks);
		_nano_wait_q_put(&sem->wait_q);
		return _Swap(key);
40031c3f:	89 f0                	mov    %esi,%eax
	}

	irq_unlock(key);
	return 0;
}
40031c41:	5b                   	pop    %ebx
40031c42:	5e                   	pop    %esi
40031c43:	5d                   	pop    %ebp
	}

	if (timeout_in_ticks != TICKS_NONE) {
		_NANO_TIMEOUT_ADD(&sem->wait_q, timeout_in_ticks);
		_nano_wait_q_put(&sem->wait_q);
		return _Swap(key);
40031c44:	e9 b1 05 00 00       	jmp    400321fa <_Swap>
40031c49:	81 e6 00 02 00 00    	and    $0x200,%esi
40031c4f:	74 01                	je     40031c52 <_sem_take+0x42>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40031c51:	fb                   	sti    
	}

	irq_unlock(key);
	return 0;
}
40031c52:	5b                   	pop    %ebx
40031c53:	5e                   	pop    %esi
40031c54:	5d                   	pop    %ebp
40031c55:	c3                   	ret    

40031c56 <_sem_give_non_preemptible>:
 * ISR context.  However, the nano_isr_sem_give and nano_fiber_sem_give aliases
 * are created to support any required implementation differences in the future
 * without introducing a source code migration issue.
 */
void _sem_give_non_preemptible(struct nano_sem *sem)
{
40031c56:	55                   	push   %ebp
40031c57:	89 c2                	mov    %eax,%edx
40031c59:	89 e5                	mov    %esp,%ebp
40031c5b:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40031c5c:	9c                   	pushf  
40031c5d:	fa                   	cli    
40031c5e:	5b                   	pop    %ebx
 * Remove first fiber from a wait queue and put it on the ready queue.
 * Abort and return NULL if the wait queue is empty.
 */
static inline struct tcs *_nano_wait_q_remove(struct _nano_queue *wait_q)
{
	return wait_q->head ? _nano_wait_q_remove_no_check(wait_q) : NULL;
40031c5f:	8b 00                	mov    (%eax),%eax
40031c61:	85 c0                	test   %eax,%eax
40031c63:	74 27                	je     40031c8c <_sem_give_non_preemptible+0x36>
static inline
struct tcs *_nano_wait_q_remove_no_check(struct _nano_queue *wait_q)
{
	struct tcs *tcs = wait_q->head;

	if (wait_q->tail == wait_q->head) {
40031c65:	3b 42 04             	cmp    0x4(%edx),%eax
40031c68:	75 0b                	jne    40031c75 <_sem_give_non_preemptible+0x1f>
#endif

/* reset a wait queue, call during operation */
static inline void _nano_wait_q_reset(struct _nano_queue *wait_q)
{
	wait_q->head = (void *)0;
40031c6a:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	wait_q->tail = (void *)&(wait_q->head);
40031c70:	89 52 04             	mov    %edx,0x4(%edx)
40031c73:	eb 04                	jmp    40031c79 <_sem_give_non_preemptible+0x23>
	struct tcs *tcs = wait_q->head;

	if (wait_q->tail == wait_q->head) {
		_nano_wait_q_reset(wait_q);
	} else {
		wait_q->head = tcs->link;
40031c75:	8b 08                	mov    (%eax),%ecx
40031c77:	89 0a                	mov    %ecx,(%edx)
	}
	tcs->link = 0;
40031c79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	_nano_fiber_ready(tcs);
40031c7f:	e8 54 fc ff ff       	call   400318d8 <_nano_fiber_ready>
40031c84:	80 e7 02             	and    $0x2,%bh
40031c87:	74 08                	je     40031c91 <_sem_give_non_preemptible+0x3b>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40031c89:	fb                   	sti    
		_nano_timeout_abort(tcs);
		set_sem_available(tcs);
	}

	irq_unlock(imask);
}
40031c8a:	eb 05                	jmp    40031c91 <_sem_give_non_preemptible+0x3b>
	unsigned int imask;

	imask = irq_lock();
	tcs = _nano_wait_q_remove(&sem->wait_q);
	if (!tcs) {
		sem->nsig++;
40031c8c:	ff 42 08             	incl   0x8(%edx)
40031c8f:	eb f3                	jmp    40031c84 <_sem_give_non_preemptible+0x2e>
		_nano_timeout_abort(tcs);
		set_sem_available(tcs);
	}

	irq_unlock(imask);
}
40031c91:	5b                   	pop    %ebx
40031c92:	5d                   	pop    %ebp
40031c93:	c3                   	ret    

40031c94 <nano_sem_init>:
 * Although the existing implementation will support invocation from an ISR
 * context, for future flexibility, this API will be restricted from ISR
 * level invocation.
 */
void nano_sem_init(struct nano_sem *sem)
{
40031c94:	55                   	push   %ebp
	sem->nsig = 0;
40031c95:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
 * Although the existing implementation will support invocation from an ISR
 * context, for future flexibility, this API will be restricted from ISR
 * level invocation.
 */
void nano_sem_init(struct nano_sem *sem)
{
40031c9c:	89 e5                	mov    %esp,%ebp
#endif

/* reset a wait queue, call during operation */
static inline void _nano_wait_q_reset(struct _nano_queue *wait_q)
{
	wait_q->head = (void *)0;
40031c9e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	wait_q->tail = (void *)&(wait_q->head);
40031ca4:	89 40 04             	mov    %eax,0x4(%eax)
	sem->nsig = 0;
	_nano_wait_q_init(&sem->wait_q);
	DEBUG_TRACING_OBJ_INIT(struct nano_sem *, sem, _track_list_nano_sem);
}
40031ca7:	5d                   	pop    %ebp
40031ca8:	c3                   	ret    

40031ca9 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
40031ca9:	55                   	push   %ebp
40031caa:	89 e5                	mov    %esp,%ebp
40031cac:	56                   	push   %esi
40031cad:	89 c6                	mov    %eax,%esi
40031caf:	53                   	push   %ebx
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40031cb0:	8b 1c 85 50 28 03 40 	mov    0x40032850(,%eax,4),%ebx
40031cb7:	3b 1c b5 54 28 03 40 	cmp    0x40032854(,%esi,4),%ebx
40031cbe:	73 0c                	jae    40031ccc <_sys_device_do_config_level+0x23>
		struct device_config *device = info->config;

		device->init(info);
40031cc0:	8b 13                	mov    (%ebx),%edx
40031cc2:	89 d8                	mov    %ebx,%eax
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
40031cc4:	83 c3 0c             	add    $0xc,%ebx
		struct device_config *device = info->config;

		device->init(info);
40031cc7:	ff 52 04             	call   *0x4(%edx)
40031cca:	eb eb                	jmp    40031cb7 <_sys_device_do_config_level+0xe>
	}
}
40031ccc:	5b                   	pop    %ebx
40031ccd:	5e                   	pop    %esi
40031cce:	5d                   	pop    %ebp
40031ccf:	c3                   	ret    

40031cd0 <device_get_binding>:
 * @param name device name to search for.
 *
 * @return pointer to device structure, or NULL if not found.
 */
struct device *device_get_binding(char *name)
{
40031cd0:	55                   	push   %ebp
40031cd1:	89 e5                	mov    %esp,%ebp
40031cd3:	56                   	push   %esi
40031cd4:	89 c6                	mov    %eax,%esi
40031cd6:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
40031cd7:	bb 94 64 00 a8       	mov    $0xa8006494,%ebx
40031cdc:	81 fb 18 65 00 a8    	cmp    $0xa8006518,%ebx
40031ce2:	74 14                	je     40031cf8 <device_get_binding+0x28>
		if (!strcmp(name, info->config->name)) {
40031ce4:	8b 03                	mov    (%ebx),%eax
40031ce6:	8b 10                	mov    (%eax),%edx
40031ce8:	89 f0                	mov    %esi,%eax
40031cea:	e8 28 fb ff ff       	call   40031817 <strcmp>
40031cef:	85 c0                	test   %eax,%eax
40031cf1:	74 09                	je     40031cfc <device_get_binding+0x2c>
 */
struct device *device_get_binding(char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
40031cf3:	83 c3 0c             	add    $0xc,%ebx
40031cf6:	eb e4                	jmp    40031cdc <device_get_binding+0xc>
		if (!strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
40031cf8:	31 c0                	xor    %eax,%eax
40031cfa:	eb 02                	jmp    40031cfe <device_get_binding+0x2e>
40031cfc:	89 d8                	mov    %ebx,%eax
}
40031cfe:	5b                   	pop    %ebx
40031cff:	5e                   	pop    %esi
40031d00:	5d                   	pop    %ebp
40031d01:	c3                   	ret    

40031d02 <nano_timer_init>:

struct nano_timer *_nano_timer_list;


void nano_timer_init(struct nano_timer *timer, void *data)
{
40031d02:	55                   	push   %ebp
40031d03:	89 e5                	mov    %esp,%ebp
40031d05:	56                   	push   %esi
40031d06:	53                   	push   %ebx
40031d07:	89 c3                	mov    %eax,%ebx
40031d09:	89 d6                	mov    %edx,%esi
	nano_lifo_init(&timer->lifo);
40031d0b:	8d 40 08             	lea    0x8(%eax),%eax
40031d0e:	e8 35 fd ff ff       	call   40031a48 <nano_lifo_init>
	timer->userData = data;
40031d13:	89 73 14             	mov    %esi,0x14(%ebx)
	DEBUG_TRACING_OBJ_INIT(struct nano_timer *, timer, _track_list_nano_timer);
}
40031d16:	5b                   	pop    %ebx
40031d17:	5e                   	pop    %esi
40031d18:	5d                   	pop    %ebp
40031d19:	c3                   	ret    

40031d1a <_timer_start>:
void _timer_start(struct nano_timer *timer, /* timer to start */
				       int ticks /* number of system ticks
						  * before expiry
						  */
				       )
{
40031d1a:	55                   	push   %ebp
	unsigned int imask;
	struct nano_timer *cur;
	struct nano_timer *prev = NULL;

	timer->ticks = ticks;
40031d1b:	89 50 04             	mov    %edx,0x4(%eax)
void _timer_start(struct nano_timer *timer, /* timer to start */
				       int ticks /* number of system ticks
						  * before expiry
						  */
				       )
{
40031d1e:	89 e5                	mov    %esp,%ebp
40031d20:	57                   	push   %edi
40031d21:	56                   	push   %esi
40031d22:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40031d23:	9c                   	pushf  
40031d24:	fa                   	cli    
40031d25:	5e                   	pop    %esi

	timer->ticks = ticks;

	imask = irq_lock();

	cur = _nano_timer_list;
40031d26:	8b 15 e8 6b 00 a8    	mov    0xa8006be8,%edx
						  */
				       )
{
	unsigned int imask;
	struct nano_timer *cur;
	struct nano_timer *prev = NULL;
40031d2c:	31 db                	xor    %ebx,%ebx

	imask = irq_lock();

	cur = _nano_timer_list;

	while (cur && (timer->ticks > cur->ticks)) {
40031d2e:	85 d2                	test   %edx,%edx
40031d30:	74 15                	je     40031d47 <_timer_start+0x2d>
40031d32:	8b 48 04             	mov    0x4(%eax),%ecx
40031d35:	8b 7a 04             	mov    0x4(%edx),%edi
40031d38:	39 f9                	cmp    %edi,%ecx
40031d3a:	76 0b                	jbe    40031d47 <_timer_start+0x2d>
		timer->ticks -= cur->ticks;
40031d3c:	29 f9                	sub    %edi,%ecx
		prev = cur;
		cur = cur->link;
40031d3e:	89 d3                	mov    %edx,%ebx
	imask = irq_lock();

	cur = _nano_timer_list;

	while (cur && (timer->ticks > cur->ticks)) {
		timer->ticks -= cur->ticks;
40031d40:	89 48 04             	mov    %ecx,0x4(%eax)
		prev = cur;
		cur = cur->link;
40031d43:	8b 12                	mov    (%edx),%edx
40031d45:	eb e7                	jmp    40031d2e <_timer_start+0x14>
	}

	timer->link = cur;
40031d47:	89 10                	mov    %edx,(%eax)
	if (cur != NULL)
40031d49:	85 d2                	test   %edx,%edx
40031d4b:	74 06                	je     40031d53 <_timer_start+0x39>
		cur->ticks -= timer->ticks;
40031d4d:	8b 48 04             	mov    0x4(%eax),%ecx
40031d50:	29 4a 04             	sub    %ecx,0x4(%edx)

	if (prev != NULL)
40031d53:	85 db                	test   %ebx,%ebx
40031d55:	74 04                	je     40031d5b <_timer_start+0x41>
		prev->link = timer;
40031d57:	89 03                	mov    %eax,(%ebx)
40031d59:	eb 05                	jmp    40031d60 <_timer_start+0x46>
	else
		_nano_timer_list = timer;
40031d5b:	a3 e8 6b 00 a8       	mov    %eax,0xa8006be8
40031d60:	81 e6 00 02 00 00    	and    $0x200,%esi
40031d66:	74 01                	je     40031d69 <_timer_start+0x4f>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
40031d68:	fb                   	sti    

	irq_unlock(imask);
}
40031d69:	5b                   	pop    %ebx
40031d6a:	5e                   	pop    %esi
40031d6b:	5f                   	pop    %edi
40031d6c:	5d                   	pop    %ebp
40031d6d:	c3                   	ret    

40031d6e <sys_ring_buf_put>:
	uint32_t  value  :8;  /**< Room for small integral values */
};

int sys_ring_buf_put(struct ring_buf *buf, uint16_t type, uint8_t value,
		     uint32_t *data, uint8_t size32)
{
40031d6e:	55                   	push   %ebp
40031d6f:	89 e5                	mov    %esp,%ebp
40031d71:	57                   	push   %edi
40031d72:	56                   	push   %esi
40031d73:	53                   	push   %ebx
40031d74:	83 ec 08             	sub    $0x8,%esp
40031d77:	89 c3                	mov    %eax,%ebx
40031d79:	8b 45 0c             	mov    0xc(%ebp),%eax
40031d7c:	89 45 f0             	mov    %eax,-0x10(%ebp)
 *
 * @return nonzero if the buffer is empty
 */
static inline int sys_ring_buf_is_empty(struct ring_buf *buf)
{
	return (buf->head == buf->tail);
40031d7f:	8b 73 04             	mov    0x4(%ebx),%esi
40031d82:	8a 45 f0             	mov    -0x10(%ebp),%al
40031d85:	88 45 ef             	mov    %al,-0x11(%ebp)
40031d88:	8b 03                	mov    (%ebx),%eax
 * @param buf Ring buffer to examine
 * @return Available space in the buffer in 32-bit chunks
 */
static inline int sys_ring_buf_space_get(struct ring_buf *buf)
{
	if (sys_ring_buf_is_empty(buf)) {
40031d8a:	39 f0                	cmp    %esi,%eax
40031d8c:	75 06                	jne    40031d94 <sys_ring_buf_put+0x26>
		return buf->size - 1;
40031d8e:	8b 43 0c             	mov    0xc(%ebx),%eax
40031d91:	48                   	dec    %eax
40031d92:	eb 08                	jmp    40031d9c <sys_ring_buf_put+0x2e>
	}

	if (buf->tail < buf->head) {
40031d94:	77 03                	ja     40031d99 <sys_ring_buf_put+0x2b>
		return buf->head - buf->tail - 1;
	}

	/* buf->tail > buf->head */
	return (buf->size - buf->tail) + buf->head - 1;
40031d96:	03 43 0c             	add    0xc(%ebx),%eax
40031d99:	48                   	dec    %eax
40031d9a:	29 f0                	sub    %esi,%eax
	uint32_t i, space, index, rc;

	space = sys_ring_buf_space_get(buf);
	if (space >= (size32 + 1)) {
40031d9c:	0f b6 7d f0          	movzbl -0x10(%ebp),%edi
40031da0:	47                   	inc    %edi
40031da1:	39 f8                	cmp    %edi,%eax
40031da3:	72 7c                	jb     40031e21 <sys_ring_buf_put+0xb3>
		struct ring_element *header =
				(struct ring_element *)&buf->buf[buf->tail];
40031da5:	8b 7b 10             	mov    0x10(%ebx),%edi
{
	uint32_t i, space, index, rc;

	space = sys_ring_buf_space_get(buf);
	if (space >= (size32 + 1)) {
		struct ring_element *header =
40031da8:	8d 04 b7             	lea    (%edi,%esi,4),%eax
				(struct ring_element *)&buf->buf[buf->tail];
		header->type = type;
40031dab:	66 89 10             	mov    %dx,(%eax)
		header->length = size32;
40031dae:	8a 55 f0             	mov    -0x10(%ebp),%dl
40031db1:	88 50 02             	mov    %dl,0x2(%eax)
		header->value = value;
40031db4:	88 48 03             	mov    %cl,0x3(%eax)

		if (likely(buf->mask)) {
			for (i = 0; i < size32; ++i) {
40031db7:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
40031dbb:	31 c0                	xor    %eax,%eax
				(struct ring_element *)&buf->buf[buf->tail];
		header->type = type;
		header->length = size32;
		header->value = value;

		if (likely(buf->mask)) {
40031dbd:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
40031dc1:	75 06                	jne    40031dc9 <sys_ring_buf_put+0x5b>
40031dc3:	31 f6                	xor    %esi,%esi
				index = (i + buf->tail + 1) & buf->mask;
				buf->buf[index] = data[i];
			}
			buf->tail = (buf->tail + size32 + 1) & buf->mask;
		} else {
			for (i = 0; i < size32; ++i) {
40031dc5:	89 d1                	mov    %edx,%ecx
40031dc7:	eb 26                	jmp    40031def <sys_ring_buf_put+0x81>
		header->type = type;
		header->length = size32;
		header->value = value;

		if (likely(buf->mask)) {
			for (i = 0; i < size32; ++i) {
40031dc9:	39 d0                	cmp    %edx,%eax
40031dcb:	8b 4b 04             	mov    0x4(%ebx),%ecx
40031dce:	73 13                	jae    40031de3 <sys_ring_buf_put+0x75>
				index = (i + buf->tail + 1) & buf->mask;
				buf->buf[index] = data[i];
40031dd0:	8d 4c 08 01          	lea    0x1(%eax,%ecx,1),%ecx
40031dd4:	8b 75 08             	mov    0x8(%ebp),%esi
40031dd7:	23 4b 14             	and    0x14(%ebx),%ecx
40031dda:	8b 34 86             	mov    (%esi,%eax,4),%esi
		header->type = type;
		header->length = size32;
		header->value = value;

		if (likely(buf->mask)) {
			for (i = 0; i < size32; ++i) {
40031ddd:	40                   	inc    %eax
				index = (i + buf->tail + 1) & buf->mask;
				buf->buf[index] = data[i];
40031dde:	89 34 8f             	mov    %esi,(%edi,%ecx,4)
40031de1:	eb e6                	jmp    40031dc9 <sys_ring_buf_put+0x5b>
			}
			buf->tail = (buf->tail + size32 + 1) & buf->mask;
40031de3:	8d 44 11 01          	lea    0x1(%ecx,%edx,1),%eax
40031de7:	23 43 14             	and    0x14(%ebx),%eax
40031dea:	89 43 04             	mov    %eax,0x4(%ebx)
40031ded:	eb 2e                	jmp    40031e1d <sys_ring_buf_put+0xaf>
		} else {
			for (i = 0; i < size32; ++i) {
40031def:	39 ce                	cmp    %ecx,%esi
40031df1:	8b 43 04             	mov    0x4(%ebx),%eax
40031df4:	73 1b                	jae    40031e11 <sys_ring_buf_put+0xa3>
				index = (i + buf->tail + 1) % buf->size;
				buf->buf[index] = data[i];
40031df6:	8b 55 08             	mov    0x8(%ebp),%edx
40031df9:	8d 44 06 01          	lea    0x1(%esi,%eax,1),%eax
40031dfd:	8b 14 b2             	mov    (%edx,%esi,4),%edx
				index = (i + buf->tail + 1) & buf->mask;
				buf->buf[index] = data[i];
			}
			buf->tail = (buf->tail + size32 + 1) & buf->mask;
		} else {
			for (i = 0; i < size32; ++i) {
40031e00:	46                   	inc    %esi
				index = (i + buf->tail + 1) % buf->size;
				buf->buf[index] = data[i];
40031e01:	89 55 f0             	mov    %edx,-0x10(%ebp)
40031e04:	31 d2                	xor    %edx,%edx
40031e06:	f7 73 0c             	divl   0xc(%ebx)
40031e09:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031e0c:	89 04 97             	mov    %eax,(%edi,%edx,4)
40031e0f:	eb de                	jmp    40031def <sys_ring_buf_put+0x81>
			}
			buf->tail = (buf->tail + size32 + 1) % buf->size;
40031e11:	8d 44 08 01          	lea    0x1(%eax,%ecx,1),%eax
40031e15:	31 d2                	xor    %edx,%edx
40031e17:	f7 73 0c             	divl   0xc(%ebx)
40031e1a:	89 53 04             	mov    %edx,0x4(%ebx)
		}
		rc = 0;
40031e1d:	31 c0                	xor    %eax,%eax
40031e1f:	eb 08                	jmp    40031e29 <sys_ring_buf_put+0xbb>
	} else {
		buf->dropped_put_count++;
40031e21:	ff 43 08             	incl   0x8(%ebx)
		rc = -EMSGSIZE;
40031e24:	b8 dc ff ff ff       	mov    $0xffffffdc,%eax
	}

	return rc;
}
40031e29:	5a                   	pop    %edx
40031e2a:	59                   	pop    %ecx
40031e2b:	5b                   	pop    %ebx
40031e2c:	5e                   	pop    %esi
40031e2d:	5f                   	pop    %edi
40031e2e:	5d                   	pop    %ebp
40031e2f:	c3                   	ret    

40031e30 <sys_ring_buf_get>:

int sys_ring_buf_get(struct ring_buf *buf, uint16_t *type, uint8_t *value,
		     uint32_t *data, uint8_t *size32)
{
40031e30:	55                   	push   %ebp
40031e31:	89 e5                	mov    %esp,%ebp
40031e33:	57                   	push   %edi
40031e34:	56                   	push   %esi
40031e35:	53                   	push   %ebx
40031e36:	89 c3                	mov    %eax,%ebx
 *
 * @return nonzero if the buffer is empty
 */
static inline int sys_ring_buf_is_empty(struct ring_buf *buf)
{
	return (buf->head == buf->tail);
40031e38:	8b 00                	mov    (%eax),%eax
40031e3a:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct ring_element *header;
	uint32_t i, index;

	if (sys_ring_buf_is_empty(buf)) {
40031e3d:	3b 43 04             	cmp    0x4(%ebx),%eax
40031e40:	0f 84 84 00 00 00    	je     40031eca <sys_ring_buf_get+0x9a>
40031e46:	89 d7                	mov    %edx,%edi
		return -EAGAIN;
	}

	header = (struct ring_element *) &buf->buf[buf->head];
40031e48:	8b 53 10             	mov    0x10(%ebx),%edx
40031e4b:	8d 04 82             	lea    (%edx,%eax,4),%eax

	if (header->length > *size32) {
40031e4e:	8a 50 02             	mov    0x2(%eax),%dl
40031e51:	3a 16                	cmp    (%esi),%dl
		*size32 = header->length;
40031e53:	88 16                	mov    %dl,(%esi)
		return -EAGAIN;
	}

	header = (struct ring_element *) &buf->buf[buf->head];

	if (header->length > *size32) {
40031e55:	76 07                	jbe    40031e5e <sys_ring_buf_get+0x2e>
		*size32 = header->length;
		return -EMSGSIZE;
40031e57:	b8 dc ff ff ff       	mov    $0xffffffdc,%eax
40031e5c:	eb 71                	jmp    40031ecf <sys_ring_buf_get+0x9f>
	}

	*size32 = header->length;
	*type = header->type;
40031e5e:	8b 10                	mov    (%eax),%edx
40031e60:	66 89 17             	mov    %dx,(%edi)
	*value = header->value;
40031e63:	8a 50 03             	mov    0x3(%eax),%dl
40031e66:	88 11                	mov    %dl,(%ecx)

	if (likely(buf->mask)) {
		for (i = 0; i < header->length; ++i) {
40031e68:	31 d2                	xor    %edx,%edx
			index = (i + buf->head + 1) & buf->mask;
			data[i] = buf->buf[index];
		}
		buf->head = (buf->head + header->length + 1) & buf->mask;
	} else {
		for (i = 0; i < header->length; ++i) {
40031e6a:	31 c9                	xor    %ecx,%ecx
40031e6c:	0f b6 70 02          	movzbl 0x2(%eax),%esi

	*size32 = header->length;
	*type = header->type;
	*value = header->value;

	if (likely(buf->mask)) {
40031e70:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
40031e74:	74 27                	je     40031e9d <sys_ring_buf_get+0x6d>
		for (i = 0; i < header->length; ++i) {
40031e76:	39 f2                	cmp    %esi,%edx
40031e78:	8b 03                	mov    (%ebx),%eax
40031e7a:	73 16                	jae    40031e92 <sys_ring_buf_get+0x62>
			index = (i + buf->head + 1) & buf->mask;
			data[i] = buf->buf[index];
40031e7c:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
40031e80:	8b 4b 10             	mov    0x10(%ebx),%ecx
40031e83:	23 43 14             	and    0x14(%ebx),%eax
40031e86:	8b 7d 08             	mov    0x8(%ebp),%edi
40031e89:	8b 04 81             	mov    (%ecx,%eax,4),%eax
40031e8c:	89 04 97             	mov    %eax,(%edi,%edx,4)
	*size32 = header->length;
	*type = header->type;
	*value = header->value;

	if (likely(buf->mask)) {
		for (i = 0; i < header->length; ++i) {
40031e8f:	42                   	inc    %edx
40031e90:	eb e4                	jmp    40031e76 <sys_ring_buf_get+0x46>
			index = (i + buf->head + 1) & buf->mask;
			data[i] = buf->buf[index];
		}
		buf->head = (buf->head + header->length + 1) & buf->mask;
40031e92:	8d 44 06 01          	lea    0x1(%esi,%eax,1),%eax
40031e96:	23 43 14             	and    0x14(%ebx),%eax
40031e99:	89 03                	mov    %eax,(%ebx)
40031e9b:	eb 29                	jmp    40031ec6 <sys_ring_buf_get+0x96>
	} else {
		for (i = 0; i < header->length; ++i) {
40031e9d:	39 f1                	cmp    %esi,%ecx
40031e9f:	8b 03                	mov    (%ebx),%eax
40031ea1:	73 18                	jae    40031ebb <sys_ring_buf_get+0x8b>
			index = (i + buf->head + 1) % buf->size;
			data[i] = buf->buf[index];
40031ea3:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
40031ea7:	31 d2                	xor    %edx,%edx
40031ea9:	f7 73 0c             	divl   0xc(%ebx)
40031eac:	8b 43 10             	mov    0x10(%ebx),%eax
40031eaf:	8b 7d 08             	mov    0x8(%ebp),%edi
40031eb2:	8b 04 90             	mov    (%eax,%edx,4),%eax
40031eb5:	89 04 8f             	mov    %eax,(%edi,%ecx,4)
			index = (i + buf->head + 1) & buf->mask;
			data[i] = buf->buf[index];
		}
		buf->head = (buf->head + header->length + 1) & buf->mask;
	} else {
		for (i = 0; i < header->length; ++i) {
40031eb8:	41                   	inc    %ecx
40031eb9:	eb e2                	jmp    40031e9d <sys_ring_buf_get+0x6d>
			index = (i + buf->head + 1) % buf->size;
			data[i] = buf->buf[index];
		}
		buf->head = (buf->head + header->length + 1) % buf->size;
40031ebb:	8d 44 06 01          	lea    0x1(%esi,%eax,1),%eax
40031ebf:	31 d2                	xor    %edx,%edx
40031ec1:	f7 73 0c             	divl   0xc(%ebx)
40031ec4:	89 13                	mov    %edx,(%ebx)
	}

	return 0;
40031ec6:	31 c0                	xor    %eax,%eax
40031ec8:	eb 05                	jmp    40031ecf <sys_ring_buf_get+0x9f>
{
	struct ring_element *header;
	uint32_t i, index;

	if (sys_ring_buf_is_empty(buf)) {
		return -EAGAIN;
40031eca:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
		}
		buf->head = (buf->head + header->length + 1) % buf->size;
	}

	return 0;
}
40031ecf:	5b                   	pop    %ebx
40031ed0:	5e                   	pop    %esi
40031ed1:	5f                   	pop    %edi
40031ed2:	5d                   	pop    %ebp
40031ed3:	c3                   	ret    

40031ed4 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
40031ed4:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40031ed5:	31 c0                	xor    %eax,%eax
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
40031ed7:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40031ed9:	5d                   	pop    %ebp
40031eda:	c3                   	ret    

40031edb <_printk_dec_ulong>:
 * @param num Number to output
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num)
{
40031edb:	55                   	push   %ebp
40031edc:	89 e5                	mov    %esp,%ebp
40031ede:	57                   	push   %edi
	unsigned long pos = 999999999;
	unsigned long remainder = num;
40031edf:	bf 09 00 00 00       	mov    $0x9,%edi
 * @param num Number to output
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num)
{
40031ee4:	56                   	push   %esi
40031ee5:	53                   	push   %ebx
	unsigned long pos = 999999999;
40031ee6:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
 * @param num Number to output
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num)
{
40031eeb:	51                   	push   %ecx
40031eec:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned long pos = 999999999;
	unsigned long remainder = num;
	int found_largest_digit = 0;
40031eef:	31 c9                	xor    %ecx,%ecx

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
40031ef1:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
40031ef4:	8d 73 01             	lea    0x1(%ebx),%esi
40031ef7:	72 0b                	jb     40031f04 <_printk_dec_ulong+0x29>
40031ef9:	88 c8                	mov    %cl,%al
40031efb:	31 c9                	xor    %ecx,%ecx
40031efd:	83 e0 01             	and    $0x1,%eax
40031f00:	84 c0                	test   %al,%al
40031f02:	74 15                	je     40031f19 <_printk_dec_ulong+0x3e>
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
40031f04:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031f07:	31 d2                	xor    %edx,%edx
40031f09:	f7 f6                	div    %esi
40031f0b:	83 c0 30             	add    $0x30,%eax
40031f0e:	ff 15 4c 64 00 a8    	call   *0xa800644c
	unsigned long remainder = num;
	int found_largest_digit = 0;

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
40031f14:	b9 01 00 00 00       	mov    $0x1,%ecx
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
40031f19:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031f1c:	31 d2                	xor    %edx,%edx
40031f1e:	f7 f6                	div    %esi
40031f20:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
40031f23:	89 d8                	mov    %ebx,%eax
40031f25:	31 d2                	xor    %edx,%edx
40031f27:	be 0a 00 00 00       	mov    $0xa,%esi
40031f2c:	f7 f6                	div    %esi
{
	unsigned long pos = 999999999;
	unsigned long remainder = num;
	int found_largest_digit = 0;

	while (pos >= 9) {
40031f2e:	4f                   	dec    %edi
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
		pos /= 10;
40031f2f:	89 c3                	mov    %eax,%ebx
{
	unsigned long pos = 999999999;
	unsigned long remainder = num;
	int found_largest_digit = 0;

	while (pos >= 9) {
40031f31:	75 be                	jne    40031ef1 <_printk_dec_ulong+0x16>
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
		pos /= 10;
	}
	_char_out((int)(remainder + 48));
40031f33:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
40031f36:	5a                   	pop    %edx
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
		pos /= 10;
	}
	_char_out((int)(remainder + 48));
40031f37:	83 c0 30             	add    $0x30,%eax
}
40031f3a:	5b                   	pop    %ebx
40031f3b:	5e                   	pop    %esi
40031f3c:	5f                   	pop    %edi
40031f3d:	5d                   	pop    %ebp
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
		pos /= 10;
	}
	_char_out((int)(remainder + 48));
40031f3e:	ff 25 4c 64 00 a8    	jmp    *0xa800644c

40031f44 <__printk_hook_install>:
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
40031f44:	55                   	push   %ebp
	_char_out = fn;
40031f45:	a3 4c 64 00 a8       	mov    %eax,0xa800644c
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
40031f4a:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
}
40031f4c:	5d                   	pop    %ebp
40031f4d:	c3                   	ret    

40031f4e <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
40031f4e:	55                   	push   %ebp
40031f4f:	89 e5                	mov    %esp,%ebp
40031f51:	57                   	push   %edi
40031f52:	56                   	push   %esi
40031f53:	53                   	push   %ebx
40031f54:	52                   	push   %edx
	va_list ap;

	va_start(ap, fmt);
40031f55:	8d 5d 0c             	lea    0xc(%ebp),%ebx
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
40031f58:	8b 75 08             	mov    0x8(%ebp),%esi
 *
 * @return N/A
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
40031f5b:	31 ff                	xor    %edi,%edi

	/* fmt has already been adjusted if needed */

	while (*fmt) {
40031f5d:	0f be 06             	movsbl (%esi),%eax
40031f60:	84 c0                	test   %al,%al
40031f62:	0f 84 03 01 00 00    	je     4003206b <printk+0x11d>
		if (!might_format) {
40031f68:	85 ff                	test   %edi,%edi
40031f6a:	75 13                	jne    40031f7f <printk+0x31>
			if (*fmt != '%') {
40031f6c:	3c 25                	cmp    $0x25,%al
40031f6e:	0f 84 ec 00 00 00    	je     40032060 <printk+0x112>
				_char_out((int)*fmt);
40031f74:	ff 15 4c 64 00 a8    	call   *0xa800644c
40031f7a:	e9 e6 00 00 00       	jmp    40032065 <printk+0x117>
			} else {
				might_format = 1;
			}
		} else {
			switch (*fmt) {
40031f7f:	3c 69                	cmp    $0x69,%al
40031f81:	74 42                	je     40031fc5 <printk+0x77>
40031f83:	7f 29                	jg     40031fae <printk+0x60>
40031f85:	3c 58                	cmp    $0x58,%al
40031f87:	74 62                	je     40031feb <printk+0x9d>
40031f89:	7f 12                	jg     40031f9d <printk+0x4f>
40031f8b:	3c 25                	cmp    $0x25,%al
40031f8d:	0f 85 b5 00 00 00    	jne    40032048 <printk+0xfa>

				_char_out(c);
				break;
			}
			case '%': {
				_char_out((int)'%');
40031f93:	b8 25 00 00 00       	mov    $0x25,%eax
40031f98:	e9 b9 00 00 00       	jmp    40032056 <printk+0x108>
				_char_out((int)*fmt);
			} else {
				might_format = 1;
			}
		} else {
			switch (*fmt) {
40031f9d:	3c 63                	cmp    $0x63,%al
40031f9f:	0f 84 94 00 00 00    	je     40032039 <printk+0xeb>
40031fa5:	3c 64                	cmp    $0x64,%al
40031fa7:	74 1c                	je     40031fc5 <printk+0x77>
40031fa9:	e9 9a 00 00 00       	jmp    40032048 <printk+0xfa>
40031fae:	3c 73                	cmp    $0x73,%al
40031fb0:	74 72                	je     40032024 <printk+0xd6>
40031fb2:	7f 04                	jg     40031fb8 <printk+0x6a>
40031fb4:	3c 70                	cmp    $0x70,%al
40031fb6:	eb 06                	jmp    40031fbe <printk+0x70>
40031fb8:	3c 75                	cmp    $0x75,%al
40031fba:	74 23                	je     40031fdf <printk+0x91>
40031fbc:	3c 78                	cmp    $0x78,%al
40031fbe:	74 2b                	je     40031feb <printk+0x9d>
40031fc0:	e9 83 00 00 00       	jmp    40032048 <printk+0xfa>
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
40031fc5:	8d 7b 04             	lea    0x4(%ebx),%edi
40031fc8:	8b 1b                	mov    (%ebx),%ebx

				if (d < 0) {
40031fca:	85 db                	test   %ebx,%ebx
40031fcc:	79 0d                	jns    40031fdb <printk+0x8d>
					_char_out((int)'-');
40031fce:	b8 2d 00 00 00       	mov    $0x2d,%eax
40031fd3:	ff 15 4c 64 00 a8    	call   *0xa800644c
					d = -d;
40031fd9:	f7 db                	neg    %ebx
				}
				_printk_dec_ulong(d);
40031fdb:	89 d8                	mov    %ebx,%eax
40031fdd:	eb 05                	jmp    40031fe4 <printk+0x96>
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
40031fdf:	8d 7b 04             	lea    0x4(%ebx),%edi
					ap, unsigned long);
				_printk_dec_ulong(u);
40031fe2:	8b 03                	mov    (%ebx),%eax
40031fe4:	e8 f2 fe ff ff       	call   40031edb <_printk_dec_ulong>
40031fe9:	eb 59                	jmp    40032044 <printk+0xf6>
				break;
			}
			case 'x':
			case 'X':
			case 'p': {
				unsigned long x = va_arg(
40031feb:	8b 03                	mov    (%ebx),%eax
40031fed:	8d 7b 04             	lea    0x4(%ebx),%edi
40031ff0:	89 45 f0             	mov    %eax,-0x10(%ebp)
 *
 * @return N/A
 */
static void _printk_hex_ulong(const unsigned long num)
{
	int size = sizeof(num) * 2;
40031ff3:	bb 08 00 00 00       	mov    $0x8,%ebx

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);
40031ff8:	4b                   	dec    %ebx
40031ff9:	8b 45 f0             	mov    -0x10(%ebp),%eax
40031ffc:	8d 0c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%ecx
40032003:	d3 e8                	shr    %cl,%eax
40032005:	83 e0 0f             	and    $0xf,%eax
		nibble += nibble > 9 ? 87 : 48;
40032008:	3c 09                	cmp    $0x9,%al
4003200a:	0f 9f c1             	setg   %cl
4003200d:	49                   	dec    %ecx
4003200e:	83 e1 d9             	and    $0xffffffd9,%ecx
		_char_out((int)nibble);
40032011:	8d 44 08 57          	lea    0x57(%eax,%ecx,1),%eax
40032015:	0f b6 c0             	movzbl %al,%eax
40032018:	ff 15 4c 64 00 a8    	call   *0xa800644c
 */
static void _printk_hex_ulong(const unsigned long num)
{
	int size = sizeof(num) * 2;

	for (; size; size--) {
4003201e:	85 db                	test   %ebx,%ebx
40032020:	75 d6                	jne    40031ff8 <printk+0xaa>
40032022:	eb 20                	jmp    40032044 <printk+0xf6>
					ap, unsigned long);
				_printk_hex_ulong(x);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
40032024:	8d 7b 04             	lea    0x4(%ebx),%edi
40032027:	8b 1b                	mov    (%ebx),%ebx

				while (*s)
40032029:	0f be 03             	movsbl (%ebx),%eax
4003202c:	84 c0                	test   %al,%al
4003202e:	74 14                	je     40032044 <printk+0xf6>
					_char_out((int)(*s++));
40032030:	43                   	inc    %ebx
40032031:	ff 15 4c 64 00 a8    	call   *0xa800644c
40032037:	eb f0                	jmp    40032029 <printk+0xdb>
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);

				_char_out(c);
40032039:	8b 03                	mov    (%ebx),%eax
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
4003203b:	8d 7b 04             	lea    0x4(%ebx),%edi

				_char_out(c);
4003203e:	ff 15 4c 64 00 a8    	call   *0xa800644c
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
40032044:	89 fb                	mov    %edi,%ebx
40032046:	eb 14                	jmp    4003205c <printk+0x10e>
			case '%': {
				_char_out((int)'%');
				break;
			}
			default:
				_char_out((int)'%');
40032048:	b8 25 00 00 00       	mov    $0x25,%eax
4003204d:	ff 15 4c 64 00 a8    	call   *0xa800644c
				_char_out((int)*fmt);
40032053:	0f be 06             	movsbl (%esi),%eax
40032056:	ff 15 4c 64 00 a8    	call   *0xa800644c
				break;
			}
			might_format = 0;
4003205c:	31 ff                	xor    %edi,%edi
4003205e:	eb 05                	jmp    40032065 <printk+0x117>
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				_char_out((int)*fmt);
			} else {
				might_format = 1;
40032060:	bf 01 00 00 00       	mov    $0x1,%edi
				break;
			}
			might_format = 0;
		}

		++fmt;
40032065:	46                   	inc    %esi
40032066:	e9 f2 fe ff ff       	jmp    40031f5d <printk+0xf>
	va_list ap;

	va_start(ap, fmt);
	_vprintk(fmt, ap);
	va_end(ap);
}
4003206b:	58                   	pop    %eax
4003206c:	5b                   	pop    %ebx
4003206d:	5e                   	pop    %esi
4003206e:	5f                   	pop    %edi
4003206f:	5d                   	pop    %ebp
40032070:	c3                   	ret    

40032071 <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
40032071:	55                   	push   %ebp
40032072:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_BOARD_ARDUINO_101, 1);
GEN_ABSOLUTE_SYM(CONFIG_UART_NS16550_PORT_1_OPTIONS, 0);
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
40032074:	5d                   	pop    %ebp
40032075:	c3                   	ret    

40032076 <_mem_safe_region_add>:
	return 0;
}
#endif /* CONFIG_XIP */

int _mem_safe_region_add(void *addr, size_t num_bytes, int perm)
{
40032076:	55                   	push   %ebp
40032077:	89 e5                	mov    %esp,%ebp
40032079:	57                   	push   %edi
4003207a:	56                   	push   %esi
	if (unlikely(!is_perm_valid(perm))) {
4003207b:	89 ce                	mov    %ecx,%esi
4003207d:	83 e6 fe             	and    $0xfffffffe,%esi
	return 0;
}
#endif /* CONFIG_XIP */

int _mem_safe_region_add(void *addr, size_t num_bytes, int perm)
{
40032080:	53                   	push   %ebx
40032081:	53                   	push   %ebx
	if (unlikely(!is_perm_valid(perm))) {
40032082:	75 53                	jne    400320d7 <_mem_safe_region_add+0x61>

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
40032084:	9c                   	pushf  
40032085:	fa                   	cli    
40032086:	8f 45 f0             	popl   -0x10(%ebp)
	}

	int slot;
	int key = irq_lock();

	if (unlikely(ro_end > rw_end)) {
40032089:	8b 1d 60 65 00 a8    	mov    0xa8006560,%ebx
4003208f:	8b 3d 50 64 00 a8    	mov    0xa8006450,%edi
40032095:	39 fb                	cmp    %edi,%ebx
40032097:	7e 07                	jle    400320a0 <_mem_safe_region_add+0x2a>
		irq_unlock(key);
		return -ENOMEM;
40032099:	be f4 ff ff ff       	mov    $0xfffffff4,%esi
4003209e:	eb 2b                	jmp    400320cb <_mem_safe_region_add+0x55>
	}

	if (perm == SYS_MEM_SAFE_WRITE) {
400320a0:	49                   	dec    %ecx
400320a1:	75 0d                	jne    400320b0 <_mem_safe_region_add+0x3a>
		slot = rw_end;
		--rw_end;
400320a3:	8d 4f ff             	lea    -0x1(%edi),%ecx
400320a6:	89 fb                	mov    %edi,%ebx
400320a8:	89 0d 50 64 00 a8    	mov    %ecx,0xa8006450
400320ae:	eb 09                	jmp    400320b9 <_mem_safe_region_add+0x43>
	} else {
		slot = ro_end;
		++ro_end;
400320b0:	8d 4b 01             	lea    0x1(%ebx),%ecx
400320b3:	89 0d 60 65 00 a8    	mov    %ecx,0xa8006560
	}

	mem_regions[slot].addr = (vaddr_t)addr;
400320b9:	89 04 dd ec 6b 00 a8 	mov    %eax,-0x57ff9414(,%ebx,8)
	mem_regions[slot].last_byte = mem_regions[slot].addr + num_bytes - 1;
400320c0:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
400320c4:	89 04 dd f0 6b 00 a8 	mov    %eax,-0x57ff9410(,%ebx,8)
400320cb:	f7 45 f0 00 02 00 00 	testl  $0x200,-0x10(%ebp)
400320d2:	74 08                	je     400320dc <_mem_safe_region_add+0x66>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
400320d4:	fb                   	sti    
400320d5:	eb 05                	jmp    400320dc <_mem_safe_region_add+0x66>
#endif /* CONFIG_XIP */

int _mem_safe_region_add(void *addr, size_t num_bytes, int perm)
{
	if (unlikely(!is_perm_valid(perm))) {
		return -EINVAL;
400320d7:	be ea ff ff ff       	mov    $0xffffffea,%esi
	mem_regions[slot].last_byte = mem_regions[slot].addr + num_bytes - 1;

	irq_unlock(key);

	return 0;
}
400320dc:	5a                   	pop    %edx
400320dd:	89 f0                	mov    %esi,%eax
400320df:	5b                   	pop    %ebx
400320e0:	5e                   	pop    %esi
400320e1:	5f                   	pop    %edi
400320e2:	5d                   	pop    %ebp
400320e3:	c3                   	ret    

400320e4 <init>:

static int init(struct device *unused)
{
400320e4:	55                   	push   %ebp

	ARG_UNUSED(unused);

	addr = (void *)IMAGE_ROM_START;
	num_bytes = (int)(IMAGE_ROM_END - IMAGE_ROM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_READ);
400320e5:	ba 40 33 03 40       	mov    $0x40033340,%edx

	return 0;
}

static int init(struct device *unused)
{
400320ea:	89 e5                	mov    %esp,%ebp

	ARG_UNUSED(unused);

	addr = (void *)IMAGE_ROM_START;
	num_bytes = (int)(IMAGE_ROM_END - IMAGE_ROM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_READ);
400320ec:	81 ea 00 00 03 40    	sub    $0x40030000,%edx
400320f2:	31 c9                	xor    %ecx,%ecx
400320f4:	b8 00 00 03 40       	mov    $0x40030000,%eax
400320f9:	e8 78 ff ff ff       	call   40032076 <_mem_safe_region_add>

	addr = (void *)IMAGE_RAM_START;
	num_bytes = (int)(IMAGE_RAM_END - IMAGE_RAM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_WRITE);
400320fe:	ba 80 78 00 a8       	mov    $0xa8007880,%edx
40032103:	81 ea 00 64 00 a8    	sub    $0xa8006400,%edx
40032109:	b9 01 00 00 00       	mov    $0x1,%ecx
4003210e:	b8 00 64 00 a8       	mov    $0xa8006400,%eax
40032113:	e8 5e ff ff ff       	call   40032076 <_mem_safe_region_add>

	return 0;
}
40032118:	31 c0                	xor    %eax,%eax
4003211a:	5d                   	pop    %ebp
4003211b:	c3                   	ret    

4003211c <_quark_se_set_mux>:
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
	}
}

static uint32_t _quark_se_set_mux(uint32_t base, uint32_t pin, uint8_t func)
{
4003211c:	55                   	push   %ebp
4003211d:	89 e5                	mov    %esp,%ebp
4003211f:	57                   	push   %edi
40032120:	56                   	push   %esi
40032121:	53                   	push   %ebx
40032122:	89 cb                	mov    %ecx,%ebx
	uint32_t register_offset = (pin / 32) * 4;
	/*
	 * Now figure out what is the full address for the register
	 * we are looking for.  Add the base register to the register_mask
	 */
	volatile uint32_t *mux_register = (uint32_t *)(base + register_offset);
40032124:	89 d1                	mov    %edx,%ecx
40032126:	c1 e9 05             	shr    $0x5,%ecx

	/*
	 * Finally grab the pin offset within the register
	 */
	uint32_t pin_offset = pin % 32;
40032129:	83 e2 1f             	and    $0x1f,%edx
	uint32_t register_offset = (pin / 32) * 4;
	/*
	 * Now figure out what is the full address for the register
	 * we are looking for.  Add the base register to the register_mask
	 */
	volatile uint32_t *mux_register = (uint32_t *)(base + register_offset);
4003212c:	8d 34 88             	lea    (%eax,%ecx,4),%esi

	/*
	 * Finally grab the pin offset within the register
	 */
	uint32_t pin_offset = pin % 32;
4003212f:	89 d1                	mov    %edx,%ecx

	/*
	 * MAGIC NUMBER: 0x1 is used as the pullup is a single bit in a
	 * 32-bit register.
	 */
	(*(mux_register)) = ((*(mux_register)) & ~(0x1 << pin_offset)) |
40032131:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
40032136:	89 d7                	mov    %edx,%edi
40032138:	8b 06                	mov    (%esi),%eax
4003213a:	d3 c7                	rol    %cl,%edi
4003213c:	21 c7                	and    %eax,%edi
4003213e:	89 d8                	mov    %ebx,%eax
40032140:	83 e0 01             	and    $0x1,%eax
40032143:	d3 e0                	shl    %cl,%eax
40032145:	09 f8                	or     %edi,%eax
40032147:	89 06                	mov    %eax,(%esi)
		((func & 0x01) << pin_offset);

	return DEV_OK;
}
40032149:	31 c0                	xor    %eax,%eax
4003214b:	5b                   	pop    %ebx
4003214c:	5e                   	pop    %esi
4003214d:	5f                   	pop    %edi
4003214e:	5d                   	pop    %ebp
4003214f:	c3                   	ret    

40032150 <pinmux_dev_set>:

	return DEV_OK;
}
#else
static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
{
40032150:	55                   	push   %ebp
	ARG_UNUSED(func);

	PRINT("ERROR: %s is not enabled", __func__);

	return DEV_NOT_CONFIG;
}
40032151:	b8 07 00 00 00       	mov    $0x7,%eax

	return DEV_OK;
}
#else
static uint32_t pinmux_dev_set(struct device *dev, uint32_t pin, uint8_t func)
{
40032156:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(func);

	PRINT("ERROR: %s is not enabled", __func__);

	return DEV_NOT_CONFIG;
}
40032158:	5d                   	pop    %ebp
40032159:	c3                   	ret    

4003215a <pinmux_dev_get>:

static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
{
4003215a:	55                   	push   %ebp
	ARG_UNUSED(func);

	PRINT("ERROR: %s is not enabled", __func__);

	return DEV_NOT_CONFIG;
}
4003215b:	b8 07 00 00 00       	mov    $0x7,%eax

	return DEV_NOT_CONFIG;
}

static uint32_t pinmux_dev_get(struct device *dev, uint32_t pin, uint8_t *func)
{
40032160:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(func);

	PRINT("ERROR: %s is not enabled", __func__);

	return DEV_NOT_CONFIG;
}
40032162:	5d                   	pop    %ebp
40032163:	c3                   	ret    

40032164 <pinmux_dev_pullup>:
#endif /* CONFIG_PINMUX_DEV */

static uint32_t pinmux_dev_pullup(struct device *dev,
				  uint32_t pin,
				  uint8_t func)
{
40032164:	55                   	push   %ebp
	struct pinmux_config * const pmux = dev->config->config_info;
40032165:	8b 00                	mov    (%eax),%eax
#endif /* CONFIG_PINMUX_DEV */

static uint32_t pinmux_dev_pullup(struct device *dev,
				  uint32_t pin,
				  uint8_t func)
{
40032167:	89 e5                	mov    %esp,%ebp
	struct pinmux_config * const pmux = dev->config->config_info;

	_quark_se_set_mux(pmux->base_address + PINMUX_PULLUP_OFFSET, pin, func);
40032169:	0f b6 c9             	movzbl %cl,%ecx
4003216c:	8b 40 08             	mov    0x8(%eax),%eax
4003216f:	8b 00                	mov    (%eax),%eax
40032171:	e8 a6 ff ff ff       	call   4003211c <_quark_se_set_mux>

	return DEV_OK;
}
40032176:	31 c0                	xor    %eax,%eax
40032178:	5d                   	pop    %ebp
40032179:	c3                   	ret    

4003217a <pinmux_dev_input>:
static uint32_t pinmux_dev_input(struct device *dev, uint32_t pin, uint8_t func)
{
4003217a:	55                   	push   %ebp
	struct pinmux_config * const pmux = dev->config->config_info;
4003217b:	8b 00                	mov    (%eax),%eax
	_quark_se_set_mux(pmux->base_address + PINMUX_PULLUP_OFFSET, pin, func);

	return DEV_OK;
}
static uint32_t pinmux_dev_input(struct device *dev, uint32_t pin, uint8_t func)
{
4003217d:	89 e5                	mov    %esp,%ebp
	struct pinmux_config * const pmux = dev->config->config_info;

	_quark_se_set_mux(pmux->base_address + PINMUX_INPUT_OFFSET, pin, func);
4003217f:	0f b6 c9             	movzbl %cl,%ecx
40032182:	8b 40 08             	mov    0x8(%eax),%eax
40032185:	8b 00                	mov    (%eax),%eax
40032187:	83 c0 20             	add    $0x20,%eax
4003218a:	e8 8d ff ff ff       	call   4003211c <_quark_se_set_mux>

	return DEV_OK;
}
4003218f:	31 c0                	xor    %eax,%eax
40032191:	5d                   	pop    %ebp
40032192:	c3                   	ret    

40032193 <pinmux_initialize>:
	.pullup = pinmux_dev_pullup,
	.input = pinmux_dev_input
};

int pinmux_initialize(struct device *port)
{
40032193:	55                   	push   %ebp
40032194:	89 e5                	mov    %esp,%ebp
40032196:	56                   	push   %esi
40032197:	53                   	push   %ebx
40032198:	83 ec 14             	sub    $0x14,%esp
	PIN_CONFIG(mux_config,  4,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config,  5,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config,  7,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config,  8,  PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  9,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 14,  PINMUX_FUNC_B);
4003219b:	c7 45 e4 55 45 06 10 	movl   $0x10064555,-0x1c(%ebp)
	.input = pinmux_dev_input
};

int pinmux_initialize(struct device *port)
{
	struct pinmux_config * const pmux = port->config->config_info;
400321a2:	8b 10                	mov    (%eax),%edx
	PIN_CONFIG(mux_config,  7,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config,  8,  PINMUX_FUNC_C);
	PIN_CONFIG(mux_config,  9,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 14,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 16,  PINMUX_FUNC_C);
	PIN_CONFIG(mux_config, 17,  PINMUX_FUNC_C);
400321a4:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%ebp)
	PIN_CONFIG(mux_config, 40,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 41,  PINMUX_FUNC_B);
400321ab:	c7 45 ec 00 00 05 00 	movl   $0x50000,-0x14(%ebp)
	PIN_CONFIG(mux_config, 55,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 56,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 57,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 63,  PINMUX_FUNC_B);
400321b2:	c7 45 f0 00 40 05 40 	movl   $0x40054000,-0x10(%ebp)
	.input = pinmux_dev_input
};

int pinmux_initialize(struct device *port)
{
	struct pinmux_config * const pmux = port->config->config_info;
400321b9:	8b 5a 08             	mov    0x8(%edx),%ebx
	PIN_CONFIG(mux_config, 56,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 57,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 63,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 64,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 65,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 66,  PINMUX_FUNC_B);
400321bc:	c7 45 f4 15 00 00 00 	movl   $0x15,-0xc(%ebp)

int pinmux_initialize(struct device *port)
{
	struct pinmux_config * const pmux = port->config->config_info;

	port->driver_api = &api_funcs;
400321c3:	c7 40 04 58 64 00 a8 	movl   $0xa8006458,0x4(%eax)
	PIN_CONFIG(mux_config, 63,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 64,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 65,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 66,  PINMUX_FUNC_B);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
400321ca:	31 c0                	xor    %eax,%eax
static inline __attribute__((always_inline))
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
			 :
			 : "r"(data), "m" (*(volatile uint32_t *) addr)
400321cc:	8b 33                	mov    (%ebx),%esi
400321ce:	8d 56 30             	lea    0x30(%esi),%edx
		PRINT("PINMUX: configuring register i=%d reg=%x", i,
		      mux_config[i]);
		sys_write32(mux_config[i], PINMUX_SELECT_REGISTER(base, i));
400321d1:	8b 4c 85 e4          	mov    -0x1c(%ebp,%eax,4),%ecx
400321d5:	8d 34 82             	lea    (%edx,%eax,4),%esi
}

static inline __attribute__((always_inline))
	void sys_write32(uint32_t data, mm_reg_t addr)
{
	__asm__ volatile("movl	%0, %1;\n\t"
400321d8:	89 0e                	mov    %ecx,(%esi)
	PIN_CONFIG(mux_config, 63,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 64,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 65,  PINMUX_FUNC_B);
	PIN_CONFIG(mux_config, 66,  PINMUX_FUNC_B);

	for (i = 0; i < PINMUX_MAX_REGISTERS; i++) {
400321da:	40                   	inc    %eax
400321db:	83 f8 05             	cmp    $0x5,%eax
400321de:	75 f1                	jne    400321d1 <pinmux_initialize+0x3e>
	return DEV_OK;
}

static inline void _pinmux_pullups(uint32_t base_address)
{
	_quark_se_set_mux(base_address + PINMUX_PULLUP_OFFSET, 104,
400321e0:	8b 03                	mov    (%ebx),%eax
400321e2:	b9 01 00 00 00       	mov    $0x1,%ecx
400321e7:	ba 68 00 00 00       	mov    $0x68,%edx
400321ec:	e8 2b ff ff ff       	call   4003211c <_quark_se_set_mux>

	_pinmux_defaults(pmux->base_address);
	_pinmux_pullups(pmux->base_address);

	return DEV_OK;
}
400321f1:	83 c4 14             	add    $0x14,%esp
400321f4:	31 c0                	xor    %eax,%eax
400321f6:	5b                   	pop    %ebx
400321f7:	5e                   	pop    %esi
400321f8:	5d                   	pop    %ebp
400321f9:	c3                   	ret    

400321fa <_Swap>:
#else
#define _sys_k_event_logger_context_switch()
#endif

unsigned int _Swap(unsigned int eflags)
{
400321fa:	55                   	push   %ebp
400321fb:	89 e5                	mov    %esp,%ebp
400321fd:	50                   	push   %eax
	struct tcs *next;
	int rv;

	/* Save the current context onto the stack */
	__asm__ volatile("pushl	%eax\n\t" /* push eflags _Swap argumet*/
400321fe:	50                   	push   %eax
400321ff:	57                   	push   %edi
40032200:	56                   	push   %esi
40032201:	53                   	push   %ebx
40032202:	55                   	push   %ebp
40032203:	53                   	push   %ebx
			 "pushl	%ebp\n\t"
			 "pushl	%ebx\n\t"); /* eax slot for fiber return */

	/* save the stack pointer into the current context structure */
	__asm__ volatile("mov %%esp, %0"
			 :"=m" (_nanokernel.current->coopReg.esp));
40032204:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
			 "pushl	%ebx\n\t"
			 "pushl	%ebp\n\t"
			 "pushl	%ebx\n\t"); /* eax slot for fiber return */

	/* save the stack pointer into the current context structure */
	__asm__ volatile("mov %%esp, %0"
40032209:	89 60 08             	mov    %esp,0x8(%eax)
			 :"=m" (_nanokernel.current->coopReg.esp));

	_sys_k_event_logger_context_switch();

	/* find the next context to run */
	if (_nanokernel.fiber) {
4003220c:	a1 64 65 00 a8       	mov    0xa8006564,%eax
40032211:	85 c0                	test   %eax,%eax
40032213:	74 0a                	je     4003221f <_Swap+0x25>
		next = _nanokernel.fiber;
		_nanokernel.fiber = (struct tcs *)_nanokernel.fiber->link;
40032215:	8b 10                	mov    (%eax),%edx
40032217:	89 15 64 65 00 a8    	mov    %edx,0xa8006564
4003221d:	eb 05                	jmp    40032224 <_Swap+0x2a>
	} else {
		next = _nanokernel.task;
4003221f:	a1 68 65 00 a8       	mov    0xa8006568,%eax
	}
	_nanokernel.current = next;
40032224:	a3 6c 65 00 a8       	mov    %eax,0xa800656c

	/* recover the stack pointer for the incoming context */
	__asm__ volatile("mov %0, %%esp"
40032229:	8b 60 08             	mov    0x8(%eax),%esp
			 :
			 :"m" (next->coopReg.esp));

	/* restore the context */
	__asm__ volatile("popl %eax\n\t"
4003222c:	58                   	pop    %eax
4003222d:	5d                   	pop    %ebp
4003222e:	5b                   	pop    %ebx
4003222f:	5e                   	pop    %esi
40032230:	5f                   	pop    %edi
40032231:	9d                   	popf   
			 );

	/* The correct return value is already in eax but this makes
	 * the compiler happy
	 */
	__asm__ volatile("mov %%eax, %0"
40032232:	89 45 fc             	mov    %eax,-0x4(%ebp)
			 :"=m" (rv)
			 );
	return rv;
}
40032235:	8b 45 fc             	mov    -0x4(%ebp),%eax
40032238:	c9                   	leave  
40032239:	c3                   	ret    

4003223a <_execute_handler>:
#endif

typedef void (*int_handler_t) (int context);

void _execute_handler(int_handler_t function, int context)
{
4003223a:	55                   	push   %ebp
	_sys_k_event_logger_interrupt();

	_sys_k_event_logger_exit_sleep();

#ifdef CONFIG_NESTED_INTERRUPTS
	if (!_nanokernel.nested)
4003223b:	8b 0d 70 65 00 a8    	mov    0xa8006570,%ecx
#endif

typedef void (*int_handler_t) (int context);

void _execute_handler(int_handler_t function, int context)
{
40032241:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_interrupt();

	_sys_k_event_logger_exit_sleep();

#ifdef CONFIG_NESTED_INTERRUPTS
	if (!_nanokernel.nested)
40032243:	85 c9                	test   %ecx,%ecx
#endif

typedef void (*int_handler_t) (int context);

void _execute_handler(int_handler_t function, int context)
{
40032245:	53                   	push   %ebx
40032246:	89 c3                	mov    %eax,%ebx
40032248:	89 d0                	mov    %edx,%eax
	_sys_k_event_logger_interrupt();

	_sys_k_event_logger_exit_sleep();

#ifdef CONFIG_NESTED_INTERRUPTS
	if (!_nanokernel.nested)
4003224a:	75 09                	jne    40032255 <_execute_handler+0x1b>
#endif
	{
		/* move to the interrupt stack and push current stack
		 * pointer onto interrupt stack
		 */
		__asm__ volatile ("movl %%esp, %%edx \n\t"
4003224c:	89 e2                	mov    %esp,%edx
4003224e:	8b 25 74 65 00 a8    	mov    0xa8006574,%esp
40032254:	52                   	push   %edx
				  :
				  :"m" (_nanokernel.common_isp)
				  :"%edx"
				 );
	}
	_nanokernel.nested++;
40032255:	41                   	inc    %ecx
40032256:	89 0d 70 65 00 a8    	mov    %ecx,0xa8006570
extern void _sys_power_save_idle_exit(int32_t ticks);

#ifdef CONFIG_NESTED_INTERRUPTS
static inline void enable_nested_interrupts(void)
{
	__asm__ volatile("sti");
4003225c:	fb                   	sti    
	}
#endif
	_int_latency_stop();
	enable_nested_interrupts();

	(*function)(context);
4003225d:	ff d3                	call   *%ebx
 * @return N/A
 */
static inline void _loapic_eoi(void)
{
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
4003225f:	e8 5a 04 00 00       	call   400326be <_lakemont_eoi>
#endif
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
40032264:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
4003226b:	00 00 00 
	__asm__ volatile("sti");
}

static inline void disable_nested_interrupts(void)
{
	__asm__ volatile("cli");
4003226e:	fa                   	cli    

	/* Are we returning to a task or fiber context? If so we need
	 * to do some work based on the context that was interrupted
	 */
#ifdef CONFIG_NESTED_INTERRUPTS
	if (!_nanokernel.nested)
4003226f:	ff 0d 70 65 00 a8    	decl   0xa8006570
40032275:	75 1c                	jne    40032293 <_execute_handler+0x59>
#endif
	{
		/* switch to kernel stack */
		__asm__ volatile ("popl %esp");
40032277:	5c                   	pop    %esp

		/* if the interrupted context was a task we need to
		 * swap back to the interrupted context
		 */
		if ((_nanokernel.current->flags & PREEMPTIBLE) &&
40032278:	a1 6c 65 00 a8       	mov    0xa800656c,%eax
4003227d:	f6 40 05 01          	testb  $0x1,0x5(%eax)
40032281:	74 10                	je     40032293 <_execute_handler+0x59>
40032283:	83 3d 64 65 00 a8 00 	cmpl   $0x0,0xa8006564
4003228a:	74 07                	je     40032293 <_execute_handler+0x59>
			_nanokernel.fiber) {
			/* move flags into arg0 we can't use local
			 * variables here since the stack may have
			 * changed.
			 */
			__asm__ volatile ("pushfl \n\t"
4003228c:	9c                   	pushf  
4003228d:	58                   	pop    %eax
4003228e:	e8 67 ff ff ff       	call   400321fa <_Swap>
					  "popl %eax \n\t"
					  "call _Swap");
		}
	}
}
40032293:	5b                   	pop    %ebx
40032294:	5d                   	pop    %ebp
40032295:	c3                   	ret    

40032296 <_SpuriousIntHandler>:

void _SpuriousIntHandler(void)
{
40032296:	55                   	push   %ebp
40032297:	89 e5                	mov    %esp,%ebp
	__asm__ volatile("cld"); /* clear direction flag */
40032299:	fc                   	cld    
	/*
	 * The task's regular stack is being used, but push the value of ESP
	 * anyway so that _ExcExit can "recover the stack pointer"
	 * without determining whether the exception occurred while CPL=3
	 */
	__asm__ volatile ("pushl %esp");
4003229a:	54                   	push   %esp

again:
	_NanoFatalErrorHandler(_NANO_ERR_SPURIOUS_INT, &_default_esf);
4003229b:	ba 80 2a 03 40       	mov    $0x40032a80,%edx
400322a0:	31 c0                	xor    %eax,%eax
400322a2:	e8 89 00 00 00       	call   40032330 <_NanoFatalErrorHandler>

400322a7 <_SpuriousIntNoErrCodeHandler>:
	/* The handler should no return but if it does call it again */
	goto again;
}

void _SpuriousIntNoErrCodeHandler(void)
{
400322a7:	55                   	push   %ebp
400322a8:	89 e5                	mov    %esp,%ebp
	__asm__ volatile ("pushl %eax");
400322aa:	50                   	push   %eax
	_SpuriousIntHandler();
400322ab:	e8 e6 ff ff ff       	call   40032296 <_SpuriousIntHandler>

400322b0 <_new_thread>:

void _new_thread(char *stack_memory, unsigned stack_size,
		 _thread_entry_t thread_func, void *parameter1,
		 void *parameter2, void *parameter3, int priority,
		 unsigned options)
{
400322b0:	55                   	push   %ebp

#ifdef CONFIG_INIT_STACKS
	memset(stack_memory, 0xaa, stack_size);
#endif

	tcs->link = (struct tcs *)NULL; /* thread not inserted into list yet */
400322b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

void _new_thread(char *stack_memory, unsigned stack_size,
		 _thread_entry_t thread_func, void *parameter1,
		 void *parameter2, void *parameter3, int priority,
		 unsigned options)
{
400322b7:	89 e5                	mov    %esp,%ebp
400322b9:	53                   	push   %ebx
400322ba:	8b 5d 14             	mov    0x14(%ebp),%ebx
#ifdef CONFIG_INIT_STACKS
	memset(stack_memory, 0xaa, stack_size);
#endif

	tcs->link = (struct tcs *)NULL; /* thread not inserted into list yet */
	tcs->prio = priority;
400322bd:	89 58 0c             	mov    %ebx,0xc(%eax)

	if (priority == -1) {
		tcs->flags = PREEMPTIBLE | TASK;
400322c0:	43                   	inc    %ebx
400322c1:	0f 95 c3             	setne  %bl
400322c4:	0f b6 db             	movzbl %bl,%ebx
400322c7:	4b                   	dec    %ebx
	tcs->custom_data = NULL;
#endif

	/* carve the thread entry struct from the "base" of the stack */

	thread_context =
400322c8:	01 c2                	add    %eax,%edx
400322ca:	83 e2 fc             	and    $0xfffffffc,%edx

	tcs->link = (struct tcs *)NULL; /* thread not inserted into list yet */
	tcs->prio = priority;

	if (priority == -1) {
		tcs->flags = PREEMPTIBLE | TASK;
400322cd:	81 e3 01 01 00 00    	and    $0x101,%ebx
400322d3:	89 58 04             	mov    %ebx,0x4(%eax)
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--thread_context = (unsigned long)parameter3;
400322d6:	8b 5d 10             	mov    0x10(%ebp),%ebx
400322d9:	89 5a fc             	mov    %ebx,-0x4(%edx)
	*--thread_context = (unsigned long)parameter2;
400322dc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
400322df:	89 5a f8             	mov    %ebx,-0x8(%edx)
	*--thread_context = (unsigned long)parameter1;
400322e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
400322e5:	89 5a f4             	mov    %ebx,-0xc(%edx)
	*--thread_context = (unsigned long)thread_func;
400322e8:	89 4a f0             	mov    %ecx,-0x10(%edx)

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--thread_context = (unsigned long)_thread_entry_wrapper;
400322eb:	c7 42 ec 28 23 03 40 	movl   $0x40032328,-0x14(%edx)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
400322f2:	9c                   	pushf  
400322f3:	59                   	pop    %ecx
	*--thread_context = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
400322f4:	80 e5 cd             	and    $0xcd,%ch
	*--thread_context = 0;
400322f7:	c7 42 e4 00 00 00 00 	movl   $0x0,-0x1c(%edx)
	*--thread_context = (unsigned long)thread_func;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--thread_context = (unsigned long)_thread_entry_wrapper;
	*--thread_context = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
400322fe:	80 cd 02             	or     $0x2,%ch
	*--thread_context = 0;
	*--thread_context = 0;
40032301:	c7 42 e0 00 00 00 00 	movl   $0x0,-0x20(%edx)
	*--thread_context = (unsigned long)thread_func;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--thread_context = (unsigned long)_thread_entry_wrapper;
	*--thread_context = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
40032308:	89 4a e8             	mov    %ecx,-0x18(%edx)
	*--thread_context = 0;
	*--thread_context = 0;
	*--thread_context = 0;
	--thread_context;
	*thread_context = (unsigned long)(thread_context + 4);
4003230b:	8d 4a e8             	lea    -0x18(%edx),%ecx

	*--thread_context = (unsigned long)_thread_entry_wrapper;
	*--thread_context = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
	*--thread_context = 0;
	*--thread_context = 0;
	*--thread_context = 0;
4003230e:	c7 42 dc 00 00 00 00 	movl   $0x0,-0x24(%edx)
	--thread_context;
	*thread_context = (unsigned long)(thread_context + 4);
40032315:	89 4a d8             	mov    %ecx,-0x28(%edx)
	*--thread_context = 0;
40032318:	c7 42 d4 00 00 00 00 	movl   $0x0,-0x2c(%edx)
4003231f:	83 ea 2c             	sub    $0x2c,%edx
		irq_unlock(imask);
	}
#endif /* CONFIG_THREAD_MONITOR */

	_nano_timeout_tcs_init(tcs);
}
40032322:	5b                   	pop    %ebx
	*--thread_context = 0;
	*--thread_context = 0;
	*--thread_context = 0;
	--thread_context;
	*thread_context = (unsigned long)(thread_context + 4);
	*--thread_context = 0;
40032323:	89 50 08             	mov    %edx,0x8(%eax)
		irq_unlock(imask);
	}
#endif /* CONFIG_THREAD_MONITOR */

	_nano_timeout_tcs_init(tcs);
}
40032326:	5d                   	pop    %ebp
40032327:	c3                   	ret    

40032328 <_thread_entry_wrapper>:
 *
 * @return N/A
 */

SECTION_FUNC(TEXT, _thread_entry_wrapper)
	popl %eax
40032328:	58                   	pop    %eax
	popl %edx
40032329:	5a                   	pop    %edx
	popl %ecx
4003232a:	59                   	pop    %ecx
	jmp _thread_entry
4003232b:	e9 e8 f7 ff ff       	jmp    40031b18 <_thread_entry>

40032330 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
40032330:	55                   	push   %ebp
40032331:	89 e5                	mov    %esp,%ebp
40032333:	57                   	push   %edi
40032334:	56                   	push   %esi
40032335:	53                   	push   %ebx
40032336:	83 ec 28             	sub    $0x28,%esp
40032339:	89 c3                	mov    %eax,%ebx
4003233b:	89 d6                	mov    %edx,%esi

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
4003233d:	83 f8 03             	cmp    $0x3,%eax
40032340:	74 1f                	je     40032361 <_NanoFatalErrorHandler+0x31>
40032342:	77 11                	ja     40032355 <_NanoFatalErrorHandler+0x25>
40032344:	85 c0                	test   %eax,%eax
40032346:	75 2d                	jne    40032375 <_NanoFatalErrorHandler+0x45>
	case _NANO_ERR_CPU_EXCEPTION:
		break;

	case _NANO_ERR_SPURIOUS_INT:
		printk("***** Unhandled interrupt vector %d occurred! "
40032348:	e8 72 e2 ff ff       	call   400305bf <_loapic_isr_vector_get>
4003234d:	50                   	push   %eax
4003234e:	68 6f 28 03 40       	push   $0x4003286f
40032353:	eb 26                	jmp    4003237b <_NanoFatalErrorHandler+0x4b>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
40032355:	83 f8 05             	cmp    $0x5,%eax
40032358:	74 0e                	je     40032368 <_NanoFatalErrorHandler+0x38>
4003235a:	83 f8 06             	cmp    $0x6,%eax
4003235d:	74 23                	je     40032382 <_NanoFatalErrorHandler+0x52>
4003235f:	eb 14                	jmp    40032375 <_NanoFatalErrorHandler+0x45>
		printk("***** Unhandled interrupt vector %d occurred! "
		       "*****\n", _loapic_isr_vector_get());
		break;

	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
40032361:	68 a4 28 03 40       	push   $0x400328a4
40032366:	eb 05                	jmp    4003236d <_NanoFatalErrorHandler+0x3d>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
40032368:	68 ce 28 03 40       	push   $0x400328ce
4003236d:	e8 dc fb ff ff       	call   40031f4e <printk>
40032372:	59                   	pop    %ecx
		break;
40032373:	eb 0d                	jmp    40032382 <_NanoFatalErrorHandler+0x52>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
40032375:	53                   	push   %ebx
40032376:	68 f4 28 03 40       	push   $0x400328f4
4003237b:	e8 ce fb ff ff       	call   40031f4e <printk>
40032380:	58                   	pop    %eax
40032381:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = 0x%x\n"
40032382:	8b 46 10             	mov    0x10(%esi),%eax
40032385:	8b 4e 2c             	mov    0x2c(%esi),%ecx
40032388:	89 45 f0             	mov    %eax,-0x10(%ebp)
4003238b:	8b 46 0c             	mov    0xc(%esi),%eax
4003238e:	89 45 ec             	mov    %eax,-0x14(%ebp)
40032391:	8b 46 14             	mov    0x14(%esi),%eax
40032394:	89 45 e8             	mov    %eax,-0x18(%ebp)
40032397:	8b 46 1c             	mov    0x1c(%esi),%eax
4003239a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
4003239d:	8b 46 08             	mov    0x8(%esi),%eax
400323a0:	89 45 e0             	mov    %eax,-0x20(%ebp)
400323a3:	8b 46 18             	mov    0x18(%esi),%eax
400323a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
400323a9:	8b 46 24             	mov    0x24(%esi),%eax
400323ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
400323af:	8b 16                	mov    (%esi),%edx
400323b1:	0f b7 46 28          	movzwl 0x28(%esi),%eax
400323b5:	89 4d cc             	mov    %ecx,-0x34(%ebp)
400323b8:	89 55 d0             	mov    %edx,-0x30(%ebp)
400323bb:	8b 7e 04             	mov    0x4(%esi),%edi
400323be:	89 45 d4             	mov    %eax,-0x2c(%ebp)
400323c1:	e8 0f f7 ff ff       	call   40031ad5 <sys_thread_self_get>
400323c6:	8b 55 d0             	mov    -0x30(%ebp),%edx
400323c9:	8b 4d cc             	mov    -0x34(%ebp),%ecx
400323cc:	51                   	push   %ecx
400323cd:	52                   	push   %edx
400323ce:	57                   	push   %edi
400323cf:	ff 75 f0             	pushl  -0x10(%ebp)
400323d2:	ff 75 ec             	pushl  -0x14(%ebp)
400323d5:	ff 75 e8             	pushl  -0x18(%ebp)
400323d8:	ff 75 e4             	pushl  -0x1c(%ebp)
400323db:	ff 75 e0             	pushl  -0x20(%ebp)
400323de:	ff 75 dc             	pushl  -0x24(%ebp)
400323e1:	ff 75 d8             	pushl  -0x28(%ebp)
400323e4:	ff 75 d4             	pushl  -0x2c(%ebp)
400323e7:	50                   	push   %eax
400323e8:	68 17 29 03 40       	push   $0x40032917
400323ed:	e8 5c fb ff ff       	call   40031f4e <printk>
400323f2:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
400323f5:	89 f2                	mov    %esi,%edx
400323f7:	89 d8                	mov    %ebx,%eax
400323f9:	e8 2d 01 00 00       	call   4003252b <_SysFatalErrorHandler>

400323fe <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
400323fe:	55                   	push   %ebp
400323ff:	89 e5                	mov    %esp,%ebp
40032401:	56                   	push   %esi
40032402:	89 c6                	mov    %eax,%esi
40032404:	53                   	push   %ebx
40032405:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
40032407:	50                   	push   %eax
40032408:	68 b8 29 03 40       	push   $0x400329b8
4003240d:	e8 3c fb ff ff       	call   40031f4e <printk>
40032412:	59                   	pop    %ecx
40032413:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
40032414:	b8 00 7d 02 00       	mov    $0x27d00,%eax
40032419:	0f a3 f0             	bt     %esi,%eax
4003241c:	73 0f                	jae    4003242d <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
4003241e:	ff 73 20             	pushl  0x20(%ebx)
40032421:	68 d0 29 03 40       	push   $0x400329d0
40032426:	e8 23 fb ff ff       	call   40031f4e <printk>
4003242b:	58                   	pop    %eax
4003242c:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
4003242d:	89 da                	mov    %ebx,%edx
4003242f:	b8 06 00 00 00       	mov    $0x6,%eax
40032434:	e8 f7 fe ff ff       	call   40032330 <_NanoFatalErrorHandler>

40032439 <handle_exc_IV_DIVIDE_ERROR>:
FUNC_NORETURN void handle_exc_##vector(const NANO_ESF *pEsf) \
{ \
	generic_exc_handle(vector, pEsf); \
}

EXC_FUNC(IV_DIVIDE_ERROR);
40032439:	55                   	push   %ebp
4003243a:	89 c2                	mov    %eax,%edx
4003243c:	89 e5                	mov    %esp,%ebp
4003243e:	31 c0                	xor    %eax,%eax
40032440:	e8 b9 ff ff ff       	call   400323fe <generic_exc_handle>

40032445 <handle_exc_IV_NON_MASKABLE_INTERRUPT>:
EXC_FUNC(IV_NON_MASKABLE_INTERRUPT);
40032445:	55                   	push   %ebp
40032446:	89 c2                	mov    %eax,%edx
40032448:	89 e5                	mov    %esp,%ebp
4003244a:	b8 02 00 00 00       	mov    $0x2,%eax
4003244f:	e8 aa ff ff ff       	call   400323fe <generic_exc_handle>

40032454 <handle_exc_IV_OVERFLOW>:
EXC_FUNC(IV_OVERFLOW);
40032454:	55                   	push   %ebp
40032455:	89 c2                	mov    %eax,%edx
40032457:	89 e5                	mov    %esp,%ebp
40032459:	b8 04 00 00 00       	mov    $0x4,%eax
4003245e:	e8 9b ff ff ff       	call   400323fe <generic_exc_handle>

40032463 <handle_exc_IV_BOUND_RANGE>:
EXC_FUNC(IV_BOUND_RANGE);
40032463:	55                   	push   %ebp
40032464:	89 c2                	mov    %eax,%edx
40032466:	89 e5                	mov    %esp,%ebp
40032468:	b8 05 00 00 00       	mov    $0x5,%eax
4003246d:	e8 8c ff ff ff       	call   400323fe <generic_exc_handle>

40032472 <handle_exc_IV_INVALID_OPCODE>:
EXC_FUNC(IV_INVALID_OPCODE);
40032472:	55                   	push   %ebp
40032473:	89 c2                	mov    %eax,%edx
40032475:	89 e5                	mov    %esp,%ebp
40032477:	b8 06 00 00 00       	mov    $0x6,%eax
4003247c:	e8 7d ff ff ff       	call   400323fe <generic_exc_handle>

40032481 <handle_exc_IV_DEVICE_NOT_AVAILABLE>:
#ifndef CONFIG_FP_SHARING
EXC_FUNC(IV_DEVICE_NOT_AVAILABLE);
40032481:	55                   	push   %ebp
40032482:	89 c2                	mov    %eax,%edx
40032484:	89 e5                	mov    %esp,%ebp
40032486:	b8 07 00 00 00       	mov    $0x7,%eax
4003248b:	e8 6e ff ff ff       	call   400323fe <generic_exc_handle>

40032490 <handle_exc_IV_DOUBLE_FAULT>:
#endif
EXC_FUNC(IV_DOUBLE_FAULT);
40032490:	55                   	push   %ebp
40032491:	89 c2                	mov    %eax,%edx
40032493:	89 e5                	mov    %esp,%ebp
40032495:	b8 08 00 00 00       	mov    $0x8,%eax
4003249a:	e8 5f ff ff ff       	call   400323fe <generic_exc_handle>

4003249f <handle_exc_IV_INVALID_TSS>:
EXC_FUNC(IV_INVALID_TSS);
4003249f:	55                   	push   %ebp
400324a0:	89 c2                	mov    %eax,%edx
400324a2:	89 e5                	mov    %esp,%ebp
400324a4:	b8 0a 00 00 00       	mov    $0xa,%eax
400324a9:	e8 50 ff ff ff       	call   400323fe <generic_exc_handle>

400324ae <handle_exc_IV_SEGMENT_NOT_PRESENT>:
EXC_FUNC(IV_SEGMENT_NOT_PRESENT);
400324ae:	55                   	push   %ebp
400324af:	89 c2                	mov    %eax,%edx
400324b1:	89 e5                	mov    %esp,%ebp
400324b3:	b8 0b 00 00 00       	mov    $0xb,%eax
400324b8:	e8 41 ff ff ff       	call   400323fe <generic_exc_handle>

400324bd <handle_exc_IV_STACK_FAULT>:
EXC_FUNC(IV_STACK_FAULT);
400324bd:	55                   	push   %ebp
400324be:	89 c2                	mov    %eax,%edx
400324c0:	89 e5                	mov    %esp,%ebp
400324c2:	b8 0c 00 00 00       	mov    $0xc,%eax
400324c7:	e8 32 ff ff ff       	call   400323fe <generic_exc_handle>

400324cc <handle_exc_IV_GENERAL_PROTECTION>:
EXC_FUNC(IV_GENERAL_PROTECTION);
400324cc:	55                   	push   %ebp
400324cd:	89 c2                	mov    %eax,%edx
400324cf:	89 e5                	mov    %esp,%ebp
400324d1:	b8 0d 00 00 00       	mov    $0xd,%eax
400324d6:	e8 23 ff ff ff       	call   400323fe <generic_exc_handle>

400324db <handle_exc_IV_PAGE_FAULT>:
EXC_FUNC(IV_PAGE_FAULT);
400324db:	55                   	push   %ebp
400324dc:	89 c2                	mov    %eax,%edx
400324de:	89 e5                	mov    %esp,%ebp
400324e0:	b8 0e 00 00 00       	mov    $0xe,%eax
400324e5:	e8 14 ff ff ff       	call   400323fe <generic_exc_handle>

400324ea <handle_exc_IV_X87_FPU_FP_ERROR>:
EXC_FUNC(IV_X87_FPU_FP_ERROR);
400324ea:	55                   	push   %ebp
400324eb:	89 c2                	mov    %eax,%edx
400324ed:	89 e5                	mov    %esp,%ebp
400324ef:	b8 10 00 00 00       	mov    $0x10,%eax
400324f4:	e8 05 ff ff ff       	call   400323fe <generic_exc_handle>

400324f9 <handle_exc_IV_ALIGNMENT_CHECK>:
EXC_FUNC(IV_ALIGNMENT_CHECK);
400324f9:	55                   	push   %ebp
400324fa:	89 c2                	mov    %eax,%edx
400324fc:	89 e5                	mov    %esp,%ebp
400324fe:	b8 11 00 00 00       	mov    $0x11,%eax
40032503:	e8 f6 fe ff ff       	call   400323fe <generic_exc_handle>

40032508 <handle_exc_IV_MACHINE_CHECK>:
EXC_FUNC(IV_MACHINE_CHECK);
40032508:	55                   	push   %ebp
40032509:	89 c2                	mov    %eax,%edx
4003250b:	89 e5                	mov    %esp,%ebp
4003250d:	b8 12 00 00 00       	mov    $0x12,%eax
40032512:	e8 e7 fe ff ff       	call   400323fe <generic_exc_handle>

40032517 <nano_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void nano_cpu_idle(void)
{
40032517:	55                   	push   %ebp
40032518:	89 e5                	mov    %esp,%ebp
	_sys_k_event_logger_enter_sleep();
#if defined(CONFIG_BOOT_TIME_MEASUREMENT)
	__idle_tsc = _NanoTscRead();
#endif

	__asm__ volatile (
4003251a:	fb                   	sti    
4003251b:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
4003251c:	5d                   	pop    %ebp
4003251d:	c3                   	ret    

4003251e <nano_cpu_atomic_idle>:
 *
 * @return N/A
 */

void nano_cpu_atomic_idle(unsigned int imask)
{
4003251e:	55                   	push   %ebp
4003251f:	89 e5                	mov    %esp,%ebp
	_int_latency_stop();
	_sys_k_event_logger_enter_sleep();

	__asm__ volatile (
40032521:	fb                   	sti    
40032522:	f4                   	hlt    
	     * atomically re-enable interrupts and enter a low-power mode.
	     */
	    "hlt\n\t");

	/* restore interrupt lockout state before returning to caller */
	if (!(imask & 0x200)) {
40032523:	f6 c4 02             	test   $0x2,%ah
40032526:	75 01                	jne    40032529 <nano_cpu_atomic_idle+0xb>
		_int_latency_start();
		__asm__ volatile("cli");
40032528:	fa                   	cli    
	}
}
40032529:	5d                   	pop    %ebp
4003252a:	c3                   	ret    

4003252b <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF * pEsf)
{
4003252b:	55                   	push   %ebp
4003252c:	89 e5                	mov    %esp,%ebp
4003252e:	53                   	push   %ebx
	nano_context_type_t curCtx = sys_execution_context_type_get();
4003252f:	e8 ab f5 ff ff       	call   40031adf <sys_execution_context_type_get>
40032534:	89 c3                	mov    %eax,%ebx

	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if ((curCtx != NANO_CTX_ISR) && !_is_thread_essential(NULL)) {
40032536:	85 c0                	test   %eax,%eax
40032538:	74 1d                	je     40032557 <_SysFatalErrorHandler+0x2c>
4003253a:	31 c0                	xor    %eax,%eax
4003253c:	e8 c1 f5 ff ff       	call   40031b02 <_is_thread_essential>
40032541:	85 c0                	test   %eax,%eax
40032543:	75 12                	jne    40032557 <_SysFatalErrorHandler+0x2c>
			PRINTK("Fatal task error! Aborting task.\n");
			_TaskAbort();
		} else
#endif /* CONFIG_MICROKERNEL */
		{
			PRINTK("Fatal fiber error! Aborting fiber.\n");
40032545:	68 ec 29 03 40       	push   $0x400329ec
4003254a:	e8 ff f9 ff ff       	call   40031f4e <printk>
4003254f:	59                   	pop    %ecx
			fiber_abort();
40032550:	e8 fc f3 ff ff       	call   40031951 <fiber_abort>
40032555:	eb 13                	jmp    4003256a <_SysFatalErrorHandler+0x3f>
		 */

		static const char * const ctxText[] = {"ISR", "essential fiber",
					  "essential task"};

		PRINTK("Fatal %s error! Spinning...\n", ctxText[curCtx]);
40032557:	ff 34 9d b0 2a 03 40 	pushl  0x40032ab0(,%ebx,4)
4003255e:	68 10 2a 03 40       	push   $0x40032a10
40032563:	e8 e6 f9 ff ff       	call   40031f4e <printk>
40032568:	58                   	pop    %eax
40032569:	5a                   	pop    %edx
4003256a:	eb fe                	jmp    4003256a <_SysFatalErrorHandler+0x3f>

4003256c <_ExcEntNoErr>:
 * This is very similar to _ExcEnt() but the stack is first massaged
 * so that a dummy error code is inserted.
 */
SECTION_FUNC(TEXT, _ExcEntNoErr)
	/* Clear direction flag, auto-restored when the exception exits */
	cld
4003256c:	fc                   	cld    

	/* Stash current value of ECX to free up the register */
	pushl	%ecx
4003256d:	51                   	push   %ecx

	/* Save the return address of the stub into ECX */
	movl	4(%esp), %ecx
4003256e:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	/*
	 * The spot for the error code contains useless data, but
	 * we don't particularly care since it will be unused.
	 */
	jmp	_ExcEntSetupDone
40032572:	e9 04 00 00 00       	jmp    4003257b <_ExcEntSetupDone>

40032577 <_ExcEnt>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
40032577:	fc                   	cld    
	/*
	 * Swap ecx and return address on the current stack;
	 * this saves ecx on the stack without losing knowledge
	 * of how to get back to the exception stub.
	 */
	xchgl	%ecx, (%esp)
40032578:	87 0c 24             	xchg   %ecx,(%esp)

4003257b <_ExcEntSetupDone>:

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
4003257b:	50                   	push   %eax
	pushl	%edx
4003257c:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
4003257d:	57                   	push   %edi
	pushl	%esi
4003257e:	56                   	push   %esi
	pushl	%ebx
4003257f:	53                   	push   %ebx
	pushl	%ebp
40032580:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
40032581:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
40032585:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
40032586:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
4003258d:	00 
	je	allDone
4003258e:	74 01                	je     40032591 <allDone>
	sti
40032590:	fb                   	sti    

40032591 <allDone>:

BRANCH_LABEL(allDone)
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
40032591:	89 e0                	mov    %esp,%eax
#else
	pushl	%esp			/* push NANO_ESF * parameter */
#endif
	jmp	*%ecx			/* "return" back to stub */
40032593:	ff e1                	jmp    *%ecx

40032595 <_ExcExit>:
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
40032595:	5d                   	pop    %ebp
	popl	%ebp
40032596:	5d                   	pop    %ebp
	popl	%ebx
40032597:	5b                   	pop    %ebx
	popl	%esi
40032598:	5e                   	pop    %esi
	popl	%edi
40032599:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
4003259a:	5a                   	pop    %edx
	popl	%eax
4003259b:	58                   	pop    %eax
	popl	%ecx
4003259c:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
4003259d:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
400325a0:	cf                   	iret   

400325a1 <handle_exc_IV_DIVIDE_ERRORStub>:
#if CONFIG_EXCEPTION_DEBUG

#define EXC_HANDLER(vec) NANO_CPU_EXC_CONNECT_NO_ERR(handle_exc_##vec, vec, 0)
#define EXC_HANDLER_CODE(vec) NANO_CPU_EXC_CONNECT(handle_exc_##vec, vec, 0)

EXC_HANDLER(IV_DIVIDE_ERROR)
400325a1:	e8 c6 ff ff ff       	call   4003256c <_ExcEntNoErr>
400325a6:	e8 8e fe ff ff       	call   40032439 <handle_exc_IV_DIVIDE_ERROR>
400325ab:	e9 e5 ff ff ff       	jmp    40032595 <_ExcExit>

400325b0 <handle_exc_IV_NON_MASKABLE_INTERRUPTStub>:
EXC_HANDLER(IV_NON_MASKABLE_INTERRUPT)
400325b0:	e8 b7 ff ff ff       	call   4003256c <_ExcEntNoErr>
400325b5:	e8 8b fe ff ff       	call   40032445 <handle_exc_IV_NON_MASKABLE_INTERRUPT>
400325ba:	e9 d6 ff ff ff       	jmp    40032595 <_ExcExit>

400325bf <handle_exc_IV_OVERFLOWStub>:
EXC_HANDLER(IV_OVERFLOW)
400325bf:	e8 a8 ff ff ff       	call   4003256c <_ExcEntNoErr>
400325c4:	e8 8b fe ff ff       	call   40032454 <handle_exc_IV_OVERFLOW>
400325c9:	e9 c7 ff ff ff       	jmp    40032595 <_ExcExit>

400325ce <handle_exc_IV_BOUND_RANGEStub>:
EXC_HANDLER(IV_BOUND_RANGE)
400325ce:	e8 99 ff ff ff       	call   4003256c <_ExcEntNoErr>
400325d3:	e8 8b fe ff ff       	call   40032463 <handle_exc_IV_BOUND_RANGE>
400325d8:	e9 b8 ff ff ff       	jmp    40032595 <_ExcExit>

400325dd <handle_exc_IV_INVALID_OPCODEStub>:
EXC_HANDLER(IV_INVALID_OPCODE)
400325dd:	e8 8a ff ff ff       	call   4003256c <_ExcEntNoErr>
400325e2:	e8 8b fe ff ff       	call   40032472 <handle_exc_IV_INVALID_OPCODE>
400325e7:	e9 a9 ff ff ff       	jmp    40032595 <_ExcExit>

400325ec <handle_exc_IV_DEVICE_NOT_AVAILABLEStub>:
#ifndef CONFIG_FP_SHARING
EXC_HANDLER(IV_DEVICE_NOT_AVAILABLE)
400325ec:	e8 7b ff ff ff       	call   4003256c <_ExcEntNoErr>
400325f1:	e8 8b fe ff ff       	call   40032481 <handle_exc_IV_DEVICE_NOT_AVAILABLE>
400325f6:	e9 9a ff ff ff       	jmp    40032595 <_ExcExit>

400325fb <handle_exc_IV_DOUBLE_FAULTStub>:
#endif
EXC_HANDLER_CODE(IV_DOUBLE_FAULT)
400325fb:	e8 77 ff ff ff       	call   40032577 <_ExcEnt>
40032600:	e8 8b fe ff ff       	call   40032490 <handle_exc_IV_DOUBLE_FAULT>
40032605:	e9 8b ff ff ff       	jmp    40032595 <_ExcExit>

4003260a <handle_exc_IV_INVALID_TSSStub>:
EXC_HANDLER_CODE(IV_INVALID_TSS)
4003260a:	e8 68 ff ff ff       	call   40032577 <_ExcEnt>
4003260f:	e8 8b fe ff ff       	call   4003249f <handle_exc_IV_INVALID_TSS>
40032614:	e9 7c ff ff ff       	jmp    40032595 <_ExcExit>

40032619 <handle_exc_IV_SEGMENT_NOT_PRESENTStub>:
EXC_HANDLER_CODE(IV_SEGMENT_NOT_PRESENT)
40032619:	e8 59 ff ff ff       	call   40032577 <_ExcEnt>
4003261e:	e8 8b fe ff ff       	call   400324ae <handle_exc_IV_SEGMENT_NOT_PRESENT>
40032623:	e9 6d ff ff ff       	jmp    40032595 <_ExcExit>

40032628 <handle_exc_IV_STACK_FAULTStub>:
EXC_HANDLER_CODE(IV_STACK_FAULT)
40032628:	e8 4a ff ff ff       	call   40032577 <_ExcEnt>
4003262d:	e8 8b fe ff ff       	call   400324bd <handle_exc_IV_STACK_FAULT>
40032632:	e9 5e ff ff ff       	jmp    40032595 <_ExcExit>

40032637 <handle_exc_IV_GENERAL_PROTECTIONStub>:
EXC_HANDLER_CODE(IV_GENERAL_PROTECTION)
40032637:	e8 3b ff ff ff       	call   40032577 <_ExcEnt>
4003263c:	e8 8b fe ff ff       	call   400324cc <handle_exc_IV_GENERAL_PROTECTION>
40032641:	e9 4f ff ff ff       	jmp    40032595 <_ExcExit>

40032646 <handle_exc_IV_PAGE_FAULTStub>:
EXC_HANDLER_CODE(IV_PAGE_FAULT)
40032646:	e8 2c ff ff ff       	call   40032577 <_ExcEnt>
4003264b:	e8 8b fe ff ff       	call   400324db <handle_exc_IV_PAGE_FAULT>
40032650:	e9 40 ff ff ff       	jmp    40032595 <_ExcExit>

40032655 <handle_exc_IV_X87_FPU_FP_ERRORStub>:
EXC_HANDLER(IV_X87_FPU_FP_ERROR)
40032655:	e8 12 ff ff ff       	call   4003256c <_ExcEntNoErr>
4003265a:	e8 8b fe ff ff       	call   400324ea <handle_exc_IV_X87_FPU_FP_ERROR>
4003265f:	e9 31 ff ff ff       	jmp    40032595 <_ExcExit>

40032664 <handle_exc_IV_ALIGNMENT_CHECKStub>:
EXC_HANDLER_CODE(IV_ALIGNMENT_CHECK)
40032664:	e8 0e ff ff ff       	call   40032577 <_ExcEnt>
40032669:	e8 8b fe ff ff       	call   400324f9 <handle_exc_IV_ALIGNMENT_CHECK>
4003266e:	e9 22 ff ff ff       	jmp    40032595 <_ExcExit>

40032673 <handle_exc_IV_MACHINE_CHECKStub>:
EXC_HANDLER(IV_MACHINE_CHECK)
40032673:	e8 f4 fe ff ff       	call   4003256c <_ExcEntNoErr>
40032678:	e8 8b fe ff ff       	call   40032508 <handle_exc_IV_MACHINE_CHECK>
4003267d:	e9 13 ff ff ff       	jmp    40032595 <_ExcExit>

40032682 <x86_quark_se_ipm_init>:
#if CONFIG_IPM_QUARK_SE
#include <ipm.h>
#include <ipm/ipm_quark_se.h>

static int x86_quark_se_ipm_init(void)
{
40032682:	55                   	push   %ebp
40032683:	89 e5                	mov    %esp,%ebp
	IRQ_CONNECT(QUARK_SE_IPM_INTERRUPT, QUARK_SE_IPM_INTERRUPT_PRI,
40032685:	eb 16                	jmp    4003269d <x86_quark_se_ipm_init+0x1b>
40032687:	50                   	push   %eax
40032688:	52                   	push   %edx
40032689:	51                   	push   %ecx
4003268a:	b8 c9 07 03 40       	mov    $0x400307c9,%eax
4003268f:	ba 00 00 00 00       	mov    $0x0,%edx
40032694:	e8 a1 fb ff ff       	call   4003223a <_execute_handler>
40032699:	59                   	pop    %ecx
4003269a:	5a                   	pop    %edx
4003269b:	58                   	pop    %eax
4003269c:	cf                   	iret   
4003269d:	0f b6 05 d5 32 03 40 	movzbl 0x400332d5,%eax
400326a4:	31 c9                	xor    %ecx,%ecx
400326a6:	ba 15 00 00 00       	mov    $0x15,%edx
400326ab:	e8 cf dd ff ff       	call   4003047f <_SysIntVecProgram>
		    quark_se_ipm_isr, NULL, 0);
	irq_enable(QUARK_SE_IPM_INTERRUPT);
400326b0:	b8 15 00 00 00       	mov    $0x15,%eax
400326b5:	e8 e7 dd ff ff       	call   400304a1 <irq_enable>
	return DEV_OK;
}
400326ba:	31 c0                	xor    %eax,%eax
400326bc:	5d                   	pop    %ebp
400326bd:	c3                   	ret    

400326be <_lakemont_eoi>:
#include <drivers/ioapic.h>
#include <sys_io.h>
#include <interrupt_controller/ioapic_priv.h>

void _lakemont_eoi(void)
{
400326be:	55                   	push   %ebp
400326bf:	89 e5                	mov    %esp,%ebp
	int vector = _loapic_isr_vector_get();
400326c1:	e8 f9 de ff ff       	call   400305bf <_loapic_isr_vector_get>
400326c6:	a3 40 00 c0 fe       	mov    %eax,0xfec00040
	 * a level interrupt handled by the IOAPIC; the only information
	 * we have is the vector # in the IDT. So unconditionally
	 * write to IOAPIC_EOI for every interrupt
	 */
	sys_write32(vector, CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_EOI);
}
400326cb:	5d                   	pop    %ebp
400326cc:	c3                   	ret    

400326cd <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
400326cd:	55                   	push   %ebp
400326ce:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
400326d0:	5d                   	pop    %ebp
400326d1:	c3                   	ret    
