
zephyr.elf:     file format elf32-i386


Disassembly of section text:

00100000 <__start>:
        mov  %eax, %esi			/* low  value */
        mov  %edx, %edi			/* high value */
#endif

	/* Enable write-back caching by clearing the NW and CD bits */
	movl	%cr0, %eax
  100000:	0f 20 c0             	mov    %cr0,%eax
	andl	$0x9fffffff, %eax
  100003:	25 ff ff ff 9f       	and    $0x9fffffff,%eax
	movl	%eax, %cr0
  100008:	0f 22 c0             	mov    %eax,%cr0
	/*
	 * Ensure interrupts are disabled.  Interrupts are enabled when
	 * the first context switch occurs.
	 */

	cli
  10000b:	fa                   	cli    
	 * Although the bootloader sets up an Interrupt Descriptor Table (IDT)
	 * and a Global Descriptor Table (GDT), the specification encourages
	 * booted operating systems to setup their own IDT and GDT.
	 */

	lgdt	_gdt_rom		/* load 32-bit operand size GDT */
  10000c:	0f 01 15 6c 00 10 00 	lgdtl  0x10006c
	lidt	_Idt		/* load 32-bit operand size IDT */
  100013:	0f 01 1d 5a 00 10 00 	lidtl  0x10005a
	 *
	 * This is a special case for the ia32 platform, which must work for
	 * multiple platforms (QEMU, generic PC board, etc.). With other
	 * platforms the bootloader is well known so assumptions can be made.
	 */
	movw	$0x10, %ax	/* data segment selector (entry = 3) */
  10001a:	66 b8 10 00          	mov    $0x10,%ax
	movw	%ax, %ds	/* set DS */
  10001e:	8e d8                	mov    %eax,%ds
	movw	%ax, %es	/* set ES */
  100020:	8e c0                	mov    %eax,%es
	movw	%ax, %fs	/* set FS */
  100022:	8e e0                	mov    %eax,%fs
	movw	%ax, %gs	/* set GS */
  100024:	8e e8                	mov    %eax,%gs
	movw	%ax, %ss	/* set SS */
  100026:	8e d0                	mov    %eax,%ss

	ljmp	$0x08, $__csSet	/* set CS = 0x08 */
  100028:	ea 2f 00 10 00 08 00 	ljmp   $0x8,$0x10002f

0010002f <__csSet>:
	/*
	 * Force an #NM exception for floating point instructions
	 * since FP support hasn't been configured
	 */

	movl	%cr0, %eax		/* move CR0 to EAX */
  10002f:	0f 20 c0             	mov    %cr0,%eax
	orl	$0x2e, %eax		/* CR0[NE+TS+EM+MP]=1 */
  100032:	83 c8 2e             	or     $0x2e,%eax
	movl	%eax, %cr0		/* move EAX to CR0 */
  100035:	0f 22 c0             	mov    %eax,%cr0
	 * interfering with interrupt handler use of this stack.
	 * If it is a cold boot then _sys_soc_resume() should not do
	 * anything and must return immediately.
	 */

	movl	$_interrupt_stack, %esp
  100038:	bc 40 1f 10 00       	mov    $0x101f40,%esp
	addl	$CONFIG_ISR_STACK_SIZE, %esp
  10003d:	81 c4 00 08 00 00    	add    $0x800,%esp

	/* align to stack boundary: ROUND_DOWN (%esp, 4) */

	andl	$0xfffffffc, %esp
  100043:	83 e4 fc             	and    $0xfffffffc,%esp

#else /* !CONFIG_SSE */

	/* clear out BSS double words (32-bits at a time) */

	xorl	%eax, %eax		/* fill memory with 0 */
  100046:	31 c0                	xor    %eax,%eax
	movl	$__bss_start, %edi	/* load BSS start address */
  100048:	bf c0 1e 10 00       	mov    $0x101ec0,%edi
	movl	$__bss_num_words, %ecx	/* number of quad bytes */
  10004d:	b9 19 00 00 00       	mov    $0x19,%ecx
	cld
  100052:	fc                   	cld    
	rep
  100053:	f3 ab                	rep stos %eax,%es:(%edi)
	lgdt	%ds:_gdt
#endif

	/* Jump to C portion of kernel initialization and never return */

	jmp	_Cstart
  100055:	e9 56 08 00 00       	jmp    1008b0 <_Cstart>

0010005a <_Idt>:
  10005a:	ff 07 80 15 10 00 02 b0 ad 1b 00 00 00 00 fe 4f     ...............O
  10006a:	52 e4                                               R.

0010006c <_gdt>:
  10006c:	17 00 80 00 10 00 8d b4 26 00 00 00 00 8d bc 27     ........&......'
  10007c:	00 00 00 00                                         ....

00100080 <_gdt_rom_entries>:
	...
  100088:	ff                   	(bad)  
  100089:	ff 00                	incl   (%eax)
  10008b:	00 00                	add    %al,(%eax)
  10008d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
  100094:	00 92 cf 00 66 90    	add    %dl,-0x6f99ff31(%edx)

00100098 <_gdt_rom_end>:
  100098:	66 90                	xchg   %ax,%ax
  10009a:	66 90                	xchg   %ax,%ax
  10009c:	66 90                	xchg   %ax,%ax
  10009e:	66 90                	xchg   %ax,%ax

001000a0 <__udivdi3>:
  1000a0:	55                   	push   %ebp
  1000a1:	57                   	push   %edi
  1000a2:	56                   	push   %esi
  1000a3:	53                   	push   %ebx
  1000a4:	83 ec 1c             	sub    $0x1c,%esp
  1000a7:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  1000ab:	8b 4c 24 34          	mov    0x34(%esp),%ecx
  1000af:	8b 7c 24 38          	mov    0x38(%esp),%edi
  1000b3:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  1000b7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  1000bb:	89 ca                	mov    %ecx,%edx
  1000bd:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1000c1:	85 f6                	test   %esi,%esi
  1000c3:	75 3b                	jne    100100 <__udivdi3+0x60>
  1000c5:	39 cf                	cmp    %ecx,%edi
  1000c7:	0f 87 c3 00 00 00    	ja     100190 <__udivdi3+0xf0>
  1000cd:	89 fd                	mov    %edi,%ebp
  1000cf:	85 ff                	test   %edi,%edi
  1000d1:	75 0b                	jne    1000de <__udivdi3+0x3e>
  1000d3:	b8 01 00 00 00       	mov    $0x1,%eax
  1000d8:	31 d2                	xor    %edx,%edx
  1000da:	f7 f7                	div    %edi
  1000dc:	89 c5                	mov    %eax,%ebp
  1000de:	89 c8                	mov    %ecx,%eax
  1000e0:	31 d2                	xor    %edx,%edx
  1000e2:	f7 f5                	div    %ebp
  1000e4:	89 c1                	mov    %eax,%ecx
  1000e6:	89 d8                	mov    %ebx,%eax
  1000e8:	89 cf                	mov    %ecx,%edi
  1000ea:	f7 f5                	div    %ebp
  1000ec:	89 fa                	mov    %edi,%edx
  1000ee:	83 c4 1c             	add    $0x1c,%esp
  1000f1:	5b                   	pop    %ebx
  1000f2:	5e                   	pop    %esi
  1000f3:	5f                   	pop    %edi
  1000f4:	5d                   	pop    %ebp
  1000f5:	c3                   	ret    
  1000f6:	8d 76 00             	lea    0x0(%esi),%esi
  1000f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100100:	39 ce                	cmp    %ecx,%esi
  100102:	77 7c                	ja     100180 <__udivdi3+0xe0>
  100104:	0f bd fe             	bsr    %esi,%edi
  100107:	83 f7 1f             	xor    $0x1f,%edi
  10010a:	0f 84 90 00 00 00    	je     1001a0 <__udivdi3+0x100>
  100110:	bd 20 00 00 00       	mov    $0x20,%ebp
  100115:	89 f9                	mov    %edi,%ecx
  100117:	89 eb                	mov    %ebp,%ebx
  100119:	8b 6c 24 0c          	mov    0xc(%esp),%ebp
  10011d:	29 fb                	sub    %edi,%ebx
  10011f:	89 e8                	mov    %ebp,%eax
  100121:	d3 e6                	shl    %cl,%esi
  100123:	88 d9                	mov    %bl,%cl
  100125:	d3 e8                	shr    %cl,%eax
  100127:	89 f9                	mov    %edi,%ecx
  100129:	09 f0                	or     %esi,%eax
  10012b:	d3 e5                	shl    %cl,%ebp
  10012d:	89 d6                	mov    %edx,%esi
  10012f:	88 d9                	mov    %bl,%cl
  100131:	d3 ee                	shr    %cl,%esi
  100133:	89 f9                	mov    %edi,%ecx
  100135:	89 44 24 0c          	mov    %eax,0xc(%esp)
  100139:	d3 e2                	shl    %cl,%edx
  10013b:	8b 44 24 08          	mov    0x8(%esp),%eax
  10013f:	88 d9                	mov    %bl,%cl
  100141:	d3 e8                	shr    %cl,%eax
  100143:	09 c2                	or     %eax,%edx
  100145:	89 d0                	mov    %edx,%eax
  100147:	89 f2                	mov    %esi,%edx
  100149:	f7 74 24 0c          	divl   0xc(%esp)
  10014d:	89 d6                	mov    %edx,%esi
  10014f:	89 c3                	mov    %eax,%ebx
  100151:	f7 e5                	mul    %ebp
  100153:	39 d6                	cmp    %edx,%esi
  100155:	72 10                	jb     100167 <__udivdi3+0xc7>
  100157:	8b 6c 24 08          	mov    0x8(%esp),%ebp
  10015b:	89 f9                	mov    %edi,%ecx
  10015d:	d3 e5                	shl    %cl,%ebp
  10015f:	39 c5                	cmp    %eax,%ebp
  100161:	73 5d                	jae    1001c0 <__udivdi3+0x120>
  100163:	39 d6                	cmp    %edx,%esi
  100165:	75 59                	jne    1001c0 <__udivdi3+0x120>
  100167:	8d 43 ff             	lea    -0x1(%ebx),%eax
  10016a:	31 ff                	xor    %edi,%edi
  10016c:	89 fa                	mov    %edi,%edx
  10016e:	83 c4 1c             	add    $0x1c,%esp
  100171:	5b                   	pop    %ebx
  100172:	5e                   	pop    %esi
  100173:	5f                   	pop    %edi
  100174:	5d                   	pop    %ebp
  100175:	c3                   	ret    
  100176:	8d 76 00             	lea    0x0(%esi),%esi
  100179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  100180:	31 ff                	xor    %edi,%edi
  100182:	31 c0                	xor    %eax,%eax
  100184:	89 fa                	mov    %edi,%edx
  100186:	83 c4 1c             	add    $0x1c,%esp
  100189:	5b                   	pop    %ebx
  10018a:	5e                   	pop    %esi
  10018b:	5f                   	pop    %edi
  10018c:	5d                   	pop    %ebp
  10018d:	c3                   	ret    
  10018e:	66 90                	xchg   %ax,%ax
  100190:	89 d8                	mov    %ebx,%eax
  100192:	f7 f7                	div    %edi
  100194:	31 ff                	xor    %edi,%edi
  100196:	89 fa                	mov    %edi,%edx
  100198:	83 c4 1c             	add    $0x1c,%esp
  10019b:	5b                   	pop    %ebx
  10019c:	5e                   	pop    %esi
  10019d:	5f                   	pop    %edi
  10019e:	5d                   	pop    %ebp
  10019f:	c3                   	ret    
  1001a0:	39 ce                	cmp    %ecx,%esi
  1001a2:	72 10                	jb     1001b4 <__udivdi3+0x114>
  1001a4:	8b 74 24 08          	mov    0x8(%esp),%esi
  1001a8:	31 c0                	xor    %eax,%eax
  1001aa:	39 74 24 0c          	cmp    %esi,0xc(%esp)
  1001ae:	0f 87 38 ff ff ff    	ja     1000ec <__udivdi3+0x4c>
  1001b4:	b8 01 00 00 00       	mov    $0x1,%eax
  1001b9:	e9 2e ff ff ff       	jmp    1000ec <__udivdi3+0x4c>
  1001be:	66 90                	xchg   %ax,%ax
  1001c0:	89 d8                	mov    %ebx,%eax
  1001c2:	31 ff                	xor    %edi,%edi
  1001c4:	e9 23 ff ff ff       	jmp    1000ec <__udivdi3+0x4c>

001001c9 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1001c9:	55                   	push   %ebp
	uart_poll_out(uart_console_dev, (unsigned char)c);
  1001ca:	a1 c0 1e 10 00       	mov    0x101ec0,%eax
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
  1001cf:	89 e5                	mov    %esp,%ebp
  1001d1:	53                   	push   %ebx
					  unsigned char out_char)
{
	struct uart_driver_api *api;

	api = (struct uart_driver_api *)dev->driver_api;
	return api->poll_out(dev, out_char);
  1001d2:	8b 50 04             	mov    0x4(%eax),%edx
  1001d5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  1001d8:	0f b6 cb             	movzbl %bl,%ecx
  1001db:	51                   	push   %ecx
  1001dc:	50                   	push   %eax
  1001dd:	ff 52 04             	call   *0x4(%edx)
  1001e0:	59                   	pop    %ecx
	uart_poll_out(uart_console_dev, (unsigned char)c);
	if ('\n' == c) {
  1001e1:	83 fb 0a             	cmp    $0xa,%ebx
  1001e4:	58                   	pop    %eax
  1001e5:	75 10                	jne    1001f7 <console_out+0x2e>
		uart_poll_out(uart_console_dev, (unsigned char)'\r');
  1001e7:	a1 c0 1e 10 00       	mov    0x101ec0,%eax
  1001ec:	8b 50 04             	mov    0x4(%eax),%edx
  1001ef:	6a 0d                	push   $0xd
  1001f1:	50                   	push   %eax
  1001f2:	ff 52 04             	call   *0x4(%edx)
  1001f5:	58                   	pop    %eax
  1001f6:	5a                   	pop    %edx
	}
	return c;
}
  1001f7:	89 d8                	mov    %ebx,%eax
  1001f9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1001fc:	c9                   	leave  
  1001fd:	c3                   	ret    

001001fe <uart_console_hook_install>:
 *
 * @return N/A
 */

void uart_console_hook_install(void)
{
  1001fe:	55                   	push   %ebp
  1001ff:	89 e5                	mov    %esp,%ebp
	__stdout_hook_install(console_out);
	__printk_hook_install(console_out);
  100201:	68 c9 01 10 00       	push   $0x1001c9
  100206:	e8 0d 0a 00 00       	call   100c18 <__printk_hook_install>
  10020b:	58                   	pop    %eax
}
  10020c:	c9                   	leave  
  10020d:	c3                   	ret    

0010020e <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
  10020e:	55                   	push   %ebp
  10020f:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
  100211:	68 00 13 10 00       	push   $0x101300
  100216:	e8 70 07 00 00       	call   10098b <device_get_binding>
  10021b:	5a                   	pop    %edx
  10021c:	a3 c0 1e 10 00       	mov    %eax,0x101ec0

	uart_console_hook_install();
  100221:	e8 d8 ff ff ff       	call   1001fe <uart_console_hook_install>

	return 0;
}
  100226:	31 c0                	xor    %eax,%eax
  100228:	c9                   	leave  
  100229:	c3                   	ret    

0010022a <uart_ns16550_init>:
 * @param dev UART device struct
 *
 * @return 0 if successful, failed othersie
 */
static int uart_ns16550_init(struct device *dev)
{
  10022a:	55                   	push   %ebp
  10022b:	89 e5                	mov    %esp,%ebp
  10022d:	57                   	push   %edi
  10022e:	56                   	push   %esi
  10022f:	53                   	push   %ebx
  100230:	83 ec 0c             	sub    $0xc,%esp
  100233:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
  100236:	8b 79 08             	mov    0x8(%ecx),%edi

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100239:	9c                   	pushf  
  10023a:	fa                   	cli    
  10023b:	8f 45 e8             	popl   -0x18(%ebp)
}
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	struct uart_device_config * const dev_cfg = DEV_CFG(dev);
  10023e:	8b 01                	mov    (%ecx),%eax
	dev_data->iir_cache = 0;
#endif

	old_level = irq_lock();

	set_baud_rate(dev, dev_data->baud_rate);
  100240:	8b 1f                	mov    (%edi),%ebx
{
	struct uart_device_config * const dev_cfg = DEV_CFG(dev);
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  100242:	85 db                	test   %ebx,%ebx
}
#endif

static void set_baud_rate(struct device *dev, uint32_t baud_rate)
{
	struct uart_device_config * const dev_cfg = DEV_CFG(dev);
  100244:	8b 70 08             	mov    0x8(%eax),%esi
	struct uart_ns16550_dev_data_t * const dev_data = DEV_DATA(dev);
	uint32_t divisor; /* baud rate divisor */

	if ((baud_rate != 0) && (dev_cfg->sys_clk_freq != 0)) {
  100247:	74 2f                	je     100278 <uart_ns16550_init+0x4e>
  100249:	8b 46 04             	mov    0x4(%esi),%eax
  10024c:	85 c0                	test   %eax,%eax
  10024e:	74 28                	je     100278 <uart_ns16550_init+0x4e>
		/* calculate baud rate divisor */
		divisor = (dev_cfg->sys_clk_freq / baud_rate) >> 4;
  100250:	31 d2                	xor    %edx,%edx
  100252:	f7 f3                	div    %ebx
  100254:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100257:	c1 e8 04             	shr    $0x4,%eax
  10025a:	89 45 ec             	mov    %eax,-0x14(%ebp)
/* Implementation of sys_io.h's documented functions */

static inline __attribute__((always_inline))
	void sys_out8(uint8_t data, io_port_t port)
{
	__asm__ volatile("outb	%b0, %w1;\n\t"
  10025d:	8b 06                	mov    (%esi),%eax
  10025f:	8d 50 03             	lea    0x3(%eax),%edx
  100262:	b0 80                	mov    $0x80,%al
  100264:	ee                   	out    %al,(%dx)
  100265:	8a 45 ec             	mov    -0x14(%ebp),%al
  100268:	8b 16                	mov    (%esi),%edx
  10026a:	ee                   	out    %al,(%dx)
  10026b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10026e:	42                   	inc    %edx
  10026f:	c1 e8 0c             	shr    $0xc,%eax
  100272:	ee                   	out    %al,(%dx)
		/* set the DLAB to access the baud rate divisor registers */
		OUTBYTE(LCR(dev), LCR_DLAB);
		OUTBYTE(BRDL(dev), (unsigned char)(divisor & 0xff));
		OUTBYTE(BRDH(dev), (unsigned char)((divisor >> 8) & 0xff));

		dev_data->baud_rate = baud_rate;
  100273:	8b 41 08             	mov    0x8(%ecx),%eax
  100276:	89 18                	mov    %ebx,(%eax)
#ifdef CONFIG_UART_NS16550_DLF
	set_dlf(dev, dev_data->dlf);
#endif

	/* 8 data bits, 1 stop bit, no parity, clear DLAB */
	OUTBYTE(LCR(dev), LCR_CS8 | LCR_1_STB | LCR_PDIS);
  100278:	8b 1e                	mov    (%esi),%ebx
  10027a:	b0 03                	mov    $0x3,%al
  10027c:	8d 53 03             	lea    0x3(%ebx),%edx
  10027f:	ee                   	out    %al,(%dx)

	mdc = MCR_OUT2 | MCR_RTS | MCR_DTR;
	if ((dev_data->options & UART_OPTION_AFCE) == UART_OPTION_AFCE)
  100280:	8a 47 04             	mov    0x4(%edi),%al
  100283:	8d 53 04             	lea    0x4(%ebx),%edx
  100286:	83 e0 01             	and    $0x1,%eax
		mdc |= MCR_AFCE;
  100289:	3c 01                	cmp    $0x1,%al
  10028b:	19 c0                	sbb    %eax,%eax
  10028d:	83 e0 e0             	and    $0xffffffe0,%eax
  100290:	83 c0 2b             	add    $0x2b,%eax
  100293:	ee                   	out    %al,(%dx)
  100294:	b0 87                	mov    $0x87,%al
  100296:	8d 53 02             	lea    0x2(%ebx),%edx
  100299:	ee                   	out    %al,(%dx)
static inline __attribute__((always_inline))
	uint8_t sys_in8(io_port_t port)
{
	uint8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
  10029a:	89 da                	mov    %ebx,%edx
  10029c:	ec                   	in     (%dx),%al
/* Implementation of sys_io.h's documented functions */

static inline __attribute__((always_inline))
	void sys_out8(uint8_t data, io_port_t port)
{
	__asm__ volatile("outb	%b0, %w1;\n\t"
  10029d:	31 c0                	xor    %eax,%eax
  10029f:	8d 53 01             	lea    0x1(%ebx),%edx
  1002a2:	ee                   	out    %al,(%dx)
 *
 */

static inline __attribute__((always_inline)) void _arch_irq_unlock(unsigned int key)
{
	if (!(key & 0x200)) {
  1002a3:	f7 45 e8 00 02 00 00 	testl  $0x200,-0x18(%ebp)
  1002aa:	74 01                	je     1002ad <uart_ns16550_init+0x83>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  1002ac:	fb                   	sti    

#ifdef CONFIG_UART_INTERRUPT_DRIVEN
	DEV_CFG(dev)->irq_config_func(dev);
#endif

	dev->driver_api = &uart_ns16550_driver_api;
  1002ad:	c7 41 04 20 1e 10 00 	movl   $0x101e20,0x4(%ecx)

	return 0;
}
  1002b4:	83 c4 0c             	add    $0xc,%esp
  1002b7:	31 c0                	xor    %eax,%eax
  1002b9:	5b                   	pop    %ebx
  1002ba:	5e                   	pop    %esi
  1002bb:	5f                   	pop    %edi
  1002bc:	5d                   	pop    %ebp
  1002bd:	c3                   	ret    

001002be <uart_ns16550_poll_in>:
 * @param c Pointer to character
 *
 * @return 0 if a character arrived, -1 if the input buffer if empty.
 */
static int uart_ns16550_poll_in(struct device *dev, unsigned char *c)
{
  1002be:	55                   	push   %ebp
  1002bf:	89 e5                	mov    %esp,%ebp
	if ((INBYTE(LSR(dev)) & LSR_RXRDY) == 0x00)
  1002c1:	8b 45 08             	mov    0x8(%ebp),%eax
  1002c4:	8b 00                	mov    (%eax),%eax
  1002c6:	8b 40 08             	mov    0x8(%eax),%eax
  1002c9:	8b 08                	mov    (%eax),%ecx
static inline __attribute__((always_inline))
	uint8_t sys_in8(io_port_t port)
{
	uint8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
  1002cb:	8d 51 05             	lea    0x5(%ecx),%edx
  1002ce:	ec                   	in     (%dx),%al
  1002cf:	88 c2                	mov    %al,%dl
  1002d1:	80 e2 01             	and    $0x1,%dl
  1002d4:	74 0c                	je     1002e2 <uart_ns16550_poll_in+0x24>
  1002d6:	89 ca                	mov    %ecx,%edx
  1002d8:	ec                   	in     (%dx),%al
		return (-1);

	/* got a character */
	*c = INBYTE(RDR(dev));
  1002d9:	8b 55 0c             	mov    0xc(%ebp),%edx
  1002dc:	88 02                	mov    %al,(%edx)

	return 0;
  1002de:	31 c0                	xor    %eax,%eax
  1002e0:	eb 03                	jmp    1002e5 <uart_ns16550_poll_in+0x27>
  1002e2:	83 c8 ff             	or     $0xffffffff,%eax
}
  1002e5:	5d                   	pop    %ebp
  1002e6:	c3                   	ret    

001002e7 <uart_ns16550_poll_out>:
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  1002e7:	55                   	push   %ebp
  1002e8:	89 e5                	mov    %esp,%ebp
  1002ea:	53                   	push   %ebx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
  1002eb:	8b 45 08             	mov    0x8(%ebp),%eax
 *
 * @return Sent character
 */
static unsigned char uart_ns16550_poll_out(struct device *dev,
					   unsigned char c)
{
  1002ee:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	/* wait for transmitter to ready to accept a character */
	while ((INBYTE(LSR(dev)) & LSR_TEMT) == 0)
  1002f1:	8b 00                	mov    (%eax),%eax
  1002f3:	8b 40 08             	mov    0x8(%eax),%eax
  1002f6:	8b 18                	mov    (%eax),%ebx
  1002f8:	8d 53 05             	lea    0x5(%ebx),%edx
  1002fb:	ec                   	in     (%dx),%al
  1002fc:	a8 40                	test   $0x40,%al
  1002fe:	74 fb                	je     1002fb <uart_ns16550_poll_out+0x14>
/* Implementation of sys_io.h's documented functions */

static inline __attribute__((always_inline))
	void sys_out8(uint8_t data, io_port_t port)
{
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100300:	88 c8                	mov    %cl,%al
  100302:	89 da                	mov    %ebx,%edx
  100304:	ee                   	out    %al,(%dx)
		;

	OUTBYTE(THR(dev), c);

	return c;
}
  100305:	5b                   	pop    %ebx
  100306:	5d                   	pop    %ebp
  100307:	c3                   	ret    

00100308 <uart_ns16550_err_check>:
 *
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
  100308:	55                   	push   %ebp
  100309:	89 e5                	mov    %esp,%ebp
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  10030b:	8b 45 08             	mov    0x8(%ebp),%eax
  10030e:	8b 00                	mov    (%eax),%eax
  100310:	8b 40 08             	mov    0x8(%eax),%eax
static inline __attribute__((always_inline))
	uint8_t sys_in8(io_port_t port)
{
	uint8_t ret;

	__asm__ volatile("inb	%w1, %b0;\n\t"
  100313:	8b 00                	mov    (%eax),%eax
  100315:	8d 50 05             	lea    0x5(%eax),%edx
  100318:	ec                   	in     (%dx),%al
  100319:	83 e0 1e             	and    $0x1e,%eax
}
  10031c:	5d                   	pop    %ebp
 * @return one of UART_ERROR_OVERRUN, UART_ERROR_PARITY, UART_ERROR_FRAMING,
 * UART_ERROR_BREAK if an error was detected, 0 otherwise.
 */
static int uart_ns16550_err_check(struct device *dev)
{
	return (INBYTE(LSR(dev)) & LSR_EOB_MASK) >> 1;
  10031d:	d1 f8                	sar    %eax
}
  10031f:	c3                   	ret    

00100320 <_timer_int_handler>:
 * is pushed onto the microkernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  100320:	55                   	push   %ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  100321:	a1 2c 1e 10 00       	mov    0x101e2c,%eax
 * is pushed onto the microkernel stack.
 *
 * @return N/A
 */
void _timer_int_handler(void *unused)
{
  100326:	89 e5                	mov    %esp,%ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  100328:	89 45 08             	mov    %eax,0x8(%ebp)
		_sys_clock_tick_announce();
	}

#endif /* !CONFIG_TICKLESS_IDLE */

}
  10032b:	5d                   	pop    %ebp
	/*
	 * one more tick has occurred -- don't need to do anything special since
	 * timer is already configured to interrupt on the following tick
	 */

	_sys_clock_tick_announce();
  10032c:	e9 35 04 00 00       	jmp    100766 <_nano_sys_clock_tick_announce>

00100331 <_sys_clock_driver_init>:
 *
 * @return 0
 */

int _sys_clock_driver_init(struct device *device)
{
  100331:	55                   	push   %ebp
  100332:	89 e5                	mov    %esp,%ebp
  100334:	57                   	push   %edi
  100335:	56                   	push   %esi
  100336:	53                   	push   %ebx
	/*
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
  100337:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  10033c:	83 e0 fe             	and    $0xfffffffe,%eax
  10033f:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100344:	c7 05 f0 00 d0 fe 00 	movl   $0x0,0xfed000f0
  10034b:	00 00 00 
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  10034e:	b8 00 ca 9a 3b       	mov    $0x3b9aca00,%eax
	 * Initial state of HPET is unknown, so put it back in a reset-like
	 * state (i.e. set main counter to 0 and disable interrupts)
	 */

	*_HPET_GENERAL_CONFIG &= ~HPET_ENABLE_CNF;
	*_HPET_MAIN_COUNTER_VALUE = 0;
  100353:	c7 05 f4 00 d0 fe 00 	movl   $0x0,0xfed000f4
  10035a:	00 00 00 
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  10035d:	f7 2d 38 1e 10 00    	imull  0x101e38
	 * to determine the frequency of clock applied to the HPET device.
	 */

	/* read the clock period: units are fempto (10^-15) seconds */

	hpetClockPeriod = HPET_COUNTER_CLK_PERIOD(*_HPET_GENERAL_CAPS);
  100363:	8b 0d 00 00 d0 fe    	mov    0xfed00000,%ecx
  100369:	8b 1d 04 00 d0 fe    	mov    0xfed00004,%ebx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  10036f:	89 d9                	mov    %ebx,%ecx
  100371:	31 db                	xor    %ebx,%ebx
  100373:	53                   	push   %ebx
  100374:	51                   	push   %ecx
  100375:	52                   	push   %edx
  100376:	50                   	push   %eax
  100377:	e8 24 fd ff ff       	call   1000a0 <__udivdi3>
  10037c:	31 db                	xor    %ebx,%ebx
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  10037e:	6b d0 64             	imul   $0x64,%eax,%edx
	PRINTK("HPET: timer0: available interrupts mask 0x%x\n",
	       (uint32_t)(*_HPET_TIMER0_CONFIG_CAPS >> 32));

	/* Initialize sys_clock_hw_cycles_per_tick/sec */

	sys_clock_hw_cycles_per_tick = counter_load_value;
  100381:	a3 34 1e 10 00       	mov    %eax,0x101e34
	sys_clock_hw_cycles_per_sec = sys_clock_hw_cycles_per_tick *
  100386:	89 15 30 1e 10 00    	mov    %edx,0x101e30
	/*
	 * Configure HPET replace legacy 8254 timer.
	 * In this case the timer0 interrupt is routed to IRQ2
	 * and legacy timer generates no interrupts
	 */
	*_HPET_GENERAL_CONFIG |= HPET_LEGACY_RT_CNF;
  10038c:	8b 15 10 00 d0 fe    	mov    0xfed00010,%edx
	/*
	 * compute value for the comparator register to achieve
	 * 'sys_clock_us_per_tick' period
	 */

	counter_load_value = (uint32_t)(tickFempto / hpetClockPeriod);
  100392:	83 c4 10             	add    $0x10,%esp
	/*
	 * Configure HPET replace legacy 8254 timer.
	 * In this case the timer0 interrupt is routed to IRQ2
	 * and legacy timer generates no interrupts
	 */
	*_HPET_GENERAL_CONFIG |= HPET_LEGACY_RT_CNF;
  100395:	83 ca 02             	or     $0x2,%edx
  100398:	89 15 10 00 d0 fe    	mov    %edx,0xfed00010
	 * Setting 32-bit mode during the first load of the comparator
	 * value is required to work around some hardware that otherwise
	 * does not work properly.
	 */

	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_TYPE_CNF | HPET_Tn_32MODE_CNF;
  10039e:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  1003a4:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  1003aa:	89 f2                	mov    %esi,%edx
  1003ac:	81 ca 08 01 00 00    	or     $0x108,%edx
  1003b2:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  1003b8:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104

	/*
	 * Set the comparator register for timer0.  The write to the comparator
	 * register is allowed due to setting the HPET_Tn_VAL_SET_CNF bit.
	 */
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_VAL_SET_CNF;
  1003be:	8b 35 00 01 d0 fe    	mov    0xfed00100,%esi
  1003c4:	8b 3d 04 01 d0 fe    	mov    0xfed00104,%edi
  1003ca:	89 f2                	mov    %esi,%edx
  1003cc:	83 ca 40             	or     $0x40,%edx
  1003cf:	89 15 00 01 d0 fe    	mov    %edx,0xfed00100
  1003d5:	89 3d 04 01 d0 fe    	mov    %edi,0xfed00104
	*_HPET_TIMER0_COMPARATOR = counter_load_value;
  1003db:	a3 08 01 d0 fe       	mov    %eax,0xfed00108
  1003e0:	89 1d 0c 01 d0 fe    	mov    %ebx,0xfed0010c
	/*
	 * After the comparator is loaded, 32-bit mode can be safely
	 * switched off
	 */
	*_HPET_TIMER0_CONFIG_CAPS &= ~HPET_Tn_32MODE_CNF;
  1003e6:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  1003ec:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  1003f2:	89 cf                	mov    %ecx,%edi
  1003f4:	81 e7 ff fe ff ff    	and    $0xfffffeff,%edi
  1003fa:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  100400:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
#if CONFIG_HPET_TIMER_IRQ < 32
		(*_HPET_TIMER0_CONFIG_CAPS & ~HPET_Tn_INT_ROUTE_CNF_MASK) |
  100406:	a1 00 01 d0 fe       	mov    0xfed00100,%eax
  10040b:	8b 15 04 01 d0 fe    	mov    0xfed00104,%edx
  100411:	89 c3                	mov    %eax,%ebx
  100413:	80 e7 c1             	and    $0xc1,%bh
  100416:	80 cf 04             	or     $0x4,%bh
	 * HPET timers IRQ field is 5 bits wide, and hence, can support only
	 * IRQ's up to 31. Some platforms, however, use IRQs greater than 31. In
	 * this case program leaves the IRQ fields blank.
	 */

	*_HPET_TIMER0_CONFIG_CAPS =
  100419:	89 1d 00 01 d0 fe    	mov    %ebx,0xfed00100
  10041f:	89 15 04 01 d0 fe    	mov    %edx,0xfed00104

	/*
	 * Although the stub has already been "connected", the vector number
	 * still has to be programmed into the interrupt controller.
	 */
	IRQ_CONNECT(CONFIG_HPET_TIMER_IRQ, CONFIG_HPET_TIMER_IRQ_PRIORITY,
  100425:	eb 11                	jmp    100438 <_sys_clock_driver_init+0x107>
  100427:	e8 cd 09 00 00       	call   100df9 <_IntEnt>
  10042c:	6a 00                	push   $0x0
  10042e:	e8 ed fe ff ff       	call   100320 <_timer_int_handler>
  100433:	e9 de 09 00 00       	jmp    100e16 <_IntExitWithEoi>
  100438:	0f b6 05 82 1d 10 00 	movzbl 0x101d82,%eax
  10043f:	6a 00                	push   $0x0
  100441:	6a 02                	push   $0x2
  100443:	50                   	push   %eax
  100444:	e8 4c 00 00 00       	call   100495 <_SysIntVecProgram>
  100449:	83 c4 0c             	add    $0xc,%esp
		   _timer_int_handler, 0, HPET_IOAPIC_FLAGS);

	/* enable the IRQ in the interrupt controller */

	irq_enable(CONFIG_HPET_TIMER_IRQ);
  10044c:	6a 02                	push   $0x2
  10044e:	e8 68 00 00 00       	call   1004bb <_arch_irq_enable>
  100453:	58                   	pop    %eax

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
  100454:	a1 10 00 d0 fe       	mov    0xfed00010,%eax
  100459:	83 c8 01             	or     $0x1,%eax
  10045c:	a3 10 00 d0 fe       	mov    %eax,0xfed00010
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;

	return 0;
}
  100461:	31 c0                	xor    %eax,%eax
	irq_enable(CONFIG_HPET_TIMER_IRQ);

	/* enable the HPET generally, and timer0 specifically */

	*_HPET_GENERAL_CONFIG |= HPET_ENABLE_CNF;
	*_HPET_TIMER0_CONFIG_CAPS |= HPET_Tn_INT_ENB_CNF;
  100463:	8b 0d 00 01 d0 fe    	mov    0xfed00100,%ecx
  100469:	8b 1d 04 01 d0 fe    	mov    0xfed00104,%ebx
  10046f:	89 cf                	mov    %ecx,%edi
  100471:	83 cf 04             	or     $0x4,%edi
  100474:	89 3d 00 01 d0 fe    	mov    %edi,0xfed00100
  10047a:	89 1d 04 01 d0 fe    	mov    %ebx,0xfed00104

	return 0;
}
  100480:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100483:	5b                   	pop    %ebx
  100484:	5e                   	pop    %esi
  100485:	5f                   	pop    %edi
  100486:	5d                   	pop    %ebp
  100487:	c3                   	ret    

00100488 <_i8259_init>:
 *
 * @return N/A
 */

int _i8259_init(struct device *unused)
{
  100488:	55                   	push   %ebp
/* Implementation of sys_io.h's documented functions */

static inline __attribute__((always_inline))
	void sys_out8(uint8_t data, io_port_t port)
{
	__asm__ volatile("outb	%b0, %w1;\n\t"
  100489:	b0 ff                	mov    $0xff,%al
  10048b:	89 e5                	mov    %esp,%ebp
  10048d:	e6 a1                	out    %al,$0xa1
  10048f:	e6 21                	out    %al,$0x21
	ARG_UNUSED(unused);
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_SLAVE_BASE_ADRS));
	sys_out8(PIC_DISABLE, PIC_PORT2(PIC_MASTER_BASE_ADRS));
	return 0;
}
  100491:	31 c0                	xor    %eax,%eax
  100493:	5d                   	pop    %ebp
  100494:	c3                   	ret    

00100495 <_SysIntVecProgram>:
 * @param irq the virtualized IRQ
 * @param flags interrupt flags
 *
 */
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
  100495:	55                   	push   %ebp
  100496:	89 e5                	mov    %esp,%ebp
  100498:	8b 45 0c             	mov    0xc(%ebp),%eax
  10049b:	8b 55 08             	mov    0x8(%ebp),%edx
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  10049e:	89 55 0c             	mov    %edx,0xc(%ebp)
 * @param flags interrupt flags
 *
 */
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
	if (IS_IOAPIC_IRQ(irq)) {
  1004a1:	83 f8 17             	cmp    $0x17,%eax
  1004a4:	77 09                	ja     1004af <_SysIntVecProgram+0x1a>
		_ioapic_irq_set(irq, vector, flags);
  1004a6:	89 45 08             	mov    %eax,0x8(%ebp)
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
	}
}
  1004a9:	5d                   	pop    %ebp
 *
 */
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
  1004aa:	e9 e6 01 00 00       	jmp    100695 <_ioapic_irq_set>
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  1004af:	83 e8 18             	sub    $0x18,%eax
  1004b2:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  1004b5:	5d                   	pop    %ebp
void _SysIntVecProgram(unsigned int vector, unsigned int irq, uint32_t flags)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_set(irq, vector, flags);
	} else {
		_loapic_int_vec_set(irq - LOAPIC_IRQ_BASE, vector);
  1004b6:	e9 df 00 00 00       	jmp    10059a <_loapic_int_vec_set>

001004bb <_arch_irq_enable>:
 * virtualization.
 *
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
  1004bb:	55                   	push   %ebp
  1004bc:	89 e5                	mov    %esp,%ebp
  1004be:	8b 45 08             	mov    0x8(%ebp),%eax
	if (IS_IOAPIC_IRQ(irq)) {
  1004c1:	83 f8 17             	cmp    $0x17,%eax
  1004c4:	77 06                	ja     1004cc <_arch_irq_enable+0x11>
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
	}
}
  1004c6:	5d                   	pop    %ebp
 * @return N/A
 */
void _arch_irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
  1004c7:	e9 b6 01 00 00       	jmp    100682 <_ioapic_irq_enable>
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  1004cc:	83 e8 18             	sub    $0x18,%eax
  1004cf:	89 45 08             	mov    %eax,0x8(%ebp)
	}
}
  1004d2:	5d                   	pop    %ebp
void _arch_irq_enable(unsigned int irq)
{
	if (IS_IOAPIC_IRQ(irq)) {
		_ioapic_irq_enable(irq);
	} else {
		_loapic_irq_enable(irq - LOAPIC_IRQ_BASE);
  1004d3:	e9 e4 00 00 00       	jmp    1005bc <_loapic_irq_enable>

001004d8 <_loapic_enable>:
 *
 * @return N/A
 */

void _loapic_enable(void)
{
  1004d8:	55                   	push   %ebp
  1004d9:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1004db:	9c                   	pushf  
  1004dc:	fa                   	cli    
  1004dd:	5a                   	pop    %edx
	int32_t oldLevel = irq_lock(); /* LOCK INTERRUPTS */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_SVR) |= LOAPIC_ENABLE;
  1004de:	a1 f0 00 e0 fe       	mov    0xfee000f0,%eax
  1004e3:	80 cc 01             	or     $0x1,%ah
  1004e6:	80 e6 02             	and    $0x2,%dh
  1004e9:	a3 f0 00 e0 fe       	mov    %eax,0xfee000f0
  1004ee:	74 01                	je     1004f1 <_loapic_enable+0x19>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  1004f0:	fb                   	sti    

	irq_unlock(oldLevel); /* UNLOCK INTERRUPTS */
}
  1004f1:	5d                   	pop    %ebp
  1004f2:	c3                   	ret    

001004f3 <_loapic_init>:
 * @return N/A
 *
 */

int _loapic_init(struct device *unused)
{
  1004f3:	55                   	push   %ebp
  1004f4:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(unused);
	int32_t loApicMaxLvt; /* local APIC Max LVT */

	/* enable the Local APIC */

	_loapic_enable();
  1004f6:	e8 dd ff ff ff       	call   1004d8 <_loapic_enable>

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  1004fb:	a1 30 00 e0 fe       	mov    0xfee00030,%eax
			LOAPIC_MAXLVT_MASK) >> 16;

	/* reset the DFR, TPR, TIMER_CONFIG, and TIMER_ICR */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_DFR) =
  100500:	c7 05 e0 00 e0 fe ff 	movl   $0xffffffff,0xfee000e0
  100507:	ff ff ff 
		(int)0xffffffff;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TPR) = (int)0x0;
  10050a:	c7 05 80 00 e0 fe 00 	movl   $0x0,0xfee00080
  100511:	00 00 00 
	*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_CONFIG) =
  100514:	c7 05 e0 03 e0 fe 00 	movl   $0x0,0xfee003e0
  10051b:	00 00 00 
		(int)0x0;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER_ICR) = (int)0x0;
  10051e:	c7 05 80 03 e0 fe 00 	movl   $0x0,0xfee00380
  100525:	00 00 00 
	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
  100528:	8b 15 50 03 e0 fe    	mov    0xfee00350,%edx

	/* enable the Local APIC */

	_loapic_enable();

	loApicMaxLvt = (*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_VER) &
  10052e:	25 00 00 ff 00       	and    $0xff0000,%eax
  100533:	c1 f8 10             	sar    $0x10,%eax

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) &
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  100536:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
  10053c:	80 ce 07             	or     $0x7,%dh

	/* program Local Vector Table for the Virtual Wire Mode */

	/* set LINT0: extInt, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT0) =
  10053f:	89 15 50 03 e0 fe    	mov    %edx,0xfee00350
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
		(*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) &
  100545:	8b 15 60 03 e0 fe    	mov    0xfee00360,%edx
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
  10054b:	81 e2 ff 58 fe ff    	and    $0xfffe58ff,%edx
  100551:	80 ce 04             	or     $0x4,%dh
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100554:	83 f8 03             	cmp    $0x3,%eax
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_EXT | LOAPIC_HIGH | LOAPIC_EDGE);

	/* set LINT1: NMI, high-polarity, edge-trigger, not-masked */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_LINT1) =
  100557:	89 15 60 03 e0 fe    	mov    %edx,0xfee00360
		 ~(LOAPIC_MODE | LOAPIC_LOW | LOAPIC_LEVEL | LOAPIC_LVT_MASKED)) |
		(LOAPIC_NMI | LOAPIC_HIGH | LOAPIC_EDGE);

	/* lock the Local APIC interrupts */

	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER) =
  10055d:	c7 05 20 03 e0 fe 00 	movl   $0x10000,0xfee00320
  100564:	00 01 00 
		LOAPIC_LVT_MASKED;
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ERROR) =
  100567:	c7 05 70 03 e0 fe 00 	movl   $0x10000,0xfee00370
  10056e:	00 01 00 
		LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_P6)
  100571:	7e 19                	jle    10058c <_loapic_init+0x99>
		*(volatile int *) (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_PMC) =
  100573:	c7 05 40 03 e0 fe 00 	movl   $0x10000,0xfee00340
  10057a:	00 01 00 
			LOAPIC_LVT_MASKED;

	if (loApicMaxLvt >= LOAPIC_LVT_PENTIUM4)
  10057d:	83 f8 04             	cmp    $0x4,%eax
  100580:	74 0a                	je     10058c <_loapic_init+0x99>
		*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_THERMAL) =
  100582:	c7 05 30 03 e0 fe 00 	movl   $0x10000,0xfee00330
  100589:	00 01 00 
static inline void _loapic_eoi(void)
{
#if CONFIG_EOI_FORWARDING_BUG
	_lakemont_eoi();
#endif
	*(volatile int *)(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI) = 0;
  10058c:	c7 05 b0 00 e0 fe 00 	movl   $0x0,0xfee000b0
  100593:	00 00 00 
#endif

	/* discard a pending interrupt if any */
	_loapic_eoi();
	return 0;
}
  100596:	31 c0                	xor    %eax,%eax
  100598:	5d                   	pop    %ebp
  100599:	c3                   	ret    

0010059a <_loapic_int_vec_set>:
 */

void _loapic_int_vec_set(unsigned int irq, /* IRQ number of the interrupt */
				  unsigned int vector /* vector to copy into the LVT */
				  )
{
  10059a:	55                   	push   %ebp
  10059b:	89 e5                	mov    %esp,%ebp
	 *   IRQ5 -> LOAPIC_ERROR
	 *
	 * It's assumed that LVTs are spaced by 0x10 bytes
	 */

	pLvt = (volatile int *)
  10059d:	8b 45 08             	mov    0x8(%ebp),%eax
  1005a0:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  1005a5:	c1 e0 04             	shl    $0x4,%eax

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1005a8:	9c                   	pushf  
  1005a9:	fa                   	cli    
  1005aa:	59                   	pop    %ecx
			(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* update the 'vector' bits in the LVT */

	oldLevel = irq_lock();
	*pLvt = (*pLvt & ~LOAPIC_VECTOR) | vector;
  1005ab:	8b 10                	mov    (%eax),%edx
  1005ad:	30 d2                	xor    %dl,%dl
  1005af:	0b 55 0c             	or     0xc(%ebp),%edx
  1005b2:	80 e5 02             	and    $0x2,%ch
  1005b5:	89 10                	mov    %edx,(%eax)
  1005b7:	74 01                	je     1005ba <_loapic_int_vec_set+0x20>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  1005b9:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1005ba:	5d                   	pop    %ebp
  1005bb:	c3                   	ret    

001005bc <_loapic_irq_enable>:
 *
 * @return N/A
 */

void _loapic_irq_enable(unsigned int irq)
{
  1005bc:	55                   	push   %ebp
  1005bd:	89 e5                	mov    %esp,%ebp
	/*
	 * See the comments in _LoApicLvtVecSet() regarding IRQ to LVT mappings
	 * and ths assumption concerning LVT spacing.
	 */

	pLvt = (volatile int *)
  1005bf:	8b 45 08             	mov    0x8(%ebp),%eax
  1005c2:	05 32 00 ee 0f       	add    $0xfee0032,%eax
  1005c7:	c1 e0 04             	shl    $0x4,%eax

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1005ca:	9c                   	pushf  
  1005cb:	fa                   	cli    
  1005cc:	59                   	pop    %ecx
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_TIMER + (irq * 0x10));

	/* clear the mask bit in the LVT */

	oldLevel = irq_lock();
	*pLvt = *pLvt & ~LOAPIC_LVT_MASKED;
  1005cd:	8b 10                	mov    (%eax),%edx
  1005cf:	81 e2 ff ff fe ff    	and    $0xfffeffff,%edx
  1005d5:	80 e5 02             	and    $0x2,%ch
  1005d8:	89 10                	mov    %edx,(%eax)
  1005da:	74 01                	je     1005dd <_loapic_irq_enable+0x21>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  1005dc:	fb                   	sti    
	irq_unlock(oldLevel);
}
  1005dd:	5d                   	pop    %ebp
  1005de:	c3                   	ret    

001005df <_loapic_isr_vector_get>:
 * --------------------
 *
 * @return The vector of the interrupt that is currently being processed.
 */
int _loapic_isr_vector_get(void)
{
  1005df:	55                   	push   %ebp
  1005e0:	ba 00 01 e0 fe       	mov    $0xfee00100,%edx
  1005e5:	89 e5                	mov    %esp,%ebp
	/* pointer to ISR vector table */
	volatile int *pReg;
	int block = 0;
  1005e7:	31 c9                	xor    %ecx,%ecx

	while (block < 8) {
		pReg = (volatile int *)
		(CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_ISR + (block * 0x10));
		if (*pReg) {
  1005e9:	8b 02                	mov    (%edx),%eax
  1005eb:	85 c0                	test   %eax,%eax
  1005ed:	74 14                	je     100603 <_loapic_isr_vector_get+0x24>
			return (block * 32) + (find_lsb_set(*pReg) - 1);
  1005ef:	8b 12                	mov    (%edx),%edx

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
	unsigned int bitpos;

	__asm__ volatile (
  1005f1:	0f bc d2             	bsf    %edx,%edx
  1005f4:	75 05                	jne    1005fb <_loapic_isr_vector_get+0x1c>
  1005f6:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  1005fb:	c1 e1 05             	shl    $0x5,%ecx
  1005fe:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  100601:	eb 09                	jmp    10060c <_loapic_isr_vector_get+0x2d>
		}
		block++;
  100603:	41                   	inc    %ecx
  100604:	83 c2 10             	add    $0x10,%edx
{
	/* pointer to ISR vector table */
	volatile int *pReg;
	int block = 0;

	while (block < 8) {
  100607:	83 f9 08             	cmp    $0x8,%ecx
  10060a:	75 dd                	jne    1005e9 <_loapic_isr_vector_get+0xa>
		}
		block++;
	}

	return 0;
}
  10060c:	5d                   	pop    %ebp
  10060d:	c3                   	ret    

0010060e <__IoApicSet>:
 * @param offset Register offset (8 bits)
 * @param value Value to set the register
 * @return N/A
 */
static void __IoApicSet(int32_t offset, uint32_t value)
{
  10060e:	55                   	push   %ebp
  10060f:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100611:	9c                   	pushf  
  100612:	fa                   	cli    
  100613:	59                   	pop    %ecx
  100614:	80 e5 02             	and    $0x2,%ch

	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*(volatile char *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND) = (char)offset;
  100617:	a2 00 00 c0 fe       	mov    %al,0xfec00000
	*((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA)) = value;
  10061c:	89 15 10 00 c0 fe    	mov    %edx,0xfec00010
  100622:	74 01                	je     100625 <__IoApicSet+0x17>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100624:	fb                   	sti    

	irq_unlock(key);
}
  100625:	5d                   	pop    %ebp
  100626:	c3                   	ret    

00100627 <_IoApicRedUpdateLo>:
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  100627:	55                   	push   %ebp
 * @param irq INTIN number
 * @return 32 low-order bits
 */
static uint32_t ioApicRedGetLo(unsigned int irq)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */
  100628:	8d 44 00 10          	lea    0x10(%eax,%eax,1),%eax
 * @return N/A
 */
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
  10062c:	89 e5                	mov    %esp,%ebp
  10062e:	56                   	push   %esi
  10062f:	53                   	push   %ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100630:	9c                   	pushf  
  100631:	fa                   	cli    
  100632:	5e                   	pop    %esi
	/* lock interrupts to ensure indirect addressing works "atomically" */

	key = irq_lock();

	*((volatile char *)
		(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_IND)) = (char)offset;
  100633:	a2 00 00 c0 fe       	mov    %al,0xfec00000
  100638:	81 e6 00 02 00 00    	and    $0x200,%esi
	value = *((volatile uint32_t *)(CONFIG_IOAPIC_BASE_ADDRESS + IOAPIC_DATA));
  10063e:	8b 1d 10 00 c0 fe    	mov    0xfec00010,%ebx
  100644:	74 01                	je     100647 <_IoApicRedUpdateLo+0x20>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100646:	fb                   	sti    
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  100647:	31 da                	xor    %ebx,%edx
  100649:	21 ca                	and    %ecx,%edx
  10064b:	31 da                	xor    %ebx,%edx
static void _IoApicRedUpdateLo(unsigned int irq,
				uint32_t value,
				uint32_t mask)
{
	ioApicRedSetLo(irq, (ioApicRedGetLo(irq) & ~mask) | (value & mask));
}
  10064d:	5b                   	pop    %ebx
  10064e:	5e                   	pop    %esi
  10064f:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  100650:	e9 b9 ff ff ff       	jmp    10060e <__IoApicSet>

00100655 <_ioapic_init>:
 * This routine initializes the IO APIC or xAPIC.
 *
 * @return N/A
 */
int _ioapic_init(struct device *unused)
{
  100655:	55                   	push   %ebp
  100656:	89 e5                	mov    %esp,%ebp
  100658:	56                   	push   %esi
  100659:	53                   	push   %ebx
	 */

	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  10065a:	31 db                	xor    %ebx,%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10065c:	8d 34 1b             	lea    (%ebx,%ebx,1),%esi

	__IoApicSet(offset, upper32);
  10065f:	31 d2                	xor    %edx,%edx
	 */

	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  100661:	43                   	inc    %ebx
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  100662:	8d 46 11             	lea    0x11(%esi),%eax
  100665:	e8 a4 ff ff ff       	call   10060e <__IoApicSet>
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  10066a:	8d 46 10             	lea    0x10(%esi),%eax
  10066d:	ba 00 00 01 00       	mov    $0x10000,%edx
  100672:	e8 97 ff ff ff       	call   10060e <__IoApicSet>
	 */

	rteValue = IOAPIC_EDGE | IOAPIC_HIGH | IOAPIC_FIXED | IOAPIC_INT_MASK |
		   IOAPIC_PHYSICAL | 0 /* dummy vector */;

	for (ix = 0; ix < CONFIG_IOAPIC_NUM_RTES; ix++) {
  100677:	83 fb 18             	cmp    $0x18,%ebx
  10067a:	75 e0                	jne    10065c <_ioapic_init+0x7>
		ioApicRedSetHi(ix, 0);
		ioApicRedSetLo(ix, rteValue);
	}
	return 0;
}
  10067c:	5b                   	pop    %ebx
  10067d:	31 c0                	xor    %eax,%eax
  10067f:	5e                   	pop    %esi
  100680:	5d                   	pop    %ebp
  100681:	c3                   	ret    

00100682 <_ioapic_irq_enable>:
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
  100682:	55                   	push   %ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100683:	b9 00 00 01 00       	mov    $0x10000,%ecx
 * @param irq IRQ number to enable
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
  100688:	89 e5                	mov    %esp,%ebp
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  10068a:	31 d2                	xor    %edx,%edx
  10068c:	8b 45 08             	mov    0x8(%ebp),%eax
}
  10068f:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void _ioapic_irq_enable(unsigned int irq)
{
	_IoApicRedUpdateLo(irq, 0, IOAPIC_INT_MASK);
  100690:	e9 92 ff ff ff       	jmp    100627 <_IoApicRedUpdateLo>

00100695 <_ioapic_irq_set>:
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
  100695:	55                   	push   %ebp
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  100696:	31 d2                	xor    %edx,%edx
 * @param flags Interrupt flags
 *
 * @return N/A
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
  100698:	89 e5                	mov    %esp,%ebp
  10069a:	56                   	push   %esi
  10069b:	53                   	push   %ebx
  10069c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 * @param upper32 Value to be written
 * @return N/A
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */
  10069f:	01 db                	add    %ebx,%ebx
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  1006a1:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  1006a5:	8d 43 11             	lea    0x11(%ebx),%eax
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  1006a8:	0b 75 10             	or     0x10(%ebp),%esi
 */
static void ioApicRedSetHi(unsigned int irq, uint32_t upper32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1) + 1; /* register offset */

	__IoApicSet(offset, upper32);
  1006ab:	e8 5e ff ff ff       	call   10060e <__IoApicSet>
 */
void _ioapic_irq_set(unsigned int irq, unsigned int vector, uint32_t flags)
{
	uint32_t rteValue;   /* value to copy into redirection table entry */

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
  1006b0:	81 ce 00 00 01 00    	or     $0x10000,%esi
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1006b6:	8d 43 10             	lea    0x10(%ebx),%eax
  1006b9:	89 f2                	mov    %esi,%edx

	rteValue = IOAPIC_FIXED | IOAPIC_INT_MASK | IOAPIC_PHYSICAL |
		   (vector & IOAPIC_VEC_MASK) | flags;
	ioApicRedSetHi(irq, 0);
	ioApicRedSetLo(irq, rteValue);
}
  1006bb:	5b                   	pop    %ebx
  1006bc:	5e                   	pop    %esi
  1006bd:	5d                   	pop    %ebp
 */
static void ioApicRedSetLo(unsigned int irq, uint32_t lower32)
{
	int32_t offset = IOAPIC_REDTBL + (irq << 1); /* register offset */

	__IoApicSet(offset, lower32);
  1006be:	e9 4b ff ff ff       	jmp    10060e <__IoApicSet>

001006c3 <main>:
 * Nanokernel version of hello world demo
 */


void main(void)
{
  1006c3:	55                   	push   %ebp
  1006c4:	89 e5                	mov    %esp,%ebp
  1006c6:	56                   	push   %esi
  1006c7:	53                   	push   %ebx
  1006c8:	83 ec 20             	sub    $0x20,%esp
	struct nano_timer timer;
	void *timer_data[1];
	
	nano_timer_init(&timer, timer_data);
  1006cb:	8d 45 d8             	lea    -0x28(%ebp),%eax
  1006ce:	8d 5d dc             	lea    -0x24(%ebp),%ebx
  1006d1:	50                   	push   %eax
  1006d2:	53                   	push   %ebx
  1006d3:	e8 4c 03 00 00       	call   100a24 <nano_timer_init>
  1006d8:	58                   	pop    %eax

	int v1 = 0;
  1006d9:	31 c0                	xor    %eax,%eax
void main(void)
{
	struct nano_timer timer;
	void *timer_data[1];
	
	nano_timer_init(&timer, timer_data);
  1006db:	5a                   	pop    %edx

	int v1 = 0;
	int v2 = 100;
	while(1) {
		PRINT("{\"ch-1\": %d, \"ch-2\": %d}\n", v1++, v2++);
  1006dc:	8d 50 64             	lea    0x64(%eax),%edx
  1006df:	8d 70 01             	lea    0x1(%eax),%esi
  1006e2:	52                   	push   %edx
  1006e3:	50                   	push   %eax
  1006e4:	68 0e 13 10 00       	push   $0x10130e
  1006e9:	e8 37 05 00 00       	call   100c25 <printk>
  1006ee:	83 c4 0c             	add    $0xc,%esp
		nano_timer_start(&timer, SLEEPTICKS);
  1006f1:	6a 14                	push   $0x14
  1006f3:	53                   	push   %ebx
  1006f4:	e8 55 03 00 00       	call   100a4e <_timer_start>
  1006f9:	58                   	pop    %eax
  1006fa:	5a                   	pop    %edx
		nano_timer_test(&timer, TICKS_UNLIMITED);
  1006fb:	6a ff                	push   $0xffffffff
  1006fd:	53                   	push   %ebx
  1006fe:	e8 e1 03 00 00       	call   100ae4 <nano_timer_test>
  100703:	59                   	pop    %ecx
  100704:	58                   	pop    %eax
	nano_timer_init(&timer, timer_data);

	int v1 = 0;
	int v2 = 100;
	while(1) {
		PRINT("{\"ch-1\": %d, \"ch-2\": %d}\n", v1++, v2++);
  100705:	89 f0                	mov    %esi,%eax
  100707:	eb d3                	jmp    1006dc <main+0x19>

00100709 <strcmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  100709:	55                   	push   %ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  10070a:	31 c9                	xor    %ecx,%ecx
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
  10070c:	89 e5                	mov    %esp,%ebp
	while ((*s1 == *s2) && (*s1 != '\0')) {
  10070e:	8b 45 08             	mov    0x8(%ebp),%eax
  100711:	8b 55 0c             	mov    0xc(%ebp),%edx
  100714:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  100718:	0f be 14 0a          	movsbl (%edx,%ecx,1),%edx
  10071c:	38 d0                	cmp    %dl,%al
  10071e:	75 08                	jne    100728 <strcmp+0x1f>
  100720:	41                   	inc    %ecx
  100721:	84 c0                	test   %al,%al
  100723:	75 e9                	jne    10070e <strcmp+0x5>
  100725:	0f be d0             	movsbl %al,%edx
		s1++;
		s2++;
	}

	return *s1 - *s2;
  100728:	29 d0                	sub    %edx,%eax
}
  10072a:	5d                   	pop    %ebp
  10072b:	c3                   	ret    

0010072c <_nano_fiber_ready>:
 * while this routine is executing!
 *
 * @return N/A
 */
void _nano_fiber_ready(struct tcs *tcs)
{
  10072c:	55                   	push   %ebp
	struct tcs *pQ = (struct tcs *)&_nanokernel.fiber;
  10072d:	ba e0 1e 10 00       	mov    $0x101ee0,%edx
 * while this routine is executing!
 *
 * @return N/A
 */
void _nano_fiber_ready(struct tcs *tcs)
{
  100732:	89 e5                	mov    %esp,%ebp
  100734:	53                   	push   %ebx
  100735:	8b 4d 08             	mov    0x8(%ebp),%ecx
	/*
	 * Search until end of list or until a fiber with numerically
	 * higher priority is located.
	 */

	while (pQ->link && (tcs->prio >= pQ->link->prio)) {
  100738:	8b 02                	mov    (%edx),%eax
  10073a:	85 c0                	test   %eax,%eax
  10073c:	74 0c                	je     10074a <_nano_fiber_ready+0x1e>
  10073e:	8b 58 0c             	mov    0xc(%eax),%ebx
  100741:	39 59 0c             	cmp    %ebx,0xc(%ecx)
  100744:	7c 04                	jl     10074a <_nano_fiber_ready+0x1e>
  100746:	89 c2                	mov    %eax,%edx
  100748:	eb ee                	jmp    100738 <_nano_fiber_ready+0xc>
		pQ = pQ->link;
	}

	/* Insert fiber, following any equal priority fibers */

	tcs->link = pQ->link;
  10074a:	89 01                	mov    %eax,(%ecx)
	pQ->link = tcs;
  10074c:	89 0a                	mov    %ecx,(%edx)
}
  10074e:	5b                   	pop    %ebx
  10074f:	5d                   	pop    %ebp
  100750:	c3                   	ret    

00100751 <_nano_fiber_swap>:
 * This routine can only be called from a fiber.
 *
 * @return This function never returns
 */
FUNC_NORETURN void _nano_fiber_swap(void)
{
  100751:	55                   	push   %ebp
  100752:	89 e5                	mov    %esp,%ebp

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100754:	9c                   	pushf  
  100755:	fa                   	cli    
  100756:	58                   	pop    %eax
	 * switch to the highest priority fiber, or the highest priority task
	 * if there are no runnable fibers.
	 */

	imask = irq_lock();
	_Swap(imask);
  100757:	50                   	push   %eax
  100758:	e8 0a 07 00 00       	call   100e67 <_Swap>
  10075d:	58                   	pop    %eax

0010075e <fiber_abort>:
	CODE_UNREACHABLE;
}

#ifndef CONFIG_ARCH_HAS_NANO_FIBER_ABORT
FUNC_NORETURN void fiber_abort(void)
{
  10075e:	55                   	push   %ebp
  10075f:	89 e5                	mov    %esp,%ebp
	/* Do normal thread exit cleanup, then give up CPU control */

	_thread_exit(_nanokernel.current);
	_nano_fiber_swap();
  100761:	e8 eb ff ff ff       	call   100751 <_nano_fiber_swap>

00100766 <_nano_sys_clock_tick_announce>:
 * timers that have expired and wake up the fibers pending on them.
 *
 * @return N/A
 */
void _nano_sys_clock_tick_announce(int32_t ticks)
{
  100766:	55                   	push   %ebp
  100767:	89 e5                	mov    %esp,%ebp
  100769:	56                   	push   %esi
  10076a:	53                   	push   %ebx
  10076b:	8b 55 08             	mov    0x8(%ebp),%edx
  10076e:	9c                   	pushf  
  10076f:	fa                   	cli    
  100770:	5e                   	pop    %esi
	unsigned int  key;

	key = irq_lock();
	_sys_clock_tick_count += ticks;
  100771:	89 d3                	mov    %edx,%ebx
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  100773:	a1 f4 1e 10 00       	mov    0x101ef4,%eax
  100778:	c1 fb 1f             	sar    $0x1f,%ebx
  10077b:	01 15 00 1f 10 00    	add    %edx,0x101f00
  100781:	11 1d 04 1f 10 00    	adc    %ebx,0x101f04
 * @return a pointer to the head element from a node, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  100787:	3d f4 1e 10 00       	cmp    $0x101ef4,%eax
  10078c:	75 02                	jne    100790 <_nano_sys_clock_tick_announce+0x2a>
  10078e:	31 c0                	xor    %eax,%eax
static inline void handle_expired_nano_timeouts(int32_t ticks)
{
	struct _nano_timeout *head =
		(struct _nano_timeout *)sys_dlist_peek_head(&_nanokernel.timeout_q);

	_nanokernel.task_timeout = TICKS_UNLIMITED;
  100790:	c7 05 fc 1e 10 00 ff 	movl   $0xffffffff,0x101efc
  100797:	ff ff ff 
	if (head) {
  10079a:	85 c0                	test   %eax,%eax
  10079c:	75 0b                	jne    1007a9 <_nano_sys_clock_tick_announce+0x43>
  10079e:	81 e6 00 02 00 00    	and    $0x200,%esi
  1007a4:	74 54                	je     1007fa <_nano_sys_clock_tick_announce+0x94>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  1007a6:	fb                   	sti    

	key = irq_lock();
	_sys_clock_tick_count += ticks;
	handle_expired_nano_timeouts(ticks);
	irq_unlock(key);
}
  1007a7:	eb 51                	jmp    1007fa <_nano_sys_clock_tick_announce+0x94>
	struct _nano_timeout *head =
		(struct _nano_timeout *)sys_dlist_peek_head(&_nanokernel.timeout_q);

	_nanokernel.task_timeout = TICKS_UNLIMITED;
	if (head) {
		head->delta_ticks_from_prev -= ticks;
  1007a9:	29 50 10             	sub    %edx,0x10(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1007ac:	a1 f4 1e 10 00       	mov    0x101ef4,%eax
 * @return a pointer to the head element from a node, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  1007b1:	3d f4 1e 10 00       	cmp    $0x101ef4,%eax
  1007b6:	74 e6                	je     10079e <_nano_sys_clock_tick_announce+0x38>
{
	sys_dlist_t *timeout_q = &_nanokernel.timeout_q;
	struct _nano_timeout *next;

	next = (struct _nano_timeout *)sys_dlist_peek_head(timeout_q);
	while (next && next->delta_ticks_from_prev == 0) {
  1007b8:	85 c0                	test   %eax,%eax
  1007ba:	74 e2                	je     10079e <_nano_sys_clock_tick_announce+0x38>
  1007bc:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  1007c0:	75 dc                	jne    10079e <_nano_sys_clock_tick_announce+0x38>
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  1007c2:	8b 1d f4 1e 10 00    	mov    0x101ef4,%ebx

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node;

	if (sys_dlist_is_empty(list)) {
  1007c8:	81 fb f4 1e 10 00    	cmp    $0x101ef4,%ebx
  1007ce:	74 23                	je     1007f3 <_nano_sys_clock_tick_announce+0x8d>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
  1007d0:	8b 43 04             	mov    0x4(%ebx),%eax
  1007d3:	8b 13                	mov    (%ebx),%edx
  1007d5:	89 10                	mov    %edx,(%eax)
	node->next->prev = node->prev;
  1007d7:	8b 13                	mov    (%ebx),%edx
  1007d9:	89 42 04             	mov    %eax,0x4(%edx)

static inline struct _nano_timeout *_nano_timeout_handle_one_timeout(
	sys_dlist_t *timeout_q)
{
	struct _nano_timeout *t = (void *)sys_dlist_get(timeout_q);
	struct tcs *tcs = t->tcs;
  1007dc:	8b 43 08             	mov    0x8(%ebx),%eax

	if (tcs != NULL) {
  1007df:	85 c0                	test   %eax,%eax
  1007e1:	74 07                	je     1007ea <_nano_sys_clock_tick_announce+0x84>
		_nano_timeout_object_dequeue(tcs, t);
		_nano_fiber_ready(tcs);
  1007e3:	50                   	push   %eax
  1007e4:	e8 43 ff ff ff       	call   10072c <_nano_fiber_ready>
  1007e9:	58                   	pop    %eax
	}
	t->delta_ticks_from_prev = -1;
  1007ea:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)
  1007f1:	eb b9                	jmp    1007ac <_nano_sys_clock_tick_announce+0x46>

static inline struct _nano_timeout *_nano_timeout_handle_one_timeout(
	sys_dlist_t *timeout_q)
{
	struct _nano_timeout *t = (void *)sys_dlist_get(timeout_q);
	struct tcs *tcs = t->tcs;
  1007f3:	a1 08 00 00 00       	mov    0x8,%eax
  1007f8:	0f 0b                	ud2    

	key = irq_lock();
	_sys_clock_tick_count += ticks;
	handle_expired_nano_timeouts(ticks);
	irq_unlock(key);
}
  1007fa:	8d 65 f8             	lea    -0x8(%ebp),%esp
  1007fd:	5b                   	pop    %ebx
  1007fe:	5e                   	pop    %esi
  1007ff:	5d                   	pop    %ebp
  100800:	c3                   	ret    

00100801 <sys_thread_self_get>:
#include <sys_clock.h>
#include <drivers/system_timer.h>


nano_thread_id_t sys_thread_self_get(void)
{
  100801:	55                   	push   %ebp
	return _nanokernel.current;
}
  100802:	a1 e8 1e 10 00       	mov    0x101ee8,%eax
#include <sys_clock.h>
#include <drivers/system_timer.h>


nano_thread_id_t sys_thread_self_get(void)
{
  100807:	89 e5                	mov    %esp,%ebp
	return _nanokernel.current;
}
  100809:	5d                   	pop    %ebp
  10080a:	c3                   	ret    

0010080b <sys_execution_context_type_get>:

nano_context_type_t sys_execution_context_type_get(void)
{
  10080b:	55                   	push   %ebp
  10080c:	31 c0                	xor    %eax,%eax
  10080e:	89 e5                	mov    %esp,%ebp
	if (_IS_IN_ISR())
  100810:	83 3d ec 1e 10 00 00 	cmpl   $0x0,0x101eec
  100817:	75 13                	jne    10082c <sys_execution_context_type_get+0x21>
		return NANO_CTX_ISR;

	if ((_nanokernel.current->flags & TASK) == TASK)
  100819:	a1 e8 1e 10 00       	mov    0x101ee8,%eax
  10081e:	8b 40 04             	mov    0x4(%eax),%eax
  100821:	83 e0 01             	and    $0x1,%eax
		return NANO_CTX_TASK;

	return NANO_CTX_FIBER;
  100824:	83 f8 01             	cmp    $0x1,%eax
  100827:	19 c0                	sbb    %eax,%eax
  100829:	83 c0 02             	add    $0x2,%eax
}
  10082c:	5d                   	pop    %ebp
  10082d:	c3                   	ret    

0010082e <_is_thread_essential>:
 * @param pCtx Pointer to the thread
 *
 * @return Non-zero if specified thread is essential, zero if it is not
 */
int _is_thread_essential(struct tcs *pCtx)
{
  10082e:	55                   	push   %ebp
  10082f:	89 e5                	mov    %esp,%ebp
  100831:	8b 45 08             	mov    0x8(%ebp),%eax
	return ((pCtx == NULL) ? _nanokernel.current : pCtx)->flags & ESSENTIAL;
  100834:	85 c0                	test   %eax,%eax
  100836:	75 05                	jne    10083d <_is_thread_essential+0xf>
  100838:	a1 e8 1e 10 00       	mov    0x101ee8,%eax
  10083d:	8b 40 04             	mov    0x4(%eax),%eax
}
  100840:	5d                   	pop    %ebp
 *
 * @return Non-zero if specified thread is essential, zero if it is not
 */
int _is_thread_essential(struct tcs *pCtx)
{
	return ((pCtx == NULL) ? _nanokernel.current : pCtx)->flags & ESSENTIAL;
  100841:	25 00 02 00 00       	and    $0x200,%eax
}
  100846:	c3                   	ret    

00100847 <_thread_entry>:
 */
FUNC_NORETURN void _thread_entry(_thread_entry_t pEntry,
					_thread_arg_t parameter1,
					_thread_arg_t parameter2,
					_thread_arg_t parameter3)
{
  100847:	55                   	push   %ebp
  100848:	89 e5                	mov    %esp,%ebp
	/* Execute the "application" entry point function */

	pEntry(parameter1, parameter2, parameter3);
  10084a:	ff 75 14             	pushl  0x14(%ebp)
  10084d:	ff 75 10             	pushl  0x10(%ebp)
  100850:	ff 75 0c             	pushl  0xc(%ebp)
  100853:	ff 55 08             	call   *0x8(%ebp)

	/* Determine if thread can legally terminate itself via "return" */

	if (_is_thread_essential(NULL)) {
  100856:	a1 e8 1e 10 00       	mov    0x101ee8,%eax
					_thread_arg_t parameter2,
					_thread_arg_t parameter3)
{
	/* Execute the "application" entry point function */

	pEntry(parameter1, parameter2, parameter3);
  10085b:	83 c4 0c             	add    $0xc,%esp

	/* Determine if thread can legally terminate itself via "return" */

	if (_is_thread_essential(NULL)) {
  10085e:	f6 40 05 02          	testb  $0x2,0x5(%eax)
  100862:	74 1e                	je     100882 <_thread_entry+0x3b>
		/*
		 * Nanokernel's background task must always be present,
		 * so if it has nothing left to do just let it idle forever
		 */

		while (((_nanokernel.current)->flags & TASK) == TASK) {
  100864:	a1 e8 1e 10 00       	mov    0x101ee8,%eax
  100869:	f6 40 04 01          	testb  $0x1,0x4(%eax)
  10086d:	74 07                	je     100876 <_thread_entry+0x2f>
			nano_cpu_idle();
  10086f:	e8 73 08 00 00       	call   1010e7 <nano_cpu_idle>
  100874:	eb ee                	jmp    100864 <_thread_entry+0x1d>
		}
#endif /*  CONFIG_NANOKERNEL */

		/* Loss of essential thread is a system fatal error */

		_NanoFatalErrorHandler(_NANO_ERR_INVALID_TASK_EXIT,
  100876:	68 40 15 10 00       	push   $0x101540
  10087b:	6a 03                	push   $0x3
  10087d:	e8 73 06 00 00       	call   100ef5 <_NanoFatalErrorHandler>
		extern FUNC_NORETURN void _TaskAbort(void);
		_TaskAbort();
	} else
#endif /* CONFIG_MICROKERNEL */
	{
		fiber_abort();
  100882:	e8 d7 fe ff ff       	call   10075e <fiber_abort>

00100887 <_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void _main(void)
{
  100887:	55                   	push   %ebp
  100888:	89 e5                	mov    %esp,%ebp
	_sys_device_do_config_level(_SYS_INIT_LEVEL_SECONDARY);
  10088a:	6a 01                	push   $0x1
  10088c:	e8 cf 00 00 00       	call   100960 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_NANOKERNEL);
  100891:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100898:	e8 c3 00 00 00       	call   100960 <_sys_device_do_config_level>
	_sys_device_do_config_level(_SYS_INIT_LEVEL_APPLICATION);
  10089d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1008a4:	e8 b7 00 00 00       	call   100960 <_sys_device_do_config_level>
  1008a9:	58                   	pop    %eax
	__do_init_array_aux();
#endif

	extern void main(void);
	main();
}
  1008aa:	c9                   	leave  
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	extern void main(void);
	main();
  1008ab:	e9 13 fe ff ff       	jmp    1006c3 <main>

001008b0 <_Cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void _Cstart(void)
{
  1008b0:	55                   	push   %ebp
  1008b1:	89 e5                	mov    %esp,%ebp
  1008b3:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Initialize the thread control block (TCS) for the main task (either
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;
  1008b6:	c7 05 e4 1e 10 00 40 	movl   $0x102740,0x101ee4
  1008bd:	27 10 00 
	 * initialization.
	 * However, don't waste effort initializing the fields of the dummy
	 * thread beyond those needed to identify it as a dummy thread.
	 */

	_nanokernel.current = dummyOutContext;
  1008c0:	8d 45 ec             	lea    -0x14(%ebp),%eax
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
  1008c3:	6a 00                	push   $0x0
	 * initialization.
	 * However, don't waste effort initializing the fields of the dummy
	 * thread beyond those needed to identify it as a dummy thread.
	 */

	_nanokernel.current = dummyOutContext;
  1008c5:	a3 e8 1e 10 00       	mov    %eax,0x101ee8
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
  1008ca:	6a ff                	push   $0xffffffff

	/*
	 * Do not insert dummy execution context in the list of fibers, so that
	 * it does not get scheduled back in once context-switched out.
	 */
	dummyOutContext->link = (struct tcs *)NULL;
  1008cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
  1008d3:	6a 00                	push   $0x0
	 * Do not insert dummy execution context in the list of fibers, so that
	 * it does not get scheduled back in once context-switched out.
	 */
	dummyOutContext->link = (struct tcs *)NULL;

	dummyOutContext->flags = FIBER | ESSENTIAL;
  1008d5:	c7 45 f0 00 02 00 00 	movl   $0x200,-0x10(%ebp)
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
  1008dc:	6a 00                	push   $0x0
	 * it does not get scheduled back in once context-switched out.
	 */
	dummyOutContext->link = (struct tcs *)NULL;

	dummyOutContext->flags = FIBER | ESSENTIAL;
	dummyOutContext->prio = 0;
  1008de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
  1008e5:	6a 00                	push   $0x0
  1008e7:	68 87 08 10 00       	push   $0x100887
  1008ec:	68 00 04 00 00       	push   $0x400
  1008f1:	68 40 27 10 00       	push   $0x102740
  1008f6:	e8 9c 05 00 00       	call   100e97 <_new_thread>

	/* indicate that failure of this task may be fatal to the entire
	 * system
	 */

	_nanokernel.task->flags |= ESSENTIAL;
  1008fb:	a1 e4 1e 10 00       	mov    0x101ee4,%eax
	 * background or idle task). The entry point for this thread is '_main'.
	 */

	_nanokernel.task = (struct tcs *) main_task_stack;

	_new_thread(main_task_stack,	/* pStackMem */
  100900:	83 c4 20             	add    $0x20,%esp
	 * Forces the inclusion of the spurious interrupt handlers. If a
	 * reference isn't made then intconnect.o is never pulled in by the
	 * linker.
	 */

	_dummy_spurious_interrupt = &__isr___SpuriousIntHandler;
  100903:	c7 05 20 1f 10 00 00 	movl   $0x800,0x101f20
  10090a:	08 00 00 
	 * Forces the inclusion of the exception vector stub code. If a
	 * reference isn't made then excstubs.o is never pulled in by the
	 * linker.
	 */

	_dummy_exception_vector_stub = &_ExcEnt;
  10090d:	c7 05 18 1f 10 00 71 	movl   $0x101171,0x101f18
  100914:	11 10 00 

	/* indicate that failure of this task may be fatal to the entire
	 * system
	 */

	_nanokernel.task->flags |= ESSENTIAL;
  100917:	81 48 04 00 02 00 00 	orl    $0x200,0x4(%eax)
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];
	extern void _ExcEnt(void);

	_nanokernel.nested = 0;

	_nanokernel.common_isp = (char *)STACK_ROUND_DOWN(
  10091e:	b8 3f 27 10 00       	mov    $0x10273f,%eax

	nano_init((struct tcs *)&dummyTCS);

	/* perform basic hardware initialization */

	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  100923:	6a 00                	push   $0x0
  100925:	83 e0 fc             	and    $0xfffffffc,%eax
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
  100928:	c7 05 f4 1e 10 00 f4 	movl   $0x101ef4,0x101ef4
  10092f:	1e 10 00 
  100932:	a3 f0 1e 10 00       	mov    %eax,0x101ef0
	list->tail = (sys_dnode_t *)list;
  100937:	c7 05 f8 1e 10 00 f4 	movl   $0x101ef4,0x101ef8
  10093e:	1e 10 00 
	 * system
	 */

	_nanokernel.task->flags |= ESSENTIAL;

	initialize_nano_timeouts();
  100941:	c7 05 fc 1e 10 00 ff 	movl   $0xffffffff,0x101efc
  100948:	ff ff ff 
	extern void *_dummy_spurious_interrupt;
	extern void *_dummy_exception_vector_stub;
	extern char _interrupt_stack[CONFIG_ISR_STACK_SIZE];
	extern void _ExcEnt(void);

	_nanokernel.nested = 0;
  10094b:	c7 05 ec 1e 10 00 00 	movl   $0x0,0x101eec
  100952:	00 00 00 

	nano_init((struct tcs *)&dummyTCS);

	/* perform basic hardware initialization */

	_sys_device_do_config_level(_SYS_INIT_LEVEL_PRIMARY);
  100955:	e8 06 00 00 00       	call   100960 <_sys_device_do_config_level>
  10095a:	58                   	pop    %eax

	PRINT_BOOT_BANNER();

	/* context switch to main task (entry function is _main()) */

	_nano_fiber_swap();
  10095b:	e8 f1 fd ff ff       	call   100751 <_nano_fiber_swap>

00100960 <_sys_device_do_config_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void _sys_device_do_config_level(int level)
{
  100960:	55                   	push   %ebp
  100961:	89 e5                	mov    %esp,%ebp
  100963:	56                   	push   %esi
  100964:	53                   	push   %ebx
  100965:	8b 75 08             	mov    0x8(%ebp),%esi
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  100968:	8b 1c b5 28 13 10 00 	mov    0x101328(,%esi,4),%ebx
  10096f:	3b 1c b5 2c 13 10 00 	cmp    0x10132c(,%esi,4),%ebx
  100976:	73 0c                	jae    100984 <_sys_device_do_config_level+0x24>
		struct device_config *device = info->config;

		device->init(info);
  100978:	8b 03                	mov    (%ebx),%eax
  10097a:	53                   	push   %ebx
 */
void _sys_device_do_config_level(int level)
{
	struct device *info;

	for (info = config_levels[level]; info < config_levels[level+1]; info++) {
  10097b:	83 c3 0c             	add    $0xc,%ebx
		struct device_config *device = info->config;

		device->init(info);
  10097e:	ff 50 04             	call   *0x4(%eax)
  100981:	58                   	pop    %eax
  100982:	eb eb                	jmp    10096f <_sys_device_do_config_level+0xf>
	}
}
  100984:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100987:	5b                   	pop    %ebx
  100988:	5e                   	pop    %esi
  100989:	5d                   	pop    %ebp
  10098a:	c3                   	ret    

0010098b <device_get_binding>:
 * @param name device name to search for.
 *
 * @return pointer to device structure, or NULL if not found.
 */
struct device *device_get_binding(char *name)
{
  10098b:	55                   	push   %ebp
  10098c:	89 e5                	mov    %esp,%ebp
  10098e:	53                   	push   %ebx
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  10098f:	bb 44 1e 10 00       	mov    $0x101e44,%ebx
  100994:	81 fb b0 1e 10 00    	cmp    $0x101eb0,%ebx
  10099a:	74 17                	je     1009b3 <device_get_binding+0x28>
		if (!strcmp(name, info->config->name)) {
  10099c:	8b 03                	mov    (%ebx),%eax
  10099e:	ff 30                	pushl  (%eax)
  1009a0:	ff 75 08             	pushl  0x8(%ebp)
  1009a3:	e8 61 fd ff ff       	call   100709 <strcmp>
  1009a8:	5a                   	pop    %edx
  1009a9:	85 c0                	test   %eax,%eax
  1009ab:	59                   	pop    %ecx
  1009ac:	74 09                	je     1009b7 <device_get_binding+0x2c>
 */
struct device *device_get_binding(char *name)
{
	struct device *info;

	for (info = __device_init_start; info != __device_init_end; info++) {
  1009ae:	83 c3 0c             	add    $0xc,%ebx
  1009b1:	eb e1                	jmp    100994 <device_get_binding+0x9>
		if (!strcmp(name, info->config->name)) {
			return info;
		}
	}

	return NULL;
  1009b3:	31 c0                	xor    %eax,%eax
  1009b5:	eb 02                	jmp    1009b9 <device_get_binding+0x2e>
  1009b7:	89 d8                	mov    %ebx,%eax
}
  1009b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1009bc:	c9                   	leave  
  1009bd:	c3                   	ret    

001009be <nano_fiber_timer_test>:
	irq_unlock(key);
	return user_data;
}

void *nano_fiber_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  1009be:	55                   	push   %ebp
  1009bf:	89 e5                	mov    %esp,%ebp
  1009c1:	53                   	push   %ebx
  1009c2:	8b 5d 08             	mov    0x8(%ebp),%ebx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1009c5:	9c                   	pushf  
  1009c6:	fa                   	cli    
  1009c7:	5a                   	pop    %edx
				    void **user_data_ptr)
{
	struct _nano_timeout *t = &timer->timeout_data;

	/* check if the timer has expired */
	if (t->delta_ticks_from_prev == -1) {
  1009c8:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  1009cc:	74 22                	je     1009f0 <nano_fiber_timer_test+0x32>
		*user_data_ptr = timer->user_data;
		timer->user_data = NULL;
	/* if the thread should not wait, return immediately */
	} else if (timeout_in_ticks == TICKS_NONE) {
		*user_data_ptr = NULL;
  1009ce:	31 c0                	xor    %eax,%eax
	/* check if the timer has expired */
	if (t->delta_ticks_from_prev == -1) {
		*user_data_ptr = timer->user_data;
		timer->user_data = NULL;
	/* if the thread should not wait, return immediately */
	} else if (timeout_in_ticks == TICKS_NONE) {
  1009d0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  1009d4:	75 08                	jne    1009de <nano_fiber_timer_test+0x20>
  1009d6:	80 e6 02             	and    $0x2,%dh
  1009d9:	74 21                	je     1009fc <nano_fiber_timer_test+0x3e>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  1009db:	fb                   	sti    
		key = irq_lock();
		user_data = timer->user_data;
		timer->user_data = NULL;
	}
	irq_unlock(key);
	return user_data;
  1009dc:	eb 1e                	jmp    1009fc <nano_fiber_timer_test+0x3e>
	int key = irq_lock();
	struct _nano_timeout *t = &timer->timeout_data;
	void *user_data;

	if (_nano_timer_expire_wait(timer, timeout_in_ticks, &user_data)) {
		t->tcs = _nanokernel.current;
  1009de:	a1 e8 1e 10 00       	mov    0x101ee8,%eax
  1009e3:	89 43 08             	mov    %eax,0x8(%ebx)
		_Swap(key);
  1009e6:	52                   	push   %edx
  1009e7:	e8 7b 04 00 00       	call   100e67 <_Swap>
  1009ec:	58                   	pop    %eax

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  1009ed:	9c                   	pushf  
  1009ee:	fa                   	cli    
  1009ef:	5a                   	pop    %edx
		key = irq_lock();
		user_data = timer->user_data;
  1009f0:	8b 43 14             	mov    0x14(%ebx),%eax
		timer->user_data = NULL;
  1009f3:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
  1009fa:	eb da                	jmp    1009d6 <nano_fiber_timer_test+0x18>
	}
	irq_unlock(key);
	return user_data;
}
  1009fc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  1009ff:	c9                   	leave  
  100a00:	c3                   	ret    

00100a01 <nano_isr_timer_test>:
	}
	return 0;
}

void *nano_isr_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  100a01:	55                   	push   %ebp
  100a02:	89 e5                	mov    %esp,%ebp
  100a04:	8b 55 08             	mov    0x8(%ebp),%edx
  100a07:	9c                   	pushf  
  100a08:	fa                   	cli    
  100a09:	59                   	pop    %ecx
  100a0a:	31 c0                	xor    %eax,%eax
				    void **user_data_ptr)
{
	struct _nano_timeout *t = &timer->timeout_data;

	/* check if the timer has expired */
	if (t->delta_ticks_from_prev == -1) {
  100a0c:	83 7a 10 ff          	cmpl   $0xffffffff,0x10(%edx)
  100a10:	75 0a                	jne    100a1c <nano_isr_timer_test+0x1b>
		*user_data_ptr = timer->user_data;
  100a12:	8b 42 14             	mov    0x14(%edx),%eax
		timer->user_data = NULL;
  100a15:	c7 42 14 00 00 00 00 	movl   $0x0,0x14(%edx)
  100a1c:	80 e5 02             	and    $0x2,%ch
  100a1f:	74 01                	je     100a22 <nano_isr_timer_test+0x21>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100a21:	fb                   	sti    
		/* since ISR can not wait, return NULL */
		user_data = NULL;
	}
	irq_unlock(key);
	return user_data;
}
  100a22:	5d                   	pop    %ebp
  100a23:	c3                   	ret    

00100a24 <nano_timer_init>:
#include <nano_private.h>
#include <misc/debug/object_tracing_common.h>
#include <wait_q.h>

void nano_timer_init(struct nano_timer *timer, void *data)
{
  100a24:	55                   	push   %ebp
  100a25:	89 e5                	mov    %esp,%ebp
  100a27:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->timeout_data.tcs = NULL;

	/* nano_timer_test() returns NULL on timer that was not started */
	timer->user_data = NULL;

	timer->user_data_backup = data;
  100a2a:	8b 55 0c             	mov    0xc(%ebp),%edx
#include <wait_q.h>

void nano_timer_init(struct nano_timer *timer, void *data)
{
	/* initialize timer in expired state */
	timer->timeout_data.delta_ticks_from_prev = -1;
  100a2d:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%eax)

	/* initialize to no object to wait on */
	timer->timeout_data.wait_q = NULL;
  100a34:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

	/* initialize to no fiber waiting for the timer expire */
	timer->timeout_data.tcs = NULL;
  100a3b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	/* nano_timer_test() returns NULL on timer that was not started */
	timer->user_data = NULL;
  100a42:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	timer->user_data_backup = data;
  100a49:	89 50 18             	mov    %edx,0x18(%eax)

	SYS_TRACING_OBJ_INIT(nano_timer, timer);
}
  100a4c:	5d                   	pop    %ebp
  100a4d:	c3                   	ret    

00100a4e <_timer_start>:
 * @param ticks The number of system ticks before expiration
 *
 * @return N/A
 */
void _timer_start(struct nano_timer *timer, int ticks)
{
  100a4e:	55                   	push   %ebp
  100a4f:	89 e5                	mov    %esp,%ebp
  100a51:	57                   	push   %edi
  100a52:	56                   	push   %esi
  100a53:	53                   	push   %ebx
  100a54:	8b 45 08             	mov    0x8(%ebp),%eax

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100a57:	9c                   	pushf  
  100a58:	fa                   	cli    
  100a59:	5e                   	pop    %esi

	/*
	 * Once timer is started nano_timer_test() returns
	 * the pointer to user data
	 */
	timer->user_data = timer->user_data_backup;
  100a5a:	8b 50 18             	mov    0x18(%eax),%edx
				     struct _nano_queue *wait_q,
				     int32_t timeout)
{
	sys_dlist_t *timeout_q = &_nanokernel.timeout_q;

	t->tcs = tcs;
  100a5d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  100a64:	89 50 14             	mov    %edx,0x14(%eax)
	t->delta_ticks_from_prev = timeout;
  100a67:	8b 55 0c             	mov    0xc(%ebp),%edx
	t->wait_q = wait_q;
  100a6a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
				     int32_t timeout)
{
	sys_dlist_t *timeout_q = &_nanokernel.timeout_q;

	t->tcs = tcs;
	t->delta_ticks_from_prev = timeout;
  100a71:	89 50 10             	mov    %edx,0x10(%eax)
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  100a74:	8b 15 f4 1e 10 00    	mov    0x101ef4,%edx
  100a7a:	8b 3d f8 1e 10 00    	mov    0x101ef8,%edi
 */

static inline void sys_dlist_insert_at(sys_dlist_t *list, sys_dnode_t *node,
	int (*cond)(sys_dnode_t *, void *), void *data)
{
	if (sys_dlist_is_empty(list)) {
  100a80:	81 fa f4 1e 10 00    	cmp    $0x101ef4,%edx
  100a86:	74 32                	je     100aba <_timer_start+0x6c>
		sys_dlist_append(list, node);
	} else {
		sys_dnode_t *pos = sys_dlist_peek_head(list);

		while (pos && !cond(pos, data)) {
  100a88:	85 d2                	test   %edx,%edx
  100a8a:	74 2e                	je     100aba <_timer_start+0x6c>
static int _nano_timeout_insert_point_test(sys_dnode_t *test, void *timeout)
{
	struct _nano_timeout *t = (void *)test;
	int32_t *timeout_to_insert = timeout;

	if (*timeout_to_insert > t->delta_ticks_from_prev) {
  100a8c:	8b 58 10             	mov    0x10(%eax),%ebx
  100a8f:	8b 4a 10             	mov    0x10(%edx),%ecx
  100a92:	39 cb                	cmp    %ecx,%ebx
  100a94:	7e 0d                	jle    100aa3 <_timer_start+0x55>
		*timeout_to_insert -= t->delta_ticks_from_prev;
  100a96:	29 cb                	sub    %ecx,%ebx
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node == list->tail ? NULL : node->next;
  100a98:	39 d7                	cmp    %edx,%edi
  100a9a:	89 58 10             	mov    %ebx,0x10(%eax)
  100a9d:	74 1b                	je     100aba <_timer_start+0x6c>
  100a9f:	8b 12                	mov    (%edx),%edx
  100aa1:	eb e5                	jmp    100a88 <_timer_start+0x3a>
		return 0;
	}

	t->delta_ticks_from_prev -= *timeout_to_insert;
  100aa3:	29 d9                	sub    %ebx,%ecx
  100aa5:	89 4a 10             	mov    %ecx,0x10(%edx)
	sys_dnode_t *insert_point, sys_dnode_t *node)
{
	if (!insert_point) {
		sys_dlist_append(list, node);
	} else {
		node->prev = insert_point->prev;
  100aa8:	8b 4a 04             	mov    0x4(%edx),%ecx
  100aab:	89 48 04             	mov    %ecx,0x4(%eax)
		node->next = insert_point;
  100aae:	89 10                	mov    %edx,(%eax)
		insert_point->prev->next = node;
  100ab0:	8b 4a 04             	mov    0x4(%edx),%ecx
  100ab3:	89 01                	mov    %eax,(%ecx)
		insert_point->prev = node;
  100ab5:	89 42 04             	mov    %eax,0x4(%edx)
  100ab8:	eb 1c                	jmp    100ad6 <_timer_start+0x88>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	node->next = list;
  100aba:	c7 00 f4 1e 10 00    	movl   $0x101ef4,(%eax)
	node->prev = list->tail;
  100ac0:	8b 15 f8 1e 10 00    	mov    0x101ef8,%edx
  100ac6:	89 50 04             	mov    %edx,0x4(%eax)

	list->tail->next = node;
  100ac9:	8b 15 f8 1e 10 00    	mov    0x101ef8,%edx
  100acf:	89 02                	mov    %eax,(%edx)
	list->tail = node;
  100ad1:	a3 f8 1e 10 00       	mov    %eax,0x101ef8
  100ad6:	81 e6 00 02 00 00    	and    $0x200,%esi
  100adc:	74 01                	je     100adf <_timer_start+0x91>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100ade:	fb                   	sti    
	_nano_timer_timeout_add(&timer->timeout_data,
				NULL, ticks);
	irq_unlock(key);
}
  100adf:	5b                   	pop    %ebx
  100ae0:	5e                   	pop    %esi
  100ae1:	5f                   	pop    %edi
  100ae2:	5d                   	pop    %ebp
  100ae3:	c3                   	ret    

00100ae4 <nano_timer_test>:
	irq_unlock(key);
	return user_data;
}

void *nano_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  100ae4:	55                   	push   %ebp
  100ae5:	89 e5                	mov    %esp,%ebp
  100ae7:	56                   	push   %esi
  100ae8:	53                   	push   %ebx
  100ae9:	8b 75 0c             	mov    0xc(%ebp),%esi
  100aec:	8b 5d 08             	mov    0x8(%ebp),%ebx
		nano_isr_timer_test,
		nano_fiber_timer_test,
		nano_task_timer_test,
	};

	return func[sys_execution_context_type_get()](timer, timeout_in_ticks);
  100aef:	e8 17 fd ff ff       	call   10080b <sys_execution_context_type_get>
  100af4:	89 75 0c             	mov    %esi,0xc(%ebp)
  100af7:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
  100afa:	5b                   	pop    %ebx
		nano_isr_timer_test,
		nano_fiber_timer_test,
		nano_task_timer_test,
	};

	return func[sys_execution_context_type_get()](timer, timeout_in_ticks);
  100afb:	8b 04 85 40 13 10 00 	mov    0x101340(,%eax,4),%eax
}
  100b02:	5e                   	pop    %esi
  100b03:	5d                   	pop    %ebp
		nano_isr_timer_test,
		nano_fiber_timer_test,
		nano_task_timer_test,
	};

	return func[sys_execution_context_type_get()](timer, timeout_in_ticks);
  100b04:	ff e0                	jmp    *%eax

00100b06 <nano_timer_ticks_remain>:
}

int32_t nano_timer_ticks_remain(struct nano_timer *timer)
{
  100b06:	55                   	push   %ebp
  100b07:	89 e5                	mov    %esp,%ebp
  100b09:	56                   	push   %esi
  100b0a:	53                   	push   %ebx
  100b0b:	8b 4d 08             	mov    0x8(%ebp),%ecx

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100b0e:	9c                   	pushf  
  100b0f:	fa                   	cli    
  100b10:	5b                   	pop    %ebx
	int32_t remaining_ticks;
	struct _nano_timeout *t = &timer->timeout_data;
	sys_dlist_t *timeout_q = &_nanokernel.timeout_q;
	struct _nano_timeout *iterator;

	if (t->delta_ticks_from_prev == -1) {
  100b11:	83 79 10 ff          	cmpl   $0xffffffff,0x10(%ecx)
  100b15:	74 26                	je     100b3d <nano_timer_ticks_remain+0x37>
 * @return 1 if empty, 0 otherwise
 */

static inline int sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
  100b17:	8b 15 f4 1e 10 00    	mov    0x101ef4,%edx
 * @return a pointer to the head element from a node, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
  100b1d:	81 fa f4 1e 10 00    	cmp    $0x101ef4,%edx
  100b23:	74 22                	je     100b47 <nano_timer_ticks_remain+0x41>
		 * and accumulate all the delta_ticks_from_prev values up to
		 * the timer.
		 */
		iterator =
			(struct _nano_timeout *)sys_dlist_peek_head(timeout_q);
		remaining_ticks = iterator->delta_ticks_from_prev;
  100b25:	8b 42 10             	mov    0x10(%edx),%eax
  100b28:	8b 35 f8 1e 10 00    	mov    0x101ef8,%esi
		while (iterator != t) {
  100b2e:	39 ca                	cmp    %ecx,%edx
  100b30:	74 0d                	je     100b3f <nano_timer_ticks_remain+0x39>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return node == list->tail ? NULL : node->next;
  100b32:	39 f2                	cmp    %esi,%edx
  100b34:	74 11                	je     100b47 <nano_timer_ticks_remain+0x41>
  100b36:	8b 12                	mov    (%edx),%edx
			iterator = (struct _nano_timeout *)sys_dlist_peek_next(
				timeout_q, &iterator->node);
			remaining_ticks += iterator->delta_ticks_from_prev;
  100b38:	03 42 10             	add    0x10(%edx),%eax
  100b3b:	eb f1                	jmp    100b2e <nano_timer_ticks_remain+0x28>
	struct _nano_timeout *t = &timer->timeout_data;
	sys_dlist_t *timeout_q = &_nanokernel.timeout_q;
	struct _nano_timeout *iterator;

	if (t->delta_ticks_from_prev == -1) {
		remaining_ticks = 0;
  100b3d:	31 c0                	xor    %eax,%eax
  100b3f:	80 e7 02             	and    $0x2,%bh
  100b42:	74 0a                	je     100b4e <nano_timer_ticks_remain+0x48>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100b44:	fb                   	sti    
			remaining_ticks += iterator->delta_ticks_from_prev;
		}
	}

	irq_unlock(key);
	return remaining_ticks;
  100b45:	eb 07                	jmp    100b4e <nano_timer_ticks_remain+0x48>
			(struct _nano_timeout *)sys_dlist_peek_head(timeout_q);
		remaining_ticks = iterator->delta_ticks_from_prev;
		while (iterator != t) {
			iterator = (struct _nano_timeout *)sys_dlist_peek_next(
				timeout_q, &iterator->node);
			remaining_ticks += iterator->delta_ticks_from_prev;
  100b47:	a1 10 00 00 00       	mov    0x10,%eax
  100b4c:	0f 0b                	ud2    
		}
	}

	irq_unlock(key);
	return remaining_ticks;
}
  100b4e:	5b                   	pop    %ebx
  100b4f:	5e                   	pop    %esi
  100b50:	5d                   	pop    %ebp
  100b51:	c3                   	ret    

00100b52 <nano_task_timer_test>:
	irq_unlock(key);
	return user_data;
}

void *nano_task_timer_test(struct nano_timer *timer, int32_t timeout_in_ticks)
{
  100b52:	55                   	push   %ebp
  100b53:	89 e5                	mov    %esp,%ebp
  100b55:	56                   	push   %esi
  100b56:	53                   	push   %ebx
  100b57:	8b 75 08             	mov    0x8(%ebp),%esi

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100b5a:	9c                   	pushf  
  100b5b:	fa                   	cli    
  100b5c:	5b                   	pop    %ebx
				    void **user_data_ptr)
{
	struct _nano_timeout *t = &timer->timeout_data;

	/* check if the timer has expired */
	if (t->delta_ticks_from_prev == -1) {
  100b5d:	83 7e 10 ff          	cmpl   $0xffffffff,0x10(%esi)
  100b61:	74 27                	je     100b8a <nano_task_timer_test+0x38>
		*user_data_ptr = timer->user_data;
		timer->user_data = NULL;
	/* if the thread should not wait, return immediately */
	} else if (timeout_in_ticks == TICKS_NONE) {
		*user_data_ptr = NULL;
  100b63:	31 c0                	xor    %eax,%eax
	/* check if the timer has expired */
	if (t->delta_ticks_from_prev == -1) {
		*user_data_ptr = timer->user_data;
		timer->user_data = NULL;
	/* if the thread should not wait, return immediately */
	} else if (timeout_in_ticks == TICKS_NONE) {
  100b65:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  100b69:	74 29                	je     100b94 <nano_task_timer_test+0x42>
	struct _nano_timeout *t = &timer->timeout_data;
	void *user_data;

	if (_nano_timer_expire_wait(timer, timeout_in_ticks, &user_data)) {
		/* task goes to busy waiting loop */
		while (t->delta_ticks_from_prev != -1) {
  100b6b:	83 7e 10 ff          	cmpl   $0xffffffff,0x10(%esi)
  100b6f:	74 19                	je     100b8a <nano_task_timer_test+0x38>
			_nanokernel.task_timeout =
				nano_timer_ticks_remain(timer);
  100b71:	56                   	push   %esi
  100b72:	e8 8f ff ff ff       	call   100b06 <nano_timer_ticks_remain>
			nano_cpu_atomic_idle(key);
  100b77:	89 1c 24             	mov    %ebx,(%esp)
	void *user_data;

	if (_nano_timer_expire_wait(timer, timeout_in_ticks, &user_data)) {
		/* task goes to busy waiting loop */
		while (t->delta_ticks_from_prev != -1) {
			_nanokernel.task_timeout =
  100b7a:	a3 fc 1e 10 00       	mov    %eax,0x101efc
				nano_timer_ticks_remain(timer);
			nano_cpu_atomic_idle(key);
  100b7f:	e8 6a 05 00 00       	call   1010ee <nano_cpu_atomic_idle>
  100b84:	58                   	pop    %eax
  100b85:	9c                   	pushf  
  100b86:	fa                   	cli    
  100b87:	5b                   	pop    %ebx
  100b88:	eb e1                	jmp    100b6b <nano_task_timer_test+0x19>
			key = irq_lock();
		}
		user_data = timer->user_data;
  100b8a:	8b 46 14             	mov    0x14(%esi),%eax
		timer->user_data = NULL;
  100b8d:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  100b94:	80 e7 02             	and    $0x2,%bh
  100b97:	74 01                	je     100b9a <nano_task_timer_test+0x48>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100b99:	fb                   	sti    
	}
	irq_unlock(key);
	return user_data;
}
  100b9a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  100b9d:	5b                   	pop    %ebx
  100b9e:	5e                   	pop    %esi
  100b9f:	5d                   	pop    %ebp
  100ba0:	c3                   	ret    

00100ba1 <_nop_char_out>:
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  100ba1:	55                   	push   %ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  100ba2:	31 c0                	xor    %eax,%eax
 * @param c Character to swallow
 *
 * @return 0
 */
static int _nop_char_out(int c)
{
  100ba4:	89 e5                	mov    %esp,%ebp
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
  100ba6:	5d                   	pop    %ebp
  100ba7:	c3                   	ret    

00100ba8 <_printk_dec_ulong>:
 * @param num Number to output
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num)
{
  100ba8:	55                   	push   %ebp
  100ba9:	89 e5                	mov    %esp,%ebp
  100bab:	57                   	push   %edi
	unsigned long pos = 999999999;
	unsigned long remainder = num;
  100bac:	bf 09 00 00 00       	mov    $0x9,%edi
 * @param num Number to output
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num)
{
  100bb1:	56                   	push   %esi
  100bb2:	53                   	push   %ebx
	unsigned long pos = 999999999;
  100bb3:	bb ff c9 9a 3b       	mov    $0x3b9ac9ff,%ebx
 * @param num Number to output
 *
 * @return N/A
 */
static void _printk_dec_ulong(const unsigned long num)
{
  100bb8:	51                   	push   %ecx
  100bb9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned long pos = 999999999;
	unsigned long remainder = num;
	int found_largest_digit = 0;
  100bbc:	31 c9                	xor    %ecx,%ecx

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
  100bbe:	3b 5d f0             	cmp    -0x10(%ebp),%ebx
  100bc1:	8d 73 01             	lea    0x1(%ebx),%esi
  100bc4:	72 0b                	jb     100bd1 <_printk_dec_ulong+0x29>
  100bc6:	88 c8                	mov    %cl,%al
  100bc8:	31 c9                	xor    %ecx,%ecx
  100bca:	83 e0 01             	and    $0x1,%eax
  100bcd:	84 c0                	test   %al,%al
  100bcf:	74 17                	je     100be8 <_printk_dec_ulong+0x40>
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
  100bd1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100bd4:	31 d2                	xor    %edx,%edx
  100bd6:	f7 f6                	div    %esi
  100bd8:	83 c0 30             	add    $0x30,%eax
  100bdb:	50                   	push   %eax
  100bdc:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100be2:	5a                   	pop    %edx
	unsigned long remainder = num;
	int found_largest_digit = 0;

	while (pos >= 9) {
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
  100be3:	b9 01 00 00 00       	mov    $0x1,%ecx
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
  100be8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100beb:	31 d2                	xor    %edx,%edx
  100bed:	f7 f6                	div    %esi
  100bef:	89 55 f0             	mov    %edx,-0x10(%ebp)
		pos /= 10;
  100bf2:	89 d8                	mov    %ebx,%eax
  100bf4:	31 d2                	xor    %edx,%edx
  100bf6:	be 0a 00 00 00       	mov    $0xa,%esi
  100bfb:	f7 f6                	div    %esi
{
	unsigned long pos = 999999999;
	unsigned long remainder = num;
	int found_largest_digit = 0;

	while (pos >= 9) {
  100bfd:	4f                   	dec    %edi
		if (found_largest_digit || remainder > pos) {
			found_largest_digit = 1;
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
		pos /= 10;
  100bfe:	89 c3                	mov    %eax,%ebx
{
	unsigned long pos = 999999999;
	unsigned long remainder = num;
	int found_largest_digit = 0;

	while (pos >= 9) {
  100c00:	75 bc                	jne    100bbe <_printk_dec_ulong+0x16>
			_char_out((int)((remainder / (pos + 1)) + 48));
		}
		remainder %= (pos + 1);
		pos /= 10;
	}
	_char_out((int)(remainder + 48));
  100c02:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100c05:	83 c0 30             	add    $0x30,%eax
  100c08:	50                   	push   %eax
  100c09:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100c0f:	58                   	pop    %eax
}
  100c10:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100c13:	5b                   	pop    %ebx
  100c14:	5e                   	pop    %esi
  100c15:	5f                   	pop    %edi
  100c16:	5d                   	pop    %ebp
  100c17:	c3                   	ret    

00100c18 <__printk_hook_install>:
 * @param fn putc routine to install
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
  100c18:	55                   	push   %ebp
  100c19:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
  100c1b:	8b 45 08             	mov    0x8(%ebp),%eax
}
  100c1e:	5d                   	pop    %ebp
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
  100c1f:	a3 3c 1e 10 00       	mov    %eax,0x101e3c
}
  100c24:	c3                   	ret    

00100c25 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
  100c25:	55                   	push   %ebp
  100c26:	89 e5                	mov    %esp,%ebp
  100c28:	57                   	push   %edi
  100c29:	56                   	push   %esi
  100c2a:	53                   	push   %ebx
  100c2b:	50                   	push   %eax
	va_list ap;

	va_start(ap, fmt);
  100c2c:	8d 5d 0c             	lea    0xc(%ebp),%ebx
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
  100c2f:	8b 75 08             	mov    0x8(%ebp),%esi
 *
 * @return N/A
 */
static inline void _vprintk(const char *fmt, va_list ap)
{
	int might_format = 0; /* 1 if encountered a '%' */
  100c32:	31 ff                	xor    %edi,%edi

	/* fmt has already been adjusted if needed */

	while (*fmt) {
  100c34:	0f be 06             	movsbl (%esi),%eax
  100c37:	84 c0                	test   %al,%al
  100c39:	0f 84 06 01 00 00    	je     100d45 <printk+0x120>
		if (!might_format) {
  100c3f:	85 ff                	test   %edi,%edi
  100c41:	75 15                	jne    100c58 <printk+0x33>
			if (*fmt != '%') {
  100c43:	3c 25                	cmp    $0x25,%al
  100c45:	0f 84 ef 00 00 00    	je     100d3a <printk+0x115>
				_char_out((int)*fmt);
  100c4b:	50                   	push   %eax
  100c4c:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100c52:	58                   	pop    %eax
  100c53:	e9 e7 00 00 00       	jmp    100d3f <printk+0x11a>
			} else {
				might_format = 1;
			}
		} else {
			switch (*fmt) {
  100c58:	3c 69                	cmp    $0x69,%al
  100c5a:	74 3f                	je     100c9b <printk+0x76>
  100c5c:	7f 26                	jg     100c84 <printk+0x5f>
  100c5e:	3c 58                	cmp    $0x58,%al
  100c60:	74 5d                	je     100cbf <printk+0x9a>
  100c62:	7f 0f                	jg     100c73 <printk+0x4e>
  100c64:	3c 25                	cmp    $0x25,%al
  100c66:	0f 85 b5 00 00 00    	jne    100d21 <printk+0xfc>

				_char_out(c);
				break;
			}
			case '%': {
				_char_out((int)'%');
  100c6c:	6a 25                	push   $0x25
  100c6e:	e9 bc 00 00 00       	jmp    100d2f <printk+0x10a>
				_char_out((int)*fmt);
			} else {
				might_format = 1;
			}
		} else {
			switch (*fmt) {
  100c73:	3c 63                	cmp    $0x63,%al
  100c75:	0f 84 96 00 00 00    	je     100d11 <printk+0xec>
  100c7b:	3c 64                	cmp    $0x64,%al
  100c7d:	74 1c                	je     100c9b <printk+0x76>
  100c7f:	e9 9d 00 00 00       	jmp    100d21 <printk+0xfc>
  100c84:	3c 73                	cmp    $0x73,%al
  100c86:	74 72                	je     100cfa <printk+0xd5>
  100c88:	7f 04                	jg     100c8e <printk+0x69>
  100c8a:	3c 70                	cmp    $0x70,%al
  100c8c:	eb 06                	jmp    100c94 <printk+0x6f>
  100c8e:	3c 75                	cmp    $0x75,%al
  100c90:	74 21                	je     100cb3 <printk+0x8e>
  100c92:	3c 78                	cmp    $0x78,%al
  100c94:	74 29                	je     100cbf <printk+0x9a>
  100c96:	e9 86 00 00 00       	jmp    100d21 <printk+0xfc>
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);
  100c9b:	8d 7b 04             	lea    0x4(%ebx),%edi
  100c9e:	8b 1b                	mov    (%ebx),%ebx

				if (d < 0) {
  100ca0:	85 db                	test   %ebx,%ebx
  100ca2:	79 0b                	jns    100caf <printk+0x8a>
					_char_out((int)'-');
  100ca4:	6a 2d                	push   $0x2d
  100ca6:	ff 15 3c 1e 10 00    	call   *0x101e3c
					d = -d;
  100cac:	f7 db                	neg    %ebx
			case 'd':
			case 'i': {
				long d = va_arg(ap, long);

				if (d < 0) {
					_char_out((int)'-');
  100cae:	58                   	pop    %eax
					d = -d;
				}
				_printk_dec_ulong(d);
  100caf:	89 d8                	mov    %ebx,%eax
  100cb1:	eb 05                	jmp    100cb8 <printk+0x93>
				break;
			}
			case 'u': {
				unsigned long u = va_arg(
  100cb3:	8d 7b 04             	lea    0x4(%ebx),%edi
					ap, unsigned long);
				_printk_dec_ulong(u);
  100cb6:	8b 03                	mov    (%ebx),%eax
  100cb8:	e8 eb fe ff ff       	call   100ba8 <_printk_dec_ulong>
  100cbd:	eb 5e                	jmp    100d1d <printk+0xf8>
				break;
			}
			case 'x':
			case 'X':
			case 'p': {
				unsigned long x = va_arg(
  100cbf:	8b 03                	mov    (%ebx),%eax
  100cc1:	8d 7b 04             	lea    0x4(%ebx),%edi
  100cc4:	89 45 f0             	mov    %eax,-0x10(%ebp)
 *
 * @return N/A
 */
static void _printk_hex_ulong(const unsigned long num)
{
	int size = sizeof(num) * 2;
  100cc7:	bb 08 00 00 00       	mov    $0x8,%ebx

	for (; size; size--) {
		char nibble = (num >> ((size - 1) << 2) & 0xf);
  100ccc:	4b                   	dec    %ebx
  100ccd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100cd0:	8d 0c 9d 00 00 00 00 	lea    0x0(,%ebx,4),%ecx
  100cd7:	d3 e8                	shr    %cl,%eax
  100cd9:	83 e0 0f             	and    $0xf,%eax
		nibble += nibble > 9 ? 87 : 48;
  100cdc:	3c 09                	cmp    $0x9,%al
  100cde:	0f 9f c1             	setg   %cl
  100ce1:	49                   	dec    %ecx
  100ce2:	83 e1 d9             	and    $0xffffffd9,%ecx
		_char_out((int)nibble);
  100ce5:	8d 44 08 57          	lea    0x57(%eax,%ecx,1),%eax
  100ce9:	0f b6 c0             	movzbl %al,%eax
  100cec:	50                   	push   %eax
  100ced:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100cf3:	58                   	pop    %eax
 */
static void _printk_hex_ulong(const unsigned long num)
{
	int size = sizeof(num) * 2;

	for (; size; size--) {
  100cf4:	85 db                	test   %ebx,%ebx
  100cf6:	75 d4                	jne    100ccc <printk+0xa7>
  100cf8:	eb 23                	jmp    100d1d <printk+0xf8>
					ap, unsigned long);
				_printk_hex_ulong(x);
				break;
			}
			case 's': {
				char *s = va_arg(ap, char *);
  100cfa:	8d 7b 04             	lea    0x4(%ebx),%edi
  100cfd:	8b 1b                	mov    (%ebx),%ebx

				while (*s)
  100cff:	0f be 03             	movsbl (%ebx),%eax
  100d02:	84 c0                	test   %al,%al
  100d04:	74 17                	je     100d1d <printk+0xf8>
					_char_out((int)(*s++));
  100d06:	50                   	push   %eax
  100d07:	43                   	inc    %ebx
  100d08:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100d0e:	59                   	pop    %ecx
  100d0f:	eb ee                	jmp    100cff <printk+0xda>
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);

				_char_out(c);
  100d11:	ff 33                	pushl  (%ebx)
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  100d13:	8d 7b 04             	lea    0x4(%ebx),%edi

				_char_out(c);
  100d16:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100d1c:	5a                   	pop    %edx
				while (*s)
					_char_out((int)(*s++));
				break;
			}
			case 'c': {
				int c = va_arg(ap, int);
  100d1d:	89 fb                	mov    %edi,%ebx
  100d1f:	eb 15                	jmp    100d36 <printk+0x111>
			case '%': {
				_char_out((int)'%');
				break;
			}
			default:
				_char_out((int)'%');
  100d21:	6a 25                	push   $0x25
  100d23:	ff 15 3c 1e 10 00    	call   *0x101e3c
				_char_out((int)*fmt);
  100d29:	0f be 06             	movsbl (%esi),%eax
  100d2c:	89 04 24             	mov    %eax,(%esp)
  100d2f:	ff 15 3c 1e 10 00    	call   *0x101e3c
  100d35:	58                   	pop    %eax
				break;
			}
			might_format = 0;
  100d36:	31 ff                	xor    %edi,%edi
  100d38:	eb 05                	jmp    100d3f <printk+0x11a>
	while (*fmt) {
		if (!might_format) {
			if (*fmt != '%') {
				_char_out((int)*fmt);
			} else {
				might_format = 1;
  100d3a:	bf 01 00 00 00       	mov    $0x1,%edi
				break;
			}
			might_format = 0;
		}

		++fmt;
  100d3f:	46                   	inc    %esi
  100d40:	e9 ef fe ff ff       	jmp    100c34 <printk+0xf>
	va_list ap;

	va_start(ap, fmt);
	_vprintk(fmt, ap);
	va_end(ap);
}
  100d45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  100d48:	5b                   	pop    %ebx
  100d49:	5e                   	pop    %esi
  100d4a:	5f                   	pop    %edi
  100d4b:	5d                   	pop    %ebp
  100d4c:	c3                   	ret    

00100d4d <_ConfigAbsSyms>:
/* file is auto-generated, do not modify ! */

#include <toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
  100d4d:	55                   	push   %ebp
  100d4e:	89 e5                	mov    %esp,%ebp
GEN_ABSOLUTE_SYM(CONFIG_UART_CONSOLE, 1);
GEN_ABSOLUTE_SYM(CONFIG_HPET_TIMER_RISING_EDGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_HPET_TIMER_LEGACY_EMULATION, 1);
GEN_ABSOLUTE_SYM(CONFIG_ISA_IA32, 1);

GEN_ABS_SYM_END
  100d50:	5d                   	pop    %ebp
  100d51:	c3                   	ret    

00100d52 <_mem_safe_region_add>:
	return 0;
}
#endif /* CONFIG_XIP */

int _mem_safe_region_add(void *addr, size_t num_bytes, int perm)
{
  100d52:	55                   	push   %ebp
  100d53:	89 e5                	mov    %esp,%ebp
  100d55:	56                   	push   %esi
  100d56:	53                   	push   %ebx
	if (unlikely(!is_perm_valid(perm))) {
  100d57:	8b 45 10             	mov    0x10(%ebp),%eax
	return 0;
}
#endif /* CONFIG_XIP */

int _mem_safe_region_add(void *addr, size_t num_bytes, int perm)
{
  100d5a:	8b 75 08             	mov    0x8(%ebp),%esi
	if (unlikely(!is_perm_valid(perm))) {
  100d5d:	83 e0 fe             	and    $0xfffffffe,%eax
  100d60:	75 53                	jne    100db5 <_mem_safe_region_add+0x63>

static inline __attribute__((always_inline)) unsigned int _do_irq_lock(void)
{
	unsigned int key;

	__asm__ volatile (
  100d62:	9c                   	pushf  
  100d63:	fa                   	cli    
  100d64:	5b                   	pop    %ebx
	}

	int slot;
	int key = irq_lock();

	if (unlikely(ro_end > rw_end)) {
  100d65:	8b 15 c4 1e 10 00    	mov    0x101ec4,%edx
  100d6b:	8b 0d 40 1e 10 00    	mov    0x101e40,%ecx
  100d71:	39 ca                	cmp    %ecx,%edx
  100d73:	7e 07                	jle    100d7c <_mem_safe_region_add+0x2a>
		irq_unlock(key);
		return -ENOMEM;
  100d75:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  100d7a:	eb 31                	jmp    100dad <_mem_safe_region_add+0x5b>
	}

	if (perm == SYS_MEM_SAFE_WRITE) {
  100d7c:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  100d80:	75 0d                	jne    100d8f <_mem_safe_region_add+0x3d>
		slot = rw_end;
		--rw_end;
  100d82:	8d 51 ff             	lea    -0x1(%ecx),%edx
  100d85:	89 15 40 1e 10 00    	mov    %edx,0x101e40
  100d8b:	89 ca                	mov    %ecx,%edx
  100d8d:	eb 09                	jmp    100d98 <_mem_safe_region_add+0x46>
	} else {
		slot = ro_end;
		++ro_end;
  100d8f:	8d 4a 01             	lea    0x1(%edx),%ecx
  100d92:	89 0d c4 1e 10 00    	mov    %ecx,0x101ec4
	}

	mem_regions[slot].addr = (vaddr_t)addr;
	mem_regions[slot].last_byte = mem_regions[slot].addr + num_bytes - 1;
  100d98:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	} else {
		slot = ro_end;
		++ro_end;
	}

	mem_regions[slot].addr = (vaddr_t)addr;
  100d9b:	89 34 d5 08 1f 10 00 	mov    %esi,0x101f08(,%edx,8)
	mem_regions[slot].last_byte = mem_regions[slot].addr + num_bytes - 1;
  100da2:	8d 4c 0e ff          	lea    -0x1(%esi,%ecx,1),%ecx
  100da6:	89 0c d5 0c 1f 10 00 	mov    %ecx,0x101f0c(,%edx,8)
  100dad:	80 e7 02             	and    $0x2,%bh
  100db0:	74 08                	je     100dba <_mem_safe_region_add+0x68>
 * @return N/A
 */

static inline __attribute__((always_inline)) void _do_irq_unlock(void)
{
	__asm__ volatile (
  100db2:	fb                   	sti    
  100db3:	eb 05                	jmp    100dba <_mem_safe_region_add+0x68>
#endif /* CONFIG_XIP */

int _mem_safe_region_add(void *addr, size_t num_bytes, int perm)
{
	if (unlikely(!is_perm_valid(perm))) {
		return -EINVAL;
  100db5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
	mem_regions[slot].last_byte = mem_regions[slot].addr + num_bytes - 1;

	irq_unlock(key);

	return 0;
}
  100dba:	5b                   	pop    %ebx
  100dbb:	5e                   	pop    %esi
  100dbc:	5d                   	pop    %ebp
  100dbd:	c3                   	ret    

00100dbe <init>:

	ARG_UNUSED(unused);

	addr = (void *)IMAGE_ROM_START;
	num_bytes = (int)(IMAGE_ROM_END - IMAGE_ROM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_READ);
  100dbe:	b8 00 1e 10 00       	mov    $0x101e00,%eax

	return 0;
}

static int init(struct device *unused)
{
  100dc3:	55                   	push   %ebp

	ARG_UNUSED(unused);

	addr = (void *)IMAGE_ROM_START;
	num_bytes = (int)(IMAGE_ROM_END - IMAGE_ROM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_READ);
  100dc4:	2d 00 00 10 00       	sub    $0x100000,%eax

	return 0;
}

static int init(struct device *unused)
{
  100dc9:	89 e5                	mov    %esp,%ebp

	ARG_UNUSED(unused);

	addr = (void *)IMAGE_ROM_START;
	num_bytes = (int)(IMAGE_ROM_END - IMAGE_ROM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_READ);
  100dcb:	6a 00                	push   $0x0
  100dcd:	50                   	push   %eax
  100dce:	68 00 00 10 00       	push   $0x100000
  100dd3:	e8 7a ff ff ff       	call   100d52 <_mem_safe_region_add>
  100dd8:	83 c4 0c             	add    $0xc,%esp

	addr = (void *)IMAGE_RAM_START;
	num_bytes = (int)(IMAGE_RAM_END - IMAGE_RAM_START);
	(void)_mem_safe_region_add(addr, num_bytes, SYS_MEM_SAFE_WRITE);
  100ddb:	b8 40 2b 10 00       	mov    $0x102b40,%eax
  100de0:	2d 00 1e 10 00       	sub    $0x101e00,%eax
  100de5:	6a 01                	push   $0x1
  100de7:	50                   	push   %eax
  100de8:	68 00 1e 10 00       	push   $0x101e00
  100ded:	e8 60 ff ff ff       	call   100d52 <_mem_safe_region_add>
  100df2:	83 c4 0c             	add    $0xc,%esp

	return 0;
}
  100df5:	31 c0                	xor    %eax,%eax
  100df7:	c9                   	leave  
  100df8:	c3                   	ret    

00100df9 <_IntEnt>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * interrupt exits via the IRET instruction.
	 */

	cld
  100df9:	fc                   	cld    
	/*
	 * swap eax and return address on the current stack;
	 * this saves eax on the stack without losing knowledge
	 * of how to get back to the interrupt stub
	 */
	xchgl	%eax, (%esp)
  100dfa:	87 04 24             	xchg   %eax,(%esp)
	/*
	 * The remaining volatile registers are pushed onto the current
	 * stack.
	 */

	pushl	%ecx
  100dfd:	51                   	push   %ecx
	pushl	%edx
  100dfe:	52                   	push   %edx
	popl	%eax
#endif

	/* load %ecx with &_nanokernel */

	movl	$_nanokernel, %ecx
  100dff:	b9 e0 1e 10 00       	mov    $0x101ee0,%ecx

	/* switch to the interrupt stack for the non-nested case */

	incl	__tNANO_nested_OFFSET(%ecx)	/* inc interrupt nest count */
  100e04:	ff 41 0c             	incl   0xc(%ecx)
	cmpl	$1, __tNANO_nested_OFFSET(%ecx)	/* use int stack if !nested */
  100e07:	83 79 0c 01          	cmpl   $0x1,0xc(%ecx)
	jne	alreadyOnIntStack
  100e0b:	75 06                	jne    100e13 <alreadyOnIntStack>

	/* switch to base of the interrupt stack */

	movl	%esp, %edx		/* save current thread's stack pointer */
  100e0d:	89 e2                	mov    %esp,%edx
	movl	__tNANO_common_isp_OFFSET(%ecx), %esp	/* load new sp value */
  100e0f:	8b 61 10             	mov    0x10(%ecx),%esp


	/* save thread's stack pointer onto base of interrupt stack */

	pushl	%edx			/* Save stack pointer */
  100e12:	52                   	push   %edx

00100e13 <alreadyOnIntStack>:
	pushl	%eax
	call	_int_latency_stop
	popl	%eax
#endif
#ifdef CONFIG_NESTED_INTERRUPTS
	sti			/* re-enable interrupts */
  100e13:	fb                   	sti    
#endif
	jmp	*%eax		/* "return" back to stub */
  100e14:	ff e0                	jmp    *%eax

00100e16 <_IntExitWithEoi>:
 * a particular state and need to poke the interrupt controller.
 * Prior to running the logic in _IntExit, the ISR parameter is popped off
 * the stack and EOI is set to the LOAPIC.
 */
SECTION_FUNC(TEXT, _IntExitWithEoi)
	popl %eax			/* Pushed onto stack by stub */
  100e16:	58                   	pop    %eax
#if CONFIG_EOI_FORWARDING_BUG
	call	_lakemont_eoi
#endif
	xorl %eax, %eax			/* zeroes eax */
  100e17:	31 c0                	xor    %eax,%eax
	 * layer, the in-use IRQ controller code will define an ASM macro
	 * with a specific name which does the correct thing for the particular
	 * controller.
	 */
	loapic_eoi_reg = (CONFIG_LOAPIC_BASE_ADDRESS + LOAPIC_EOI)
	movl %eax, loapic_eoi_reg	/* tell LOAPIC the IRQ is handled */
  100e19:	a3 b0 00 e0 fe       	mov    %eax,0xfee000b0

00100e1e <_IntExit>:
 *
 * void _IntExit (void);
 */
BRANCH_LABEL(_IntExit)

	cli			/* disable interrupts */
  100e1e:	fa                   	cli    
	call	_int_latency_start
#endif

	/* determine whether exiting from a nested interrupt */

	movl	$_nanokernel, %ecx
  100e1f:	b9 e0 1e 10 00       	mov    $0x101ee0,%ecx
	decl	__tNANO_nested_OFFSET(%ecx)	/* dec interrupt nest count */
  100e24:	ff 49 0c             	decl   0xc(%ecx)
	jne	nestedInterrupt                 /* 'iret' if nested case */
  100e27:	75 20                	jne    100e49 <nestedInterrupt>
	 * Determine whether the execution of the ISR requires a context
	 * switch.  If the interrupted thread is PREEMPTIBLE (a task) and
	 * _nanokernel.fiber is non-NULL, a _Swap() needs to occur.
	 */

	movl	__tNANO_current_OFFSET (%ecx), %eax
  100e29:	8b 41 08             	mov    0x8(%ecx),%eax
	testl	$PREEMPTIBLE, __tTCS_flags_OFFSET(%eax)
  100e2c:	f7 40 04 00 01 00 00 	testl  $0x100,0x4(%eax)
	je	noReschedule
  100e33:	74 13                	je     100e48 <noReschedule>
	cmpl	$0, __tNANO_fiber_OFFSET (%ecx)
  100e35:	83 39 00             	cmpl   $0x0,(%ecx)
	je	noReschedule
  100e38:	74 0e                	je     100e48 <noReschedule>
	 * the existing _Swap() primitive to save the remaining
	 * thread's registers (including floating point) and perform
	 * a switch to the new thread.
	 */

	popl	%esp		/* switch back to kernel stack */
  100e3a:	5c                   	pop    %esp

	pushfl			/* push KERNEL_LOCK_KEY argument */
  100e3b:	9c                   	pushf  
	call	_Swap
  100e3c:	e8 26 00 00 00       	call   100e67 <_Swap>
	movl	_nanokernel + __tNANO_current_OFFSET, %eax
	andl	$~INT_ACTIVE, __tTCS_flags_OFFSET (%eax)
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */


	addl 	$4, %esp	/* pop KERNEL_LOCK_KEY argument */
  100e41:	83 c4 04             	add    $0x4,%esp
	/* Restore volatile registers and return to the interrupted thread */
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif

	popl	%edx
  100e44:	5a                   	pop    %edx
	popl	%ecx
  100e45:	59                   	pop    %ecx
	popl	%eax
  100e46:	58                   	pop    %eax

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  100e47:	cf                   	iret   

00100e48 <noReschedule>:
	/*
	 * A thread reschedule is not required; switch back to the
	 * interrupted thread's stack and restore volatile registers
	 */

	popl	%esp		/* pop thread stack pointer */
  100e48:	5c                   	pop    %esp

00100e49 <nestedInterrupt>:

BRANCH_LABEL(nestedInterrupt)
#ifdef CONFIG_INT_LATENCY_BENCHMARK
	call	_int_latency_stop
#endif
	popl	%edx		/* pop volatile registers in reverse order */
  100e49:	5a                   	pop    %edx
	popl	%ecx
  100e4a:	59                   	pop    %ecx
	popl	%eax
  100e4b:	58                   	pop    %eax
	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  100e4c:	cf                   	iret   

00100e4d <_SpuriousIntNoErrCodeHandler>:
 * thus _SpuriousIntNoErrCodeHandler()/_SpuriousIntHandler() shall be
 * invoked with interrupts disabled.
 */
SECTION_FUNC(TEXT, _SpuriousIntNoErrCodeHandler)

	pushl	$0			/* push dummy err code onto stk */
  100e4d:	6a 00                	push   $0x0

00100e4f <_SpuriousIntHandler>:
	/* fall through to _SpuriousIntHandler */


SECTION_FUNC(TEXT, _SpuriousIntHandler)

	cld				/* Clear direction flag */
  100e4f:	fc                   	cld    

	/* Create the ESF */

	pushl %eax
  100e50:	50                   	push   %eax
	pushl %ecx
  100e51:	51                   	push   %ecx
	pushl %edx
  100e52:	52                   	push   %edx
	pushl %edi
  100e53:	57                   	push   %edi
	pushl %esi
  100e54:	56                   	push   %esi
	pushl %ebx
  100e55:	53                   	push   %ebx
	pushl %ebp
  100e56:	55                   	push   %ebp

	leal	44(%esp), %ecx   /* Calculate ESP before exception occurred */
  100e57:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
	pushl	%ecx             /* Save calculated ESP */
  100e5b:	51                   	push   %ecx
	 * The task's regular stack is being used, but push the value of ESP
	 * anyway so that _ExcExit can "recover the stack pointer"
	 * without determining whether the exception occurred while CPL=3
	 */

	pushl	%esp			/* push cur stack pointer: pEsf arg */
  100e5c:	54                   	push   %esp

00100e5d <finishSpuriousInt>:

BRANCH_LABEL(finishSpuriousInt)

	/* re-enable interrupts */

	sti
  100e5d:	fb                   	sti    

	/* push the 'unsigned int reason' parameter */

	pushl	$_NANO_ERR_SPURIOUS_INT
  100e5e:	6a 00                	push   $0x0

00100e60 <callFatalHandler>:

BRANCH_LABEL(callFatalHandler)

	/* call the fatal error handler */

	call	_NanoFatalErrorHandler
  100e60:	e8 90 00 00 00       	call   100ef5 <_NanoFatalErrorHandler>

	/* handler shouldn't return, but call it again if it does */

	jmp	callFatalHandler
  100e65:	eb f9                	jmp    100e60 <callFatalHandler>

00100e67 <_Swap>:
 * unsigned int _Swap (unsigned int eflags);
 *
 */

SECTION_FUNC(TEXT, _Swap)
	movl	$_nanokernel, %eax
  100e67:	b8 e0 1e 10 00       	mov    $0x101ee0,%eax
	 * any of these registers into the tTCS.  Only the 'esp' register
	 * after all the pushes have been performed) will be stored in the
	 * tTCS.
	 */

	pushl	%edi
  100e6c:	57                   	push   %edi
	pushl	%esi
  100e6d:	56                   	push   %esi
	pushl	%ebx
  100e6e:	53                   	push   %ebx
	pushl	%ebp
  100e6f:	55                   	push   %ebp
	 * Leave slot for eax register when _Swap() needs to return a value;
	 * pre-populate slot with ebx's value in case _Swap() does not return
	 * a value.
	 */

	pushl	%ebx
  100e70:	53                   	push   %ebx


	/* save esp into tTCS structure */

	movl	__tNANO_current_OFFSET (%eax), %ecx
  100e71:	8b 48 08             	mov    0x8(%eax),%ecx
	movl	%esp, __tTCS_coopReg_OFFSET + __tCoopReg_esp_OFFSET (%ecx)
  100e74:	89 61 08             	mov    %esp,0x8(%ecx)
	/*
	 * Determine what thread needs to be swapped in.
	 * Note that the %eax still contains &_nanokernel.
	 */

	movl	__tNANO_fiber_OFFSET (%eax), %ecx
  100e77:	8b 08                	mov    (%eax),%ecx
	testl	%ecx, %ecx
  100e79:	85 c9                	test   %ecx,%ecx
	jz	swapTask	/* Jump if no ready fibers */
  100e7b:	74 06                	je     100e83 <swapTask>

	/* remove the head 'TCS *' from the runnable fiber list */

	movl	__tTCS_link_OFFSET (%ecx), %ebx
  100e7d:	8b 19                	mov    (%ecx),%ebx
	movl	%ebx, __tNANO_fiber_OFFSET (%eax)
  100e7f:	89 18                	mov    %ebx,(%eax)
	jmp 	restoreContext
  100e81:	eb 03                	jmp    100e86 <restoreContext>

00100e83 <swapTask>:
	 * There are no fiber in the run queue, thus swap in the task
	 * (_nanokernel.task).  The 'task' field will _never_ be NULL.
	 */

BRANCH_LABEL(swapTask)
	movl	__tNANO_task_OFFSET (%eax), %ecx
  100e83:	8b 48 04             	mov    0x4(%eax),%ecx

00100e86 <restoreContext>:



	/* update _nanokernel.current to reflect incoming thread */

	movl    %ecx, __tNANO_current_OFFSET (%eax)
  100e86:	89 48 08             	mov    %ecx,0x8(%eax)

	/* recover task/fiber stack pointer from tTCS */

	movl	__tTCS_coopReg_OFFSET + __tCoopReg_esp_OFFSET (%ecx), %esp
  100e89:	8b 61 08             	mov    0x8(%ecx),%esp


	/* load return value from a possible fiberRtnValueSet() */

	popl	%eax
  100e8c:	58                   	pop    %eax

	/* pop the non-volatile registers from the stack */

	popl	%ebp
  100e8d:	5d                   	pop    %ebp
	popl	%ebx
  100e8e:	5b                   	pop    %ebx
	popl	%esi
  100e8f:	5e                   	pop    %esi
	popl	%edi
  100e90:	5f                   	pop    %edi
	 *          (b) same value as EBX, which is non-volatile
	 */

	/* Utilize the 'eflags' parameter to _Swap() */

	pushl	4(%esp)
  100e91:	ff 74 24 04          	pushl  0x4(%esp)
	/* restore _Swap's %eax */
	popl	%eax

BRANCH_LABEL(skipIntLatencyStop)
#endif
	popfl
  100e95:	9d                   	popf   
	ret
  100e96:	c3                   	ret    

00100e97 <_new_thread>:
 * @return opaque pointer to initialized TCS structure
 */
void _new_thread(char *pStackMem, unsigned stackSize, _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  100e97:	55                   	push   %ebp
  100e98:	89 e5                	mov    %esp,%ebp
  100e9a:	53                   	push   %ebx
  100e9b:	8b 55 08             	mov    0x8(%ebp),%edx
	memset(pStackMem, 0xaa, stackSize);
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
  100e9e:	8b 45 0c             	mov    0xc(%ebp),%eax
  100ea1:	01 d0                	add    %edx,%eax
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  100ea3:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
	memset(pStackMem, 0xaa, stackSize);
#endif

	/* carve the thread entry struct from the "base" of the stack */

	pInitialThread =
  100ea6:	83 e0 fc             	and    $0xfffffffc,%eax
 * @return opaque pointer to initialized TCS structure
 */
void _new_thread(char *pStackMem, unsigned stackSize, _thread_entry_t pEntry,
		 void *parameter1, void *parameter2, void *parameter3,
		 int priority, unsigned options)
{
  100ea9:	8b 5d 20             	mov    0x20(%ebp),%ebx
	 * setup for both threads are equivalent.
	 */

	/* push arguments required by _thread_entry() */

	*--pInitialThread = (unsigned long)parameter3;
  100eac:	89 48 fc             	mov    %ecx,-0x4(%eax)
	*--pInitialThread = (unsigned long)parameter2;
  100eaf:	8b 4d 18             	mov    0x18(%ebp),%ecx
  100eb2:	89 48 f8             	mov    %ecx,-0x8(%eax)
	*--pInitialThread = (unsigned long)parameter1;
  100eb5:	8b 4d 14             	mov    0x14(%ebp),%ecx
  100eb8:	89 48 f4             	mov    %ecx,-0xc(%eax)
	*--pInitialThread = (unsigned long)pEntry;
  100ebb:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100ebe:	89 48 f0             	mov    %ecx,-0x10(%eax)
 */
static inline unsigned int EflagsGet(void)
{
	unsigned int eflags; /* EFLAGS register contents */

	__asm__ volatile(
  100ec1:	9c                   	pushf  
  100ec2:	59                   	pop    %ecx

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  100ec3:	80 e5 cd             	and    $0xcd,%ch

	*--pInitialThread = (unsigned long)_thread_entry_wrapper;

#else /* CONFIG_GDB_INFO */

	*--pInitialThread = (unsigned long)_thread_entry;
  100ec6:	c7 40 e8 47 08 10 00 	movl   $0x100847,-0x18(%eax)
	*--pInitialThread = (unsigned long)parameter1;
	*--pInitialThread = (unsigned long)pEntry;

	/* push initial EFLAGS; only modify IF and IOPL bits */

	*--pInitialThread = (EflagsGet() & ~EFLAGS_MASK) | EFLAGS_INITIAL;
  100ecd:	80 cd 02             	or     $0x2,%ch
  100ed0:	89 48 ec             	mov    %ecx,-0x14(%eax)
	tcs->excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */


	if (priority == -1)
		tcs->flags = PREEMPTIBLE | TASK;
  100ed3:	31 c9                	xor    %ecx,%ecx
#ifndef CONFIG_FP_SHARING
	ARG_UNUSED(options);
#endif /* !CONFIG_FP_SHARING */

	tcs->link = (struct tcs *)NULL; /* thread not inserted into list yet */
	tcs->prio = priority;
  100ed5:	89 5a 0c             	mov    %ebx,0xc(%edx)
	tcs->excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */


	if (priority == -1)
		tcs->flags = PREEMPTIBLE | TASK;
  100ed8:	43                   	inc    %ebx
  100ed9:	0f 95 c1             	setne  %cl
  100edc:	49                   	dec    %ecx
	 * parameters
	 * (4 of them), eflags, eip, and the edi/esi/ebx/ebp/eax registers.
	 */
	pInitialCtx -= 11;

	tcs->coopReg.esp = (unsigned long)pInitialCtx;
  100edd:	83 e8 2c             	sub    $0x2c,%eax
	tcs->excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */


	if (priority == -1)
		tcs->flags = PREEMPTIBLE | TASK;
  100ee0:	81 e1 01 01 00 00    	and    $0x101,%ecx

#ifndef CONFIG_FP_SHARING
	ARG_UNUSED(options);
#endif /* !CONFIG_FP_SHARING */

	tcs->link = (struct tcs *)NULL; /* thread not inserted into list yet */
  100ee6:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	tcs->excNestCount = 0;
#endif /* CONFIG_FP_SHARING || CONFIG_GDB_INFO */


	if (priority == -1)
		tcs->flags = PREEMPTIBLE | TASK;
  100eec:	89 4a 04             	mov    %ecx,0x4(%edx)
	 * parameters
	 * (4 of them), eflags, eip, and the edi/esi/ebx/ebp/eax registers.
	 */
	pInitialCtx -= 11;

	tcs->coopReg.esp = (unsigned long)pInitialCtx;
  100eef:	89 42 08             	mov    %eax,0x8(%edx)
	 * For kernel tasks and fibers the thread the thread control struct (TCS)
	 * is located at the "low end" of memory set aside for the thread's stack.
	 */

	_new_thread_internal(pStackMem, stackSize, priority, options);
}
  100ef2:	5b                   	pop    %ebx
  100ef3:	5d                   	pop    %ebp
  100ef4:	c3                   	ret    

00100ef5 <_NanoFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _NanoFatalErrorHandler(unsigned int reason,
					  const NANO_ESF *pEsf)
{
  100ef5:	55                   	push   %ebp
  100ef6:	89 e5                	mov    %esp,%ebp
  100ef8:	57                   	push   %edi
  100ef9:	56                   	push   %esi
  100efa:	53                   	push   %ebx
  100efb:	83 ec 28             	sub    $0x28,%esp
  100efe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  100f01:	8b 75 0c             	mov    0xc(%ebp),%esi

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  100f04:	83 fb 03             	cmp    $0x3,%ebx
  100f07:	74 1f                	je     100f28 <_NanoFatalErrorHandler+0x33>
  100f09:	77 11                	ja     100f1c <_NanoFatalErrorHandler+0x27>
  100f0b:	85 db                	test   %ebx,%ebx
  100f0d:	75 2d                	jne    100f3c <_NanoFatalErrorHandler+0x47>
	case _NANO_ERR_CPU_EXCEPTION:
		break;

	case _NANO_ERR_SPURIOUS_INT:
		printk("***** Unhandled interrupt vector %d occurred! "
  100f0f:	e8 cb f6 ff ff       	call   1005df <_loapic_isr_vector_get>
  100f14:	50                   	push   %eax
  100f15:	68 4c 13 10 00       	push   $0x10134c
  100f1a:	eb 26                	jmp    100f42 <_NanoFatalErrorHandler+0x4d>

#ifdef CONFIG_PRINTK

	/* Display diagnostic information about the error */

	switch (reason) {
  100f1c:	83 fb 05             	cmp    $0x5,%ebx
  100f1f:	74 0e                	je     100f2f <_NanoFatalErrorHandler+0x3a>
  100f21:	83 fb 06             	cmp    $0x6,%ebx
  100f24:	74 23                	je     100f49 <_NanoFatalErrorHandler+0x54>
  100f26:	eb 14                	jmp    100f3c <_NanoFatalErrorHandler+0x47>
		printk("***** Unhandled interrupt vector %d occurred! "
		       "*****\n", _loapic_isr_vector_get());
		break;

	case _NANO_ERR_INVALID_TASK_EXIT:
		printk("***** Invalid Exit Software Error! *****\n");
  100f28:	68 81 13 10 00       	push   $0x101381
  100f2d:	eb 05                	jmp    100f34 <_NanoFatalErrorHandler+0x3f>
		break;
#endif /* CONFIG_STACK_CANARIES */


	case _NANO_ERR_ALLOCATION_FAIL:
		printk("**** Kernel Allocation Failure! ****\n");
  100f2f:	68 ab 13 10 00       	push   $0x1013ab
  100f34:	e8 ec fc ff ff       	call   100c25 <printk>
  100f39:	59                   	pop    %ecx
		break;
  100f3a:	eb 0d                	jmp    100f49 <_NanoFatalErrorHandler+0x54>

	default:
		printk("**** Unknown Fatal Error %d! ****\n", reason);
  100f3c:	53                   	push   %ebx
  100f3d:	68 d1 13 10 00       	push   $0x1013d1
  100f42:	e8 de fc ff ff       	call   100c25 <printk>
  100f47:	58                   	pop    %eax
  100f48:	5a                   	pop    %edx
		break;
	}

	printk("Current thread ID = 0x%x\n"
  100f49:	8b 46 10             	mov    0x10(%esi),%eax
  100f4c:	8b 4e 2c             	mov    0x2c(%esi),%ecx
  100f4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100f52:	8b 46 0c             	mov    0xc(%esi),%eax
  100f55:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100f58:	8b 46 14             	mov    0x14(%esi),%eax
  100f5b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100f5e:	8b 46 1c             	mov    0x1c(%esi),%eax
  100f61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100f64:	8b 46 08             	mov    0x8(%esi),%eax
  100f67:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100f6a:	8b 46 18             	mov    0x18(%esi),%eax
  100f6d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  100f70:	8b 46 24             	mov    0x24(%esi),%eax
  100f73:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100f76:	8b 16                	mov    (%esi),%edx
  100f78:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  100f7c:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  100f7f:	89 55 d0             	mov    %edx,-0x30(%ebp)
  100f82:	8b 7e 04             	mov    0x4(%esi),%edi
  100f85:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100f88:	e8 74 f8 ff ff       	call   100801 <sys_thread_self_get>
  100f8d:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  100f90:	8b 55 d0             	mov    -0x30(%ebp),%edx
  100f93:	51                   	push   %ecx
  100f94:	52                   	push   %edx
  100f95:	57                   	push   %edi
  100f96:	ff 75 f0             	pushl  -0x10(%ebp)
  100f99:	ff 75 ec             	pushl  -0x14(%ebp)
  100f9c:	ff 75 e8             	pushl  -0x18(%ebp)
  100f9f:	ff 75 e4             	pushl  -0x1c(%ebp)
  100fa2:	ff 75 e0             	pushl  -0x20(%ebp)
  100fa5:	ff 75 dc             	pushl  -0x24(%ebp)
  100fa8:	ff 75 d8             	pushl  -0x28(%ebp)
  100fab:	ff 75 d4             	pushl  -0x2c(%ebp)
  100fae:	50                   	push   %eax
  100faf:	68 f4 13 10 00       	push   $0x1013f4
  100fb4:	e8 6c fc ff ff       	call   100c25 <printk>
  100fb9:	83 c4 34             	add    $0x34,%esp
	/*
	 * Error was fatal to a kernel task or a fiber; invoke the system
	 * fatal error handling policy defined for the platform.
	 */

	_SysFatalErrorHandler(reason, pEsf);
  100fbc:	56                   	push   %esi
  100fbd:	53                   	push   %ebx
  100fbe:	e8 3c 01 00 00       	call   1010ff <_SysFatalErrorHandler>

00100fc3 <generic_exc_handle>:

#if CONFIG_EXCEPTION_DEBUG

static FUNC_NORETURN void generic_exc_handle(unsigned int vector,
					     const NANO_ESF *pEsf)
{
  100fc3:	55                   	push   %ebp
  100fc4:	89 e5                	mov    %esp,%ebp
  100fc6:	56                   	push   %esi
  100fc7:	89 c6                	mov    %eax,%esi
  100fc9:	53                   	push   %ebx
  100fca:	89 d3                	mov    %edx,%ebx
	printk("***** CPU exception %d\n", vector);
  100fcc:	50                   	push   %eax
  100fcd:	68 95 14 10 00       	push   $0x101495
  100fd2:	e8 4e fc ff ff       	call   100c25 <printk>
  100fd7:	59                   	pop    %ecx
  100fd8:	58                   	pop    %eax
	if ((1 << vector) & _EXC_ERROR_CODE_FAULTS) {
  100fd9:	b8 00 7d 02 00       	mov    $0x27d00,%eax
  100fde:	0f a3 f0             	bt     %esi,%eax
  100fe1:	73 0f                	jae    100ff2 <generic_exc_handle+0x2f>
		printk("***** Exception code: 0x%x\n", pEsf->errorCode);
  100fe3:	ff 73 20             	pushl  0x20(%ebx)
  100fe6:	68 ad 14 10 00       	push   $0x1014ad
  100feb:	e8 35 fc ff ff       	call   100c25 <printk>
  100ff0:	58                   	pop    %eax
  100ff1:	5a                   	pop    %edx
	}
	_NanoFatalErrorHandler(_NANO_ERR_CPU_EXCEPTION, pEsf);
  100ff2:	53                   	push   %ebx
  100ff3:	6a 06                	push   $0x6
  100ff5:	e8 fb fe ff ff       	call   100ef5 <_NanoFatalErrorHandler>

00100ffa <handle_exc_IV_DIVIDE_ERROR>:
FUNC_NORETURN void handle_exc_##vector(const NANO_ESF *pEsf) \
{ \
	generic_exc_handle(vector, pEsf); \
}

EXC_FUNC(IV_DIVIDE_ERROR);
  100ffa:	55                   	push   %ebp
  100ffb:	31 c0                	xor    %eax,%eax
  100ffd:	89 e5                	mov    %esp,%ebp
  100fff:	8b 55 08             	mov    0x8(%ebp),%edx
  101002:	e8 bc ff ff ff       	call   100fc3 <generic_exc_handle>

00101007 <handle_exc_IV_NON_MASKABLE_INTERRUPT>:
EXC_FUNC(IV_NON_MASKABLE_INTERRUPT);
  101007:	55                   	push   %ebp
  101008:	b8 02 00 00 00       	mov    $0x2,%eax
  10100d:	89 e5                	mov    %esp,%ebp
  10100f:	8b 55 08             	mov    0x8(%ebp),%edx
  101012:	e8 ac ff ff ff       	call   100fc3 <generic_exc_handle>

00101017 <handle_exc_IV_OVERFLOW>:
EXC_FUNC(IV_OVERFLOW);
  101017:	55                   	push   %ebp
  101018:	b8 04 00 00 00       	mov    $0x4,%eax
  10101d:	89 e5                	mov    %esp,%ebp
  10101f:	8b 55 08             	mov    0x8(%ebp),%edx
  101022:	e8 9c ff ff ff       	call   100fc3 <generic_exc_handle>

00101027 <handle_exc_IV_BOUND_RANGE>:
EXC_FUNC(IV_BOUND_RANGE);
  101027:	55                   	push   %ebp
  101028:	b8 05 00 00 00       	mov    $0x5,%eax
  10102d:	89 e5                	mov    %esp,%ebp
  10102f:	8b 55 08             	mov    0x8(%ebp),%edx
  101032:	e8 8c ff ff ff       	call   100fc3 <generic_exc_handle>

00101037 <handle_exc_IV_INVALID_OPCODE>:
EXC_FUNC(IV_INVALID_OPCODE);
  101037:	55                   	push   %ebp
  101038:	b8 06 00 00 00       	mov    $0x6,%eax
  10103d:	89 e5                	mov    %esp,%ebp
  10103f:	8b 55 08             	mov    0x8(%ebp),%edx
  101042:	e8 7c ff ff ff       	call   100fc3 <generic_exc_handle>

00101047 <handle_exc_IV_DEVICE_NOT_AVAILABLE>:
#ifndef CONFIG_FP_SHARING
EXC_FUNC(IV_DEVICE_NOT_AVAILABLE);
  101047:	55                   	push   %ebp
  101048:	b8 07 00 00 00       	mov    $0x7,%eax
  10104d:	89 e5                	mov    %esp,%ebp
  10104f:	8b 55 08             	mov    0x8(%ebp),%edx
  101052:	e8 6c ff ff ff       	call   100fc3 <generic_exc_handle>

00101057 <handle_exc_IV_DOUBLE_FAULT>:
#endif
EXC_FUNC(IV_DOUBLE_FAULT);
  101057:	55                   	push   %ebp
  101058:	b8 08 00 00 00       	mov    $0x8,%eax
  10105d:	89 e5                	mov    %esp,%ebp
  10105f:	8b 55 08             	mov    0x8(%ebp),%edx
  101062:	e8 5c ff ff ff       	call   100fc3 <generic_exc_handle>

00101067 <handle_exc_IV_INVALID_TSS>:
EXC_FUNC(IV_INVALID_TSS);
  101067:	55                   	push   %ebp
  101068:	b8 0a 00 00 00       	mov    $0xa,%eax
  10106d:	89 e5                	mov    %esp,%ebp
  10106f:	8b 55 08             	mov    0x8(%ebp),%edx
  101072:	e8 4c ff ff ff       	call   100fc3 <generic_exc_handle>

00101077 <handle_exc_IV_SEGMENT_NOT_PRESENT>:
EXC_FUNC(IV_SEGMENT_NOT_PRESENT);
  101077:	55                   	push   %ebp
  101078:	b8 0b 00 00 00       	mov    $0xb,%eax
  10107d:	89 e5                	mov    %esp,%ebp
  10107f:	8b 55 08             	mov    0x8(%ebp),%edx
  101082:	e8 3c ff ff ff       	call   100fc3 <generic_exc_handle>

00101087 <handle_exc_IV_STACK_FAULT>:
EXC_FUNC(IV_STACK_FAULT);
  101087:	55                   	push   %ebp
  101088:	b8 0c 00 00 00       	mov    $0xc,%eax
  10108d:	89 e5                	mov    %esp,%ebp
  10108f:	8b 55 08             	mov    0x8(%ebp),%edx
  101092:	e8 2c ff ff ff       	call   100fc3 <generic_exc_handle>

00101097 <handle_exc_IV_GENERAL_PROTECTION>:
EXC_FUNC(IV_GENERAL_PROTECTION);
  101097:	55                   	push   %ebp
  101098:	b8 0d 00 00 00       	mov    $0xd,%eax
  10109d:	89 e5                	mov    %esp,%ebp
  10109f:	8b 55 08             	mov    0x8(%ebp),%edx
  1010a2:	e8 1c ff ff ff       	call   100fc3 <generic_exc_handle>

001010a7 <handle_exc_IV_PAGE_FAULT>:
EXC_FUNC(IV_PAGE_FAULT);
  1010a7:	55                   	push   %ebp
  1010a8:	b8 0e 00 00 00       	mov    $0xe,%eax
  1010ad:	89 e5                	mov    %esp,%ebp
  1010af:	8b 55 08             	mov    0x8(%ebp),%edx
  1010b2:	e8 0c ff ff ff       	call   100fc3 <generic_exc_handle>

001010b7 <handle_exc_IV_X87_FPU_FP_ERROR>:
EXC_FUNC(IV_X87_FPU_FP_ERROR);
  1010b7:	55                   	push   %ebp
  1010b8:	b8 10 00 00 00       	mov    $0x10,%eax
  1010bd:	89 e5                	mov    %esp,%ebp
  1010bf:	8b 55 08             	mov    0x8(%ebp),%edx
  1010c2:	e8 fc fe ff ff       	call   100fc3 <generic_exc_handle>

001010c7 <handle_exc_IV_ALIGNMENT_CHECK>:
EXC_FUNC(IV_ALIGNMENT_CHECK);
  1010c7:	55                   	push   %ebp
  1010c8:	b8 11 00 00 00       	mov    $0x11,%eax
  1010cd:	89 e5                	mov    %esp,%ebp
  1010cf:	8b 55 08             	mov    0x8(%ebp),%edx
  1010d2:	e8 ec fe ff ff       	call   100fc3 <generic_exc_handle>

001010d7 <handle_exc_IV_MACHINE_CHECK>:
EXC_FUNC(IV_MACHINE_CHECK);
  1010d7:	55                   	push   %ebp
  1010d8:	b8 12 00 00 00       	mov    $0x12,%eax
  1010dd:	89 e5                	mov    %esp,%ebp
  1010df:	8b 55 08             	mov    0x8(%ebp),%edx
  1010e2:	e8 dc fe ff ff       	call   100fc3 <generic_exc_handle>

001010e7 <nano_cpu_idle>:
 * will be issued causing a low-power consumption sleep mode.
 *
 * @return N/A
 */
void nano_cpu_idle(void)
{
  1010e7:	55                   	push   %ebp
  1010e8:	89 e5                	mov    %esp,%ebp
#if defined(CONFIG_NANOKERNEL) && defined(CONFIG_TICKLESS_IDLE)
	__asm__ volatile("cli");
	_power_save_idle();
#endif

	__asm__ volatile (
  1010ea:	fb                   	sti    
  1010eb:	f4                   	hlt    
	    "sti\n\t"
	    "hlt\n\t");
}
  1010ec:	5d                   	pop    %ebp
  1010ed:	c3                   	ret    

001010ee <nano_cpu_atomic_idle>:
 *
 * @return N/A
 */

void nano_cpu_atomic_idle(unsigned int imask)
{
  1010ee:	55                   	push   %ebp
  1010ef:	89 e5                	mov    %esp,%ebp

#if defined(CONFIG_NANOKERNEL) && defined(CONFIG_TICKLESS_IDLE)
	_power_save_idle();
#endif

	__asm__ volatile (
  1010f1:	fb                   	sti    
  1010f2:	f4                   	hlt    
	     * atomically re-enable interrupts and enter a low-power mode.
	     */
	    "hlt\n\t");

	/* restore interrupt lockout state before returning to caller */
	if (!(imask & 0x200)) {
  1010f3:	f7 45 08 00 02 00 00 	testl  $0x200,0x8(%ebp)
  1010fa:	75 01                	jne    1010fd <nano_cpu_atomic_idle+0xf>
		_int_latency_start();
		__asm__ volatile("cli");
  1010fc:	fa                   	cli    
	}
}
  1010fd:	5d                   	pop    %ebp
  1010fe:	c3                   	ret    

001010ff <_SysFatalErrorHandler>:
 *
 * @return This function does not return.
 */
FUNC_NORETURN void _SysFatalErrorHandler(unsigned int reason,
					 const NANO_ESF * pEsf)
{
  1010ff:	55                   	push   %ebp
  101100:	89 e5                	mov    %esp,%ebp
  101102:	53                   	push   %ebx
	nano_context_type_t curCtx = sys_execution_context_type_get();
  101103:	e8 03 f7 ff ff       	call   10080b <sys_execution_context_type_get>
  101108:	89 c3                	mov    %eax,%ebx

	ARG_UNUSED(reason);
	ARG_UNUSED(pEsf);

	if ((curCtx != NANO_CTX_ISR) && !_is_thread_essential(NULL)) {
  10110a:	85 c0                	test   %eax,%eax
  10110c:	74 1e                	je     10112c <_SysFatalErrorHandler+0x2d>
  10110e:	6a 00                	push   $0x0
  101110:	e8 19 f7 ff ff       	call   10082e <_is_thread_essential>
  101115:	5a                   	pop    %edx
  101116:	85 c0                	test   %eax,%eax
  101118:	75 12                	jne    10112c <_SysFatalErrorHandler+0x2d>
			PRINTK("Fatal task error! Aborting task.\n");
			_TaskAbort();
		} else
#endif /* CONFIG_MICROKERNEL */
		{
			PRINTK("Fatal fiber error! Aborting fiber.\n");
  10111a:	68 c9 14 10 00       	push   $0x1014c9
  10111f:	e8 01 fb ff ff       	call   100c25 <printk>
  101124:	59                   	pop    %ecx
			fiber_abort();
  101125:	e8 34 f6 ff ff       	call   10075e <fiber_abort>
  10112a:	eb 13                	jmp    10113f <_SysFatalErrorHandler+0x40>
		 */

		static const char * const ctxText[] = {"ISR", "essential fiber",
					  "essential task"};

		PRINTK("Fatal %s error! Spinning...\n", ctxText[curCtx]);
  10112c:	ff 34 9d 70 15 10 00 	pushl  0x101570(,%ebx,4)
  101133:	68 ed 14 10 00       	push   $0x1014ed
  101138:	e8 e8 fa ff ff       	call   100c25 <printk>
  10113d:	58                   	pop    %eax
  10113e:	5a                   	pop    %edx
  10113f:	eb fe                	jmp    10113f <_SysFatalErrorHandler+0x40>

00101141 <_cache_line_size_get>:
	#define CPUID_CACHE_LINE_MASK (0xff << 8)

	GTEXT(_cache_line_size_get)

SECTION_FUNC(TEXT, _cache_line_size_get)
	pushl %ebx
  101141:	53                   	push   %ebx
	movl $1, %eax
  101142:	b8 01 00 00 00       	mov    $0x1,%eax
	cpuid
  101147:	0f a2                	cpuid  
	movl %ebx, %eax
  101149:	89 d8                	mov    %ebx,%eax
	andl $CPUID_CACHE_LINE_MASK, %eax
  10114b:	25 00 ff 00 00       	and    $0xff00,%eax
	shrl $5,%eax	/* shift right 8 to get value, then multiple by 8
  101150:	c1 e8 05             	shr    $0x5,%eax
					 * to get cache line size */
	popl %ebx
  101153:	5b                   	pop    %ebx
	ret
  101154:	c3                   	ret    

00101155 <init_cache>:
#else
#define init_cache_line_size() do { } while ((0))
#endif

static int init_cache(struct device *unused)
{
  101155:	55                   	push   %ebp
  101156:	89 e5                	mov    %esp,%ebp

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  101158:	e8 e4 ff ff ff       	call   101141 <_cache_line_size_get>

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  10115d:	5d                   	pop    %ebp

#if defined(CONFIG_CACHE_LINE_SIZE_DETECT)
size_t sys_cache_line_size;
static void init_cache_line_size(void)
{
	sys_cache_line_size = _cache_line_size_get();
  10115e:	a3 1c 1f 10 00       	mov    %eax,0x101f1c

	init_cache_flush();
	init_cache_line_size();

	return 0;
}
  101163:	31 c0                	xor    %eax,%eax
  101165:	c3                   	ret    

00101166 <_ExcEntNoErr>:
 * This is very similar to _ExcEnt() but the stack is first massaged
 * so that a dummy error code is inserted.
 */
SECTION_FUNC(TEXT, _ExcEntNoErr)
	/* Clear direction flag, auto-restored when the exception exits */
	cld
  101166:	fc                   	cld    

	/* Stash current value of ECX to free up the register */
	pushl	%ecx
  101167:	51                   	push   %ecx

	/* Save the return address of the stub into ECX */
	movl	4(%esp), %ecx
  101168:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	/*
	 * The spot for the error code contains useless data, but
	 * we don't particularly care since it will be unused.
	 */
	jmp	_ExcEntSetupDone
  10116c:	e9 04 00 00 00       	jmp    101175 <_ExcEntSetupDone>

00101171 <_ExcEnt>:
	 *
	 * Clear the direction flag.  It is automatically restored when the
	 * exception exits.
	 */

	cld
  101171:	fc                   	cld    
	/*
	 * Swap ecx and return address on the current stack;
	 * this saves ecx on the stack without losing knowledge
	 * of how to get back to the exception stub.
	 */
	xchgl	%ecx, (%esp)
  101172:	87 0c 24             	xchg   %ecx,(%esp)

00101175 <_ExcEntSetupDone>:

	/*
	 * Push the remaining volatile registers on the existing stack.
	 */

	pushl	%eax
  101175:	50                   	push   %eax
	pushl	%edx
  101176:	52                   	push   %edx
	/*
	 * Push the cooperative registers on the existing stack as they are
	 * required by debug tools.
	 */

	pushl	%edi
  101177:	57                   	push   %edi
	pushl	%esi
  101178:	56                   	push   %esi
	pushl	%ebx
  101179:	53                   	push   %ebx
	pushl	%ebp
  10117a:	55                   	push   %ebp

	leal	44(%esp), %eax   /* Calculate ESP before interrupt occurred */
  10117b:	8d 44 24 2c          	lea    0x2c(%esp),%eax
	pushl	%eax             /* Save calculated ESP */
  10117f:	50                   	push   %eax
	 * Test IF bit of saved EFLAGS and re-enable interrupts if IF=1.
	 */

	/* ESP is still pointing to the ESF at this point */

	testl	$0x200, __NANO_ESF_eflags_OFFSET(%esp)
  101180:	f7 44 24 2c 00 02 00 	testl  $0x200,0x2c(%esp)
  101187:	00 
	je	allDone
  101188:	74 01                	je     10118b <allDone>
	sti
  10118a:	fb                   	sti    

0010118b <allDone>:

BRANCH_LABEL(allDone)
#if CONFIG_X86_IAMCU
	movl	%esp, %eax		/* NANO_ESF * parameter */
#else
	pushl	%esp			/* push NANO_ESF * parameter */
  10118b:	54                   	push   %esp
#endif
	jmp	*%ecx			/* "return" back to stub */
  10118c:	ff e1                	jmp    *%ecx

0010118e <_ExcExit>:

SECTION_FUNC(TEXT, _ExcExit)
	/* On entry, interrupts may or may not be enabled. */

#ifndef CONFIG_X86_IAMCU
	popl %ecx      /* discard the NANO_ESF * parameter */
  10118e:	59                   	pop    %ecx
	 * Pop the non-volatile registers from the stack.
	 * Note that debug tools may have altered the saved register values while
	 * the task was stopped, and we want to pick up the altered values.
	 */

	popl	%ebp		/* Discard saved ESP */
  10118f:	5d                   	pop    %ebp
	popl	%ebp
  101190:	5d                   	pop    %ebp
	popl	%ebx
  101191:	5b                   	pop    %ebx
	popl	%esi
  101192:	5e                   	pop    %esi
	popl	%edi
  101193:	5f                   	pop    %edi

	/* restore edx and ecx which are always saved on the stack */

	popl	%edx
  101194:	5a                   	pop    %edx
	popl	%eax
  101195:	58                   	pop    %eax
	popl	%ecx
  101196:	59                   	pop    %ecx

	addl	$4, %esp	/* "pop" error code */
  101197:	83 c4 04             	add    $0x4,%esp

	/* Pop of EFLAGS will re-enable interrupts and restore direction flag */
	iret
  10119a:	cf                   	iret   

0010119b <handle_exc_IV_DIVIDE_ERRORStub>:
#if CONFIG_EXCEPTION_DEBUG

#define EXC_HANDLER(vec) NANO_CPU_EXC_CONNECT_NO_ERR(handle_exc_##vec, vec, 0)
#define EXC_HANDLER_CODE(vec) NANO_CPU_EXC_CONNECT(handle_exc_##vec, vec, 0)

EXC_HANDLER(IV_DIVIDE_ERROR)
  10119b:	e8 c6 ff ff ff       	call   101166 <_ExcEntNoErr>
  1011a0:	e8 55 fe ff ff       	call   100ffa <handle_exc_IV_DIVIDE_ERROR>
  1011a5:	e9 e4 ff ff ff       	jmp    10118e <_ExcExit>

001011aa <handle_exc_IV_NON_MASKABLE_INTERRUPTStub>:
EXC_HANDLER(IV_NON_MASKABLE_INTERRUPT)
  1011aa:	e8 b7 ff ff ff       	call   101166 <_ExcEntNoErr>
  1011af:	e8 53 fe ff ff       	call   101007 <handle_exc_IV_NON_MASKABLE_INTERRUPT>
  1011b4:	e9 d5 ff ff ff       	jmp    10118e <_ExcExit>

001011b9 <handle_exc_IV_OVERFLOWStub>:
EXC_HANDLER(IV_OVERFLOW)
  1011b9:	e8 a8 ff ff ff       	call   101166 <_ExcEntNoErr>
  1011be:	e8 54 fe ff ff       	call   101017 <handle_exc_IV_OVERFLOW>
  1011c3:	e9 c6 ff ff ff       	jmp    10118e <_ExcExit>

001011c8 <handle_exc_IV_BOUND_RANGEStub>:
EXC_HANDLER(IV_BOUND_RANGE)
  1011c8:	e8 99 ff ff ff       	call   101166 <_ExcEntNoErr>
  1011cd:	e8 55 fe ff ff       	call   101027 <handle_exc_IV_BOUND_RANGE>
  1011d2:	e9 b7 ff ff ff       	jmp    10118e <_ExcExit>

001011d7 <handle_exc_IV_INVALID_OPCODEStub>:
EXC_HANDLER(IV_INVALID_OPCODE)
  1011d7:	e8 8a ff ff ff       	call   101166 <_ExcEntNoErr>
  1011dc:	e8 56 fe ff ff       	call   101037 <handle_exc_IV_INVALID_OPCODE>
  1011e1:	e9 a8 ff ff ff       	jmp    10118e <_ExcExit>

001011e6 <handle_exc_IV_DEVICE_NOT_AVAILABLEStub>:
#ifndef CONFIG_FP_SHARING
EXC_HANDLER(IV_DEVICE_NOT_AVAILABLE)
  1011e6:	e8 7b ff ff ff       	call   101166 <_ExcEntNoErr>
  1011eb:	e8 57 fe ff ff       	call   101047 <handle_exc_IV_DEVICE_NOT_AVAILABLE>
  1011f0:	e9 99 ff ff ff       	jmp    10118e <_ExcExit>

001011f5 <handle_exc_IV_DOUBLE_FAULTStub>:
#endif
EXC_HANDLER_CODE(IV_DOUBLE_FAULT)
  1011f5:	e8 77 ff ff ff       	call   101171 <_ExcEnt>
  1011fa:	e8 58 fe ff ff       	call   101057 <handle_exc_IV_DOUBLE_FAULT>
  1011ff:	e9 8a ff ff ff       	jmp    10118e <_ExcExit>

00101204 <handle_exc_IV_INVALID_TSSStub>:
EXC_HANDLER_CODE(IV_INVALID_TSS)
  101204:	e8 68 ff ff ff       	call   101171 <_ExcEnt>
  101209:	e8 59 fe ff ff       	call   101067 <handle_exc_IV_INVALID_TSS>
  10120e:	e9 7b ff ff ff       	jmp    10118e <_ExcExit>

00101213 <handle_exc_IV_SEGMENT_NOT_PRESENTStub>:
EXC_HANDLER_CODE(IV_SEGMENT_NOT_PRESENT)
  101213:	e8 59 ff ff ff       	call   101171 <_ExcEnt>
  101218:	e8 5a fe ff ff       	call   101077 <handle_exc_IV_SEGMENT_NOT_PRESENT>
  10121d:	e9 6c ff ff ff       	jmp    10118e <_ExcExit>

00101222 <handle_exc_IV_STACK_FAULTStub>:
EXC_HANDLER_CODE(IV_STACK_FAULT)
  101222:	e8 4a ff ff ff       	call   101171 <_ExcEnt>
  101227:	e8 5b fe ff ff       	call   101087 <handle_exc_IV_STACK_FAULT>
  10122c:	e9 5d ff ff ff       	jmp    10118e <_ExcExit>

00101231 <handle_exc_IV_GENERAL_PROTECTIONStub>:
EXC_HANDLER_CODE(IV_GENERAL_PROTECTION)
  101231:	e8 3b ff ff ff       	call   101171 <_ExcEnt>
  101236:	e8 5c fe ff ff       	call   101097 <handle_exc_IV_GENERAL_PROTECTION>
  10123b:	e9 4e ff ff ff       	jmp    10118e <_ExcExit>

00101240 <handle_exc_IV_PAGE_FAULTStub>:
EXC_HANDLER_CODE(IV_PAGE_FAULT)
  101240:	e8 2c ff ff ff       	call   101171 <_ExcEnt>
  101245:	e8 5d fe ff ff       	call   1010a7 <handle_exc_IV_PAGE_FAULT>
  10124a:	e9 3f ff ff ff       	jmp    10118e <_ExcExit>

0010124f <handle_exc_IV_X87_FPU_FP_ERRORStub>:
EXC_HANDLER(IV_X87_FPU_FP_ERROR)
  10124f:	e8 12 ff ff ff       	call   101166 <_ExcEntNoErr>
  101254:	e8 5e fe ff ff       	call   1010b7 <handle_exc_IV_X87_FPU_FP_ERROR>
  101259:	e9 30 ff ff ff       	jmp    10118e <_ExcExit>

0010125e <handle_exc_IV_ALIGNMENT_CHECKStub>:
EXC_HANDLER_CODE(IV_ALIGNMENT_CHECK)
  10125e:	e8 0e ff ff ff       	call   101171 <_ExcEnt>
  101263:	e8 5f fe ff ff       	call   1010c7 <handle_exc_IV_ALIGNMENT_CHECK>
  101268:	e9 21 ff ff ff       	jmp    10118e <_ExcExit>

0010126d <handle_exc_IV_MACHINE_CHECKStub>:
EXC_HANDLER(IV_MACHINE_CHECK)
  10126d:	e8 f4 fe ff ff       	call   101166 <_ExcEntNoErr>
  101272:	e8 60 fe ff ff       	call   1010d7 <handle_exc_IV_MACHINE_CHECK>
  101277:	e9 12 ff ff ff       	jmp    10118e <_ExcExit>

0010127c <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
  10127c:	55                   	push   %ebp
  10127d:	89 e5                	mov    %esp,%ebp
/* size of the ISR_LIST structure. Used by linker scripts */

GEN_ABSOLUTE_SYM(__ISR_LIST_SIZEOF, sizeof(ISR_LIST));


GEN_ABS_SYM_END
  10127f:	5d                   	pop    %ebp
  101280:	c3                   	ret    
